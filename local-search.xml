<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker学习</title>
    <link href="/2024/08/17/CICD/Docker%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/08/17/CICD/Docker%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="docker学习啊啊啊啊"><a href="#docker学习啊啊啊啊" class="headerlink" title="docker学习啊啊啊啊"></a>docker学习啊啊啊啊</h1><h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>docker是一个容器，装应用的</p><h2 id="docker和vmvare比较"><a href="#docker和vmvare比较" class="headerlink" title="docker和vmvare比较"></a>docker和vmvare比较</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_12-06-27.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_12-11-09.png"></p><h2 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_12-18-08.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_12-21-33.png"></p><ul><li>Docker 汽车引擎</li><li>Dockerfile 汽车图纸</li><li>Images:类似于样板车</li><li>Container:把一些汽车的零件拼接在一起</li><li>Dcoker Compose 老司机    批量运行镜像</li><li>Docker Volume 汽车的邮箱  数据备份</li><li>Docker Swarm 交通枢纽     管理容器</li><li>Docker Register 4s店</li></ul><h2 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h2><p>参考文章 <a href="https://www.cnblogs.com/keyou1/p/11511067.html">https://www.cnblogs.com/keyou1/p/11511067.html</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li>真正提供服务的是Containers容器</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_12-35-18.png"></p><h4 id="获取Images镜像三种方式"><a href="#获取Images镜像三种方式" class="headerlink" title="获取Images镜像三种方式"></a>获取Images镜像三种方式</h4><ul><li>从Docker Register使用docker pull下载镜像到本地，镜像里包含安装所需要的所有资源。</li><li>dockerfile文本文件 私有镜像官方站点没有，自己构建一个镜像，通过dockerfile的一些命令。</li><li>打包别人的安装包压缩包，导入到Images中</li></ul><h4 id="dockerhub地址"><a href="#dockerhub地址" class="headerlink" title="dockerhub地址"></a>dockerhub地址</h4><p><a href="https://registry.hub.docker.com/">https://registry.hub.docker.com/</a></p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-14_15-50-58.png"></p><h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><ul><li>docker images 查看已下载镜像</li><li>docker pull centos 下载镜像</li><li>docker pull python:3.7-alpine 下载指定版本镜像</li><li>docker search python 搜索镜像</li><li>docker image rm openjdk  &#x3D; docker rmi -f openjdk 删除镜像  -f强制删除</li><li>docker inspect python:3.7-alpine 查看镜像详细信息</li><li>docker history centos 查看镜像历史信息</li></ul><h4 id="docker-run命令"><a href="#docker-run命令" class="headerlink" title="docker run命令"></a>docker run命令</h4><p>宿主机：docker安装在哪一台阿里云服务器上</p><ul><li>docker run -it python:alpine &#x2F;bin&#x2F;sh  -it和容器进行交互,开启一个python命令行界面</li><li>docker run -it –name my_python python:alpine python  –name自主定义启动的容器名称</li><li>docker run -it -d –name my_python python:alpine python  -d 在后台运行容器</li><li>docker run -it -d –name my_python -p 8000:8012 容器名称 -p端口映射 宿主机的8000端口和容器的80端口做映射后，可以通过8000端口来访问80端口的服务。8000宿主机端口（服务器端口）8012容器当中端口</li><li>docker run -it -d –name my_python -P python:alpine 使用宿主机中的随机端口和容器的80端口做映射</li><li>docker run -it -d –name my_python -v $PWD:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html -P python:alpine -v资源共享 宿主机中的&#x2F;目录文件和容器中的目录&#x2F;文件映射共享</li></ul><h4 id="容器相关操作"><a href="#容器相关操作" class="headerlink" title="容器相关操作"></a>容器相关操作</h4><ul><li>docker stop 容器名称&#x2F;ID  将运行的容器停止</li><li>docker restart 容器名称&#x2F;ID 启动容器</li><li>docker pause 容器名称&#x2F;ID 暂停容器</li><li>docker unpause 容器名称&#x2F;ID 启动容器</li><li>docker rm -f 容器名称&#x2F;ID  强制删除正在运行的容器</li><li>docker top 容器名称 查看进程信息</li><li>docker exec -it 容器名称 &#x2F;bin&#x2F;sh 进入正在运行的容器</li><li>docker run –rm 退出后会自动删掉容器 docker run –rm -it –name myweb -P nginx</li><li>docker ps 查看正在提供业务 运行的容器信息</li><li>docker ps -a 查看所有容器信息</li><li>docker stats ngix 查看容器资源利用率</li></ul><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><ul><li>1.docker login 输入用户名密码</li><li>2.docker tag redis 用户名&#x2F;rediszhou 修改tag添加版本信息</li><li>3.docker push 用户名&#x2F;rediszhou 上传镜像</li><li>4.下载镜像 docker pull 用户名&#x2F;rediszhou</li><li>5.导出为压缩文件 docker save -o apitest.tar apitest:latest</li><li>6.导入压缩文件 docker load -i apitest.tar</li></ul><h2 id="volume"><a href="#volume" class="headerlink" title="volume"></a>volume</h2><ul><li>使用数据卷实现数据持久化</li><li>数据备份&#x2F;数据共享</li></ul><h5 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h5><ul><li>1.创建 docker volume create</li><li>2.查看 docker volume inspect</li><li>3.挂载 docker run -v 宿主机目录：容器目录</li><li>4.删除 docker volume rm</li></ul><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>dockerfile为构建镜像的文本文件</p><ul><li>1.base image基础镜像</li><li>2.往往在一个dockerfile文件中只有一个FROM指令（多阶段构建除外）</li><li>3.镜像名：版本（如果本地没有，会自动去dockerhub中下载）FROM python:alpine</li><li>4.LABEL  指定docker中的元数据信息</li><li>5.maintainer 指定当前Dockerfile文件的维护者(作者)</li><li>6.description指定功能描述信息<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> python:alpine<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;zhounuo &lt;744700813@qq.com&gt;&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> description=<span class="hljs-string">&quot;this is a sample&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>7.相当于cd命令，切换到容器中的某个目录，如果指定的目录不存在，会自动创建<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br></code></pre></td></tr></table></figure></li><li>8.相当于cp命令，将宿主机中的目录或者文件复制粘贴到容器中<ul><li>a.第一个参数为宿主机中目录或者文件（相对路径或绝对路径）相对于dockerfile所属路径</li><li>b.第二个参数为容器中的目录或者文件（相对路径或绝对路径）<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">COPY</span> requirements.txt ./  复制requirements.txt粘贴到 <span class="hljs-keyword">app</span>目录下 = <span class="hljs-keyword">COPY</span> requirements.txt /<span class="hljs-keyword">app</span>/<br><span class="hljs-keyword">COPY</span> requirements.txt ./<span class="hljs-keyword">dir</span>/ 将requirements.txt复制粘贴到<span class="hljs-keyword">app</span>/<span class="hljs-keyword">dir</span>目录下<br><span class="hljs-keyword">COPY</span> requirements.txt ./<span class="hljs-keyword">dir</span> 将requirements.txt复制粘贴到<span class="hljs-keyword">app</span>目录下重命名为<span class="hljs-keyword">dir</span><br></code></pre></td></tr></table></figure></li></ul></li><li>9.ADD<ul><li>a.跟COPY功能类似</li><li>b.如果第二个参数为本地的压缩文件，那么会自动解压，将解压之后的文件复制粘贴到容器</li><li>c.如果第一个参数为远程的路径，那么会自动下载，将下载之后的文件复制粘贴到中期<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">ADD</span> one.zip ./<br></code></pre></td></tr></table></figure></li></ul></li><li>10.RUN 容器中执行linux命令<ul><li>a.–no-cache-dir安装过程中不缓存</li><li>b.RUN指令越多，那么构建出来的镜像层级就越多，镜像尺寸就会越大<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">RUN pip install -i https://pypi.douban.<span class="hljs-keyword">com</span>/simple --<span class="hljs-keyword">no</span>-cache-dir -r requirements.txt &amp;&amp; RUN <span class="hljs-keyword">ls</span> / &amp;&amp; \<br><span class="hljs-keyword">ps</span> -ef | <span class="hljs-keyword">grep</span> nginx<br></code></pre></td></tr></table></figure></li></ul></li><li>11.CMD 在容器运行时会自动执行指令<ul><li>a.与ENTERPOINT类似 ENTERPOINT [“python”,”fun.py”]</li><li>b.exec类型的命令[“指令”,”参数1”,”参数2”]为json数组（必须得使用双引号）</li><li>c.优先使用exec类型的命令</li><li>d.shell类型的命令 CMD python fun.py</li><li>e.如果有多个CMD命令或者ENTERPOINT命令，只会执行最后一个。</li><li>f.如果在容器运行（docker run)有指定命令的话，那么CMD会被忽略,所有CMD往往会作为默认参数。</li><li>g:如果在容器运行（docker run)有指定命令的话，那么ENTERPOINT不会被忽略，命令会作为ENTERPOINT的参数，相当于在列表中追加两个元素 docker run –rm keyou1&#x2F;fun:v1 <a href="http://www.baidu.com相当于/">www.baidu.com相当于</a> ENTERPOINT [“ping”，”<a href="http://www.baidu.com"]">www.baidu.com&quot;]</a></li><li>h.如果ENTERPOINT和CMD一起用，那么CMD会作为ENTERPOINT的默认参数  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">ENTERPOINT <span class="hljs-selector-attr">[<span class="hljs-string">&quot;ping&quot;</span>]</span><br>CMD <span class="hljs-selector-attr">[<span class="hljs-string">&quot;114.114.114.114&quot;</span>]</span><br></code></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">COPY</span><span class="language-bash"> . . 将宿主机中当前目录下文件复制粘贴到容器中当前目录下</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;python&quot;</span>,<span class="hljs-string">&quot;fun.py&quot;</span>]</span><br></code></pre></td></tr></table></figure></li></ul></li><li>12 ENV 在容器内创建环境变量 左右两侧不要有空格<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ENV <span class="hljs-attribute">username</span>=keyou \<br>    <span class="hljs-attribute">password</span>=123456<br></code></pre></td></tr></table></figure></li><li>13.VOLUME 指定容器运行时需要映射出去的目录（容器中）。然后才能使用-v命令<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">VOLUME</span><span class="language-bash">  /app</span><br></code></pre></td></tr></table></figure></li><li>14.EXPOSE 指定容器运行时需要映射出去的端口号（容器中的端口号）<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">EXPOSE</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure></li><li>15.可以使用如下命令将Dockerfile文件构建成镜像 <ul><li>a.docker build -t 用户名&#x2F;镜像名:版本号 .</li><li>b. .指定为当前路径下寻找Dockerfile</li><li>c.默认文件名为Dockerfile</li><li>d.如果文件名不为Dockerfile，那么可以使用 -f手动指定 docker build -t test -f Dockerfile11 .</li><li>e.构建完后要运行 docker run –rm test<br>-16.可以在shell脚本中启动多个服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dockerenterpont.sh</span><br><br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">cat</span> /etc/passwd<br><br></code></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">FROM python:alpine<br><span class="hljs-keyword">COPY</span> dockerenterpont.<span class="hljs-keyword">sh</span> /dockerenterpont.<span class="hljs-keyword">sh</span>  把文件<span class="hljs-keyword">copy</span>到容器<br><span class="hljs-keyword">RUN</span> chmod a+x dockerenterpont.<span class="hljs-keyword">sh</span>   添加执行权限<br>ENTERPOINT[<span class="hljs-string">&quot;/dockerenterpont.sh&quot;</span>]  执行<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><h4 id="1-docker0"><a href="#1-docker0" class="headerlink" title="1.docker0"></a>1.docker0</h4><ul><li>默认容器与宿主机之间沟通的桥梁</li></ul><h4 id="2-网络类型"><a href="#2-网络类型" class="headerlink" title="2.网络类型"></a>2.网络类型</h4><ul><li>bridge<ul><li>nat网络模型</li><li>虚拟交换机</li></ul></li><li>host<ul><li>与宿主机共享网络</li><li>–net&#x3D;host</li></ul></li><li>none<ul><li>不配置网络</li><li>–net&#x3D;none</li></ul></li><li>overlay<ul><li>不同网络进行通信<br>与一个容器共享网络 –net&#x3D;container:ContainerName</li></ul></li></ul><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li>docker network create mynet 创建默认docker0网络</li><li>docker network create -d none mynet 创建none类型网络</li><li>docker network inspect mynet 查看网络信息</li><li>docker run –name my_web -d -v $PWD&#x2F;index.html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;index.html –network mynet -P nginx:alpin 加入到特定的网络</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2>]]></content>
    
    
    <categories>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell命令</title>
    <link href="/2024/04/16/CICD/shell%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/04/16/CICD/shell%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><img src="/../.vuepress/public/picture/Snipaste_2021-06-01_16-45-57.png"></p><ol><li>什么是 Shell 脚本？它有什么作用？<br>答案： Shell 脚本是一种用于自动化任务的程序，它是由一系列 Shell 命令构成的文本文件，通常以 .sh 为扩展名。Shell 脚本可以执行文件操作、系统管理、任务调度、日志分析、服务启动和停止等各种任务。</li></ol><p>作用：</p><p>自动化常见的系统管理任务。<br>自动化测试、部署和构建流程。<br>执行批量操作，如文件处理、日志分析。<br>提高工作效率，减少人工操作。<br>2. 如何在 Shell 脚本中定义变量？<br>答案： 在 Shell 脚本中，定义变量时不需要使用关键字，直接赋值即可。例如：</p><p>bash<br>复制代码<br>name&#x3D;”John”    # 定义变量<br>echo $name     # 输出变量<br>注意：</p><p>变量赋值时 不能有空格，name&#x3D;John 是正确的，name &#x3D; John 是错误的。<br>使用变量时，前面需要加 $，如 echo $name。<br>3. 如何在 Shell 脚本中读取用户输入？<br>答案： 可以使用 read 命令来获取用户输入：</p><p>bash<br>复制代码<br>echo “请输入你的名字:”<br>read name<br>echo “你好，$name!”<br>4. Shell 脚本中如何判断一个文件是否存在？<br>答案： 可以使用 if 语句结合 -e 或 -f 来判断文件是否存在：</p><p>-e 判断文件是否存在。<br>-f 判断是否是一个普通文件。<br>示例：</p><p>bash<br>复制代码<br>if [ -e &#x2F;path&#x2F;to&#x2F;file ]; then<br>    echo “文件存在”<br>else<br>    echo “文件不存在”<br>fi<br>5. 如何在 Shell 脚本中进行条件判断？<br>答案： Shell 脚本中的条件判断可以使用 if、elif 和 else，并且条件表达式可以用方括号 [ ] 来表示。</p><p>示例：</p><p>bash<br>复制代码<br>#!&#x2F;bin&#x2F;bash<br>if [ $1 -gt 10 ]; then<br>    echo “参数大于 10”<br>else<br>    echo “参数小于或等于 10”<br>fi<br>-gt 表示大于，-lt 表示小于，-eq 表示等于，-ne 表示不等于。<br>6. 如何在 Shell 脚本中进行循环？<br>答案： 常见的循环语句有 for 和 while 循环。</p><p>for 循环：<br>bash<br>复制代码<br>for i in {1..5}<br>do<br>    echo “i is $i”<br>done<br>while 循环：<br>bash<br>复制代码<br>count&#x3D;1<br>while [ $count -le 5 ]<br>do<br>    echo “count is $count”<br>    ((count++))<br>done<br>7. 如何在 Shell 脚本中处理函数？<br>答案： Shell 脚本中可以定义函数，并通过函数名来调用。</p><p>示例：</p><p>bash<br>复制代码<br>#!&#x2F;bin&#x2F;bash<br>my_function() {<br>    echo “这是一个函数”<br>}</p><h1 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h1><p>my_function<br>8. 如何查看并修改 Shell 脚本的执行权限？<br>答案： 使用 chmod 命令来修改脚本的执行权限。</p><p>给脚本加执行权限：</p><p>bash<br>复制代码<br>chmod +x script.sh<br>查看脚本的权限：</p><p>bash<br>复制代码<br>ls -l script.sh<br>9. 在 Shell 脚本中如何处理错误？<br>答案：</p><p>使用 $? 来获取上一个命令的退出状态码。状态码为 0 表示命令成功执行，其他值表示失败。<br>示例：</p><p>bash<br>复制代码<br>#!&#x2F;bin&#x2F;bash<br>echo “Hello”<br>if [ $? -eq 0 ]; then<br>    echo “命令执行成功”<br>else<br>    echo “命令执行失败”<br>fi<br>可以使用 set -e 来让脚本在遇到错误时立即退出：<br>bash<br>复制代码<br>set -e<br>10. 如何在 Shell 脚本中重定向输出到文件？<br>答案：</p><p>使用 &gt; 将标准输出重定向到文件，如果文件不存在则创建。</p><p>bash<br>复制代码<br>echo “Hello, World!” &gt; output.txt<br>使用 &gt;&gt; 将标准输出追加到文件末尾。</p><p>bash<br>复制代码<br>echo “Hello again!” &gt;&gt; output.txt<br>2&gt; 用来重定向错误输出。</p><p>bash<br>复制代码<br>ls non_existing_file 2&gt; error.log<br>11. Shell 脚本中如何处理日志文件？<br>答案： Shell 脚本可以通过重定向输出到日志文件来进行日志记录，常见做法是将标准输出和标准错误输出都重定向到同一个日志文件中。</p><p>示例：</p><p>bash<br>复制代码<br>#!&#x2F;bin&#x2F;bash<br>LOG_FILE&#x3D;”script.log”<br>echo “脚本开始执行…” &gt;&gt; $LOG_FILE<br>echo “执行过程中…” &gt;&gt; $LOG_FILE 2&gt;&amp;1<br>12. 如何在 Shell 脚本中查找和替换字符串？<br>答案： 可以使用 sed 命令来查找和替换字符串。</p><p>查找并替换：<br>bash<br>复制代码<br>echo “Hello World” | sed ‘s&#x2F;World&#x2F;Shell&#x2F;‘<br>输出：Hello Shell<br>13. 如何使用 Shell 脚本处理文件和目录？<br>答案： Shell 提供了一些常用的命令来处理文件和目录。</p><p>创建目录：</p><p>bash<br>复制代码<br>mkdir &#x2F;path&#x2F;to&#x2F;directory<br>删除文件或目录：</p><p>bash<br>复制代码<br>rm &#x2F;path&#x2F;to&#x2F;file<br>rm -r &#x2F;path&#x2F;to&#x2F;directory<br>移动或重命名文件：</p><p>bash<br>复制代码<br>mv oldfile.txt newfile.txt<br>复制文件：</p><p>bash<br>复制代码<br>cp file1.txt file2.txt<br>14. 如何在 Shell 脚本中使用正则表达式？<br>答案： 可以使用 grep 或 sed 等工具在 Shell 中处理正则表达式。</p><p>使用 grep 来匹配正则表达式：<br>bash<br>复制代码<br>echo “Hello, World!” | grep -E “World”<br>总结：<br>Shell 脚本在测试开发中的应用非常广泛，面试中会涉及到脚本的编写、调试、执行及其应用场景，如自动化测试、环境配置、日志分析等。面试官会关注你对常用命令、控制结构、文件操作、错误处理、重定向等基础内容的掌握程度。</p>]]></content>
    
    
    <categories>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ORM</title>
    <link href="/2023/07/17/django/ORM/"/>
    <url>/2023/07/17/django/ORM/</url>
    
    <content type="html"><![CDATA[<h1 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h1><h2 id="一-定义"><a href="#一-定义" class="headerlink" title="一. 定义"></a>一. 定义</h2><ul><li><p>将类和数据表进行映射</p></li><li><p>通过类和对象就能操作它所对应表格中的数据（CRUD）</p></li><li><p>ORM中可以创建模型类，通过模型类，自动创建数据库表</p></li></ul><h2 id="二-安装步骤"><a href="#二-安装步骤" class="headerlink" title="二. 安装步骤"></a>二. 安装步骤</h2><h4 id="①在全局settings-py-–-DATABASES中，配置数据库信息"><a href="#①在全局settings-py-–-DATABASES中，配置数据库信息" class="headerlink" title="①在全局settings.py – DATABASES中，配置数据库信息"></a>①在全局settings.py – DATABASES中，配置数据库信息</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta"># 需要再全局setting.py DATABASES字典中来配置数据库的信息</span><br>DATABASES <span class="hljs-punctuation">=</span> &#123;<br>    <span class="hljs-meta"># 在django中数据库的标识，有多个数据库添加多个字典</span><br>    &#x27;default&#x27;<span class="hljs-punctuation">:</span> &#123;<br>        <span class="hljs-meta"># 指定数据库使用的引擎</span><br>        &#x27;ENGINE&#x27;<span class="hljs-punctuation">:</span> &#x27;django.db.backends.mysql&#x27;<span class="hljs-punctuation">,</span><br>        <span class="hljs-meta"># 指定数据库的名称</span><br>        &#x27;NAME&#x27;<span class="hljs-punctuation">:</span> &#x27;testnuonuo&#x27;<span class="hljs-punctuation">,</span><br>        <span class="hljs-meta"># 指定连接的数据库主机地址 域名和ip都可以</span><br>        &#x27;HOST&#x27;<span class="hljs-punctuation">:</span> &#x27;localhost&#x27;<span class="hljs-punctuation">,</span><br>        <span class="hljs-meta"># 指定数据库的连接端口号，默认为3306</span><br>        &#x27;PORT&#x27;<span class="hljs-punctuation">:</span> <span class="hljs-number">3306</span><span class="hljs-punctuation">,</span><br>        &#x27;USER&#x27;<span class="hljs-punctuation">:</span> &#x27;root&#x27;<span class="hljs-punctuation">,</span><br>        <span class="hljs-meta"># 当前电脑mysql数据库root权限所对应的密码</span><br>        &#x27;PASSWORD&#x27;<span class="hljs-punctuation">:</span> &#x27;zhao<span class="hljs-number">1994</span>.&#x27;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="②-安装mysql客户端，配置数据库连接信息"><a href="#②-安装mysql客户端，配置数据库连接信息" class="headerlink" title="② 安装mysql客户端，配置数据库连接信息"></a>② 安装mysql客户端，配置数据库连接信息</h4><ul><li>新建数据库连接. 数据库密码要设置的和DATABASES中设置的一致</li><li>新建数据库 字符集选择utf8 排序规则选择utf8_general_ci</li></ul><h4 id="③-安装mysqllicent"><a href="#③-安装mysqllicent" class="headerlink" title="③ 安装mysqllicent"></a>③ 安装mysqllicent</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">第一步安装brew 使用国内源<br>/bin/zsh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span><br><br>第二步修改配置文件安装mysqlclient:<br>brew install mysql-client<br>vim ~/.zshrc<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/usr/local/opt/mysql-client/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><span class="hljs-built_in">export</span> LIBRARY_PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$LIBRARY_PATH</span>:/usr/local/opt/openssl/lib/&quot;</span><br><span class="hljs-built_in">source</span> ~/.zshrc<br>pip3 install mysqlclient<br><br>如果提示mysqlcient版本不对的话在settings.py下面的__init__py中加入<br>import pymysql<br>pymysql.version_info = (1, 4, 13, <span class="hljs-string">&quot;final&quot;</span>, 0)  <span class="hljs-comment"># 解决mysql版本问题报错而添加的代码</span><br>pymysql.install_as_MySQLdb()<br></code></pre></td></tr></table></figure><h2 id="三-定义数据模型"><a href="#三-定义数据模型" class="headerlink" title="三 定义数据模型"></a>三 定义数据模型</h2><p> 在子应用的models.py中，定义数据模型</p><p>​ 一个数据模型类对应一个数据表</p><p>​ 数据模型类，需要继承Model父类或者Model子类</p><p>​ 在数据模型类中，添加的类属性（Field对象）来对应数据表中的字段</p><p> 会自动创建字段名为id的类属性，自增 主键 非空，若某一个字段中primary_key&#x3D;True，那么django不会自动创建id字段，会使用自己创建的</p><p> 在执行迁移脚本后，生成的数据表名默认为子应用名_模型类名小写</p><p> 如果想指定表名则在模型类下定义子类，子类名称固定为Meta，可使用db_table属性，指定表名</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Projects(models.Model):<br>    project_id = models.AutoField(<span class="hljs-attribute">primary_key</span>=<span class="hljs-literal">True</span>)<br>    <br>    # 约束项目名称 name 字段，最大长度为200，值唯一<br>    name = models.CharField(<span class="hljs-attribute">max_length</span>=200, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&#x27;项目名称&#x27;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&#x27;项目名称&#x27;</span>, <span class="hljs-attribute">unique</span>=<span class="hljs-literal">True</span>)<br><br>    # 项目简介 desc 字段，参数可以为空，为空时使用<span class="hljs-built_in"> default </span>默认值<br>desc = models.TextField(<span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&#x27;项目简介&#x27;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&#x27;项目简介&#x27;</span>, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">default</span>=<span class="hljs-string">&#x27;项目简介&#x27;</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>)<br><br>    # 数据创建时，添加当前时间<br>create_time = models.DateTimeField(<span class="hljs-attribute">auto_now_add</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&#x27;创建时间&#x27;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&#x27;创建时间&#x27;</span>)<br><br># 数据更新时，update_time更新，update_time只有在调用save方法的时候才会自动更新<br>update_time = models.DateTimeField(<span class="hljs-attribute">auto_now</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&#x27;更新时间&#x27;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&#x27;更新时间&#x27;</span>)<br>    <br>    class Meta:<br>         # 指定当前模型在数据库的表名<br>    db_table = <span class="hljs-string">&#x27;tb_projects&#x27;</span><br>         # 指定表的自定义描述 给模型设置别名 如果不指定它，Django 会使用小写的模型名作为默认值。<br>    verbose_name = <span class="hljs-string">&#x27;项目表&#x27;</span><br>         # 数据库模型类的复数 apple -》apples 一般和verbose_name保持一致 因为英语单词有单数和复数两种形式，这个属性是模型对象的复数名。中文则跟 verbose_name 值一致。如果不指定该选项，那么默认的复数名字是 verbose_name 加上 ‘s’ 。<br>         verbose_name_plural =verbose_name<br></code></pre></td></tr></table></figure><h3 id="表与表之间的关系："><a href="#表与表之间的关系：" class="headerlink" title="表与表之间的关系："></a>表与表之间的关系：</h3><p>​ 一对一：models.OneToOneField</p><p>​ 一对多：models.ForeignKey，“一”：父表；“多”：子表、从表</p><p>​ 如：项目表、接口表，一个接口属于一个项目，一个项目拥有多个接口，因此，项目表（一） – &gt; 接口表（多）</p><p>​ 多对多：models.ManyToManyField</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class Interfaces(models.Model):<br>    name = models.CharField(<span class="hljs-attribute">max_length</span>=200, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&quot;接口名称&quot;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&quot;接口名称&quot;</span>, <span class="hljs-attribute">unique</span>=<span class="hljs-literal">True</span>)<br>    # 1.ForeignKey指定外键字段 一般在从表的模型类里指定<br>    # 2.第一个参数为必传参数，为父表模型类的引用（模型类名或者使用<span class="hljs-string">&#x27;应用名.父表模型类名&#x27;</span><br>    # 3.第二个参数为必传参数on_delete，指定父表数据被删除后，子表中对应的记录的处理方式<br>    # 4.models.CASCADE 父表记录被删除 子表自动删<br>    projects = models.ForeignKey(<span class="hljs-string">&#x27;projects.Projects&#x27;</span>,<br>                                 <span class="hljs-attribute">on_delete</span>=models.CASCADE, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&quot;接口所属项目&quot;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&quot;接口所属项目&quot;</span>)<br>    # 5.models.SET_NULL <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span> 父表记录被删，子表自动设置为<span class="hljs-literal">null</span><br>    # 6.外键字段名称一般为父表模型类名小写<br>    # projects = models.ForeignKey(<span class="hljs-string">&#x27;projects.Projects&#x27;</span>,<span class="hljs-attribute">on_delete</span>=models.SET_NULL,null=True,verbose_name=&quot;接口所属项目id&quot;, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&quot;接口所属项目id&quot;</span>)<br>    tester = models.CharField(<span class="hljs-attribute">max_length</span>=50, <span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&quot;测试人员&quot;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&quot;测试人员&quot;</span>)<br>    desc = models.TextField(<span class="hljs-attribute">verbose_name</span>=<span class="hljs-string">&quot;项目简介&quot;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&quot;项目简介&quot;</span>, <span class="hljs-attribute">null</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">default</span>=<span class="hljs-string">&quot;xxxx简介&quot;</span>, <span class="hljs-attribute">blank</span>=<span class="hljs-literal">True</span>)<br><br><br>class Meta:<br>    db_table = <span class="hljs-string">&quot;tb_interfaces&quot;</span><br>    verbose_name = <span class="hljs-string">&quot;接口信息&quot;</span><br>    verbose_name_plural = verbose_name<br><br></code></pre></td></tr></table></figure><h4 id="创建完数据库模型类后，需要迁移才能生成数据表"><a href="#创建完数据库模型类后，需要迁移才能生成数据表" class="headerlink" title="创建完数据库模型类后，需要迁移才能生成数据表"></a>创建完数据库模型类后，需要迁移才能生成数据表</h4><p>​ ①执行python manage.py makemigrations (子应用名) 生成迁移脚本，放在projects&#x2F;migrations目录中（如果不加子应用名，则会将所有子应用进行迁移）</p><p>​ ②执行迁移脚本：python manage.py migrate</p><h4 id="删除表重新迁移步骤"><a href="#删除表重新迁移步骤" class="headerlink" title="删除表重新迁移步骤"></a>删除表重新迁移步骤</h4><ul><li>1.删除migrations下面的迁移脚本 </li><li>2.删除数据库里的表 </li><li>3.删除数据库里Django_migration表里有关子应用的迁移记录</li></ul><p>​    </p><p>模型类字段的定义 </p><table><thead><tr><th>字段名</th><th align="center">释义</th></tr></thead><tbody><tr><td>verbose_name</td><td align="center">个性化信息</td></tr><tr><td>help_text</td><td align="center">帮助文本信息，在api接口文档平台和admin后端站点中会用于提示，一般和verbose_name一致</td></tr><tr><td>unique</td><td align="center">字段值唯一</td></tr><tr><td>null</td><td align="center">指定数据在保存时是否可以为空，默认必填，如果null为True，则可以为空</td></tr><tr><td>blank</td><td align="center">指定前端用户在创建数据时，是否需要传递，默认需要，如不传递，则blank为True</td></tr><tr><td>defalut</td><td align="center">为某一个字段指定默认值，往往会和blank一起使用 前端不传指定一个默认值</td></tr><tr><td>auto_now_add</td><td align="center">设为True自动记录创建的时间（数据的create_time）</td></tr><tr><td>auto_now</td><td align="center">设为True记录更新的时间（数据的update_time）</td></tr><tr><td>只有使用form表单时，blank和null才会起作用</td><td align="center"></td></tr></tbody></table><h5 id="查看django生成的sql语句"><a href="#查看django生成的sql语句" class="headerlink" title="查看django生成的sql语句"></a>查看django生成的sql语句</h5><ul><li>1.导入from django.db import connection</li><li>2.debug调试模式下 在Variables下点击+号添加一个监听 new watch</li><li>3.监听命名为connection.queries</li></ul><h2 id="四-CURD"><a href="#四-CURD" class="headerlink" title="四.CURD"></a>四.CURD</h2><h3 id="1）C-创建create"><a href="#1）C-创建create" class="headerlink" title="1）C-创建create"></a>1）C-创建create</h3><p>方法一：使用模型类对象创建</p><p>​ ①创建一个projects模型类对象</p><p>​ ②调用模型对象的save()，提交</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">proj_obj = Projects(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;飞向月球计划&#x27;</span>, <span class="hljs-attribute">leader</span>=<span class="hljs-string">&#x27;erzn&#x27;</span>, <span class="hljs-attribute">tester</span>=<span class="hljs-string">&#x27;测试1&#x27;</span>, <span class="hljs-attribute">programmer</span>=<span class="hljs-string">&#x27;研发1&#x27;</span>)<br>proj_obj.save()<br></code></pre></td></tr></table></figure><p>方法二：使用查询集的create方法</p><p>​ objects是manager对象，用于对数据进行操作</p><p>​ 使用模型类.objects.create()方法，无需再save</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Projects.objects.create(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;占领火星计划&#x27;</span>, <span class="hljs-attribute">leader</span>=<span class="hljs-string">&#x27;erzn&#x27;</span>, <span class="hljs-attribute">tester</span>=<span class="hljs-string">&#x27;测试2&#x27;</span>, <span class="hljs-attribute">programmer</span>=<span class="hljs-string">&#x27;研发2&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2）U-更新update"><a href="#2）U-更新update" class="headerlink" title="2）U-更新update"></a>2）U-更新update</h3><p>方法一：先获取模型类对象，然后修改某些字段，再调用save</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">proj_obj = Projects.objects.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;飞向月球计划&#x27;</span>)<br>proj_obj.name = <span class="hljs-string">&#x27;驻扎广寒宫计划&#x27;</span><br>proj_obj.save()<br></code></pre></td></tr></table></figure><p>方法二：使用模型类.objects.filter(字段名&#x3D;值).update(字段名&#x3D;修改的值)</p><p>ps: 只有调用了save()，记录的updatetime才会更新</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Projects.objects.<span class="hljs-keyword">filter</span>(<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;Django学习计划&#x27;</span>).<span class="hljs-keyword">update</span>(<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;Django从入门到放弃&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="3）R-查询retrieve"><a href="#3）R-查询retrieve" class="headerlink" title="3）R-查询retrieve"></a>3）R-查询retrieve</h3><p>使用objects管理器来查询</p><h4 id="一-获取一条记录：get"><a href="#一-获取一条记录：get" class="headerlink" title="一 获取一条记录：get()"></a>一 获取一条记录：get()</h4><p>一般只能使用主键或唯一键作为查询条件，如果返回结果为空或多条记录，则会抛出异常</p><p>返回的模型类对象，会自动提交</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">res = Projects.objects.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">project_id</span>=17)<br><br></code></pre></td></tr></table></figure><h4 id="二-获取表中的所有记录：all"><a href="#二-获取表中的所有记录：all" class="headerlink" title="二 获取表中的所有记录：all()"></a>二 获取表中的所有记录：all()</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">res</span> <span class="hljs-operator">=</span> Projects.objects.all()<br></code></pre></td></tr></table></figure><p>返回QuertSet查询集对象，类似列表，支持列表中的某些操作</p><p>​ · 支持数字索引取值（负索引不支持，返回模型类对象，一条记录）、切片（返回查询集对象）</p><p>​ · 支持for循环迭代，每次迭代取出一个模型类对象</p><p>​ · QuertSet查询集对象.first()获取第一个记录、last()获取最后一条记录</p><p>​ · .count()获取查询集中的记录条数</p><p>​ · 惰性查询，只有真正使用数据时，才会去数据库中执行sql语句，为了性能要求</p><p>​ · 链式调用</p><h4 id="三-过滤出部分记录：filter"><a href="#三-过滤出部分记录：filter" class="headerlink" title="三 过滤出部分记录：filter()"></a>三 过滤出部分记录：filter()</h4><p>支持多个过滤表达式，字段名__过滤表达式，如果查询结果为空，则返回 一个空查询集</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Projects.objects.<span class="hljs-keyword">filter</span>()   # 等同于<span class="hljs-keyword">all</span>()<br>Projects.objects.<span class="hljs-keyword">filter</span>(<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;占领火星计划&#x27;</span>)<br>Projects.objects.<span class="hljs-keyword">filter</span>(name__startswith=<span class="hljs-string">&#x27;占领&#x27;</span>)<br>Projects.objects.<span class="hljs-keyword">filter</span>(id__in=[<span class="hljs-number">1</span>, <span class="hljs-number">20</span>])<br></code></pre></td></tr></table></figure><p>在ORM中有一个内置的变量pk，为数据库模型类的主键别名，不仅仅是id，可以指向任何主键</p><table><thead><tr><th>字段名</th><th align="center">释义</th></tr></thead><tbody><tr><td>__ startswith&#x3D;</td><td align="center">过滤以xxx开头的字符串</td></tr><tr><td>__ isstartswith（忽略大小写）</td><td align="center">过滤以xxx开头的字符串</td></tr><tr><td>__ endswith&#x3D;</td><td align="center">过滤以xxx结尾的字符串</td></tr><tr><td>__ iendswith（忽略大小写）</td><td align="center">过滤以xxx结尾的字符串</td></tr><tr><td>__ in&#x3D;[]</td><td align="center">过滤出在条件列表中的数据</td></tr><tr><td>__ gt&#x3D;</td><td align="center">大于</td></tr><tr><td>__ gte&#x3D;</td><td align="center">大于等于</td></tr><tr><td>__ lt&#x3D;</td><td align="center">小于</td></tr><tr><td>__ lte&#x3D;</td><td align="center">小于等于</td></tr><tr><td>__ exact&#x3D;</td><td align="center">等于（等同于 字段名&#x3D;值 ）</td></tr><tr><td>__ isnull&#x3D;True</td><td align="center">查询字段为空&#x2F;不为空的数据</td></tr><tr><td>__ contains&#x3D;</td><td align="center">过滤包含xxx的数据</td></tr><tr><td>__ icontains&#x3D;（忽略大小写）</td><td align="center">过滤包含xxx的数据</td></tr><tr><td>__ regex&#x3D;</td><td align="center">正则过滤</td></tr></tbody></table><h4 id="四-反向查询：exclude"><a href="#四-反向查询：exclude" class="headerlink" title="四 反向查询：exclude()"></a>四 反向查询：exclude()</h4><p>使用方法等同于filter()，查询结果相反</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Projects.objects.<span class="hljs-keyword">exclude</span>(<span class="hljs-type">name</span>=<span class="hljs-string">&#x27;Django学习计划&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="五-关联查询"><a href="#五-关联查询" class="headerlink" title="五 关联查询"></a>五 关联查询</h4><p>通过从表的信息获取父表的记录，从表模型类名(小写)__ 从表字段名 __查询表达式</p><p>惰性：查询集对象，只有去使用的时候，才会执行sql语句</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">qs</span> = Projects.objects.filter(interfaces__name__regex=<span class="hljs-string">&#x27;^[0-9]]&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="六-逻辑关系查询"><a href="#六-逻辑关系查询" class="headerlink" title="六 逻辑关系查询"></a>六 逻辑关系查询</h4><p>查询集支持链式调用，可以使用多个filter方法过滤。同一行中的多个filter 是与的关系</p><p>· “与”查询：filter(查询条件1, 查询条件2)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">qs = Projects.objects.filter(<span class="hljs-attribute">name__startswith</span>=<span class="hljs-string">&#x27;x&#x27;</span>).filter(programmer__contains=&#x27;4&#x27;)<br><br>qs = Projects.objects.filter(<span class="hljs-attribute">name__startswith</span>=<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-attribute">programmer__contains</span>=<span class="hljs-string">&#x27;4&#x27;</span>)<br></code></pre></td></tr></table></figure><p>· “或”查询： filter(Q(查询条件1) | Q(查询条件2))</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> django.db.models import Q<br>qs = Projects.objects.filter(Q(<span class="hljs-attribute">leader__contains</span>=<span class="hljs-string">&#x27;1&#x27;</span>) | Q(<span class="hljs-attribute">programmer__contains</span>=<span class="hljs-string">&#x27;4&#x27;</span>))<br></code></pre></td></tr></table></figure><h4 id="七-聚合查询"><a href="#七-聚合查询" class="headerlink" title="七 聚合查询"></a>七 聚合查询</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">from django<span class="hljs-selector-class">.db</span><span class="hljs-selector-class">.models</span> import Q,Count<br>qs = Projects<span class="hljs-selector-class">.objects</span><span class="hljs-selector-class">.annotate</span>(<span class="hljs-built_in">Count</span>(<span class="hljs-string">&#x27;name&#x27;</span>))<br></code></pre></td></tr></table></figure><p>特殊操作</p><p>使用order_by排序，字段名作为排序条件，默认升序。使用 ‘ - ‘标识降序</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Projects<span class="hljs-selector-class">.objects</span><span class="hljs-selector-class">.all</span>()<span class="hljs-selector-class">.order_by</span>(<span class="hljs-string">&#x27;-id&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="4）D-删除delete"><a href="#4）D-删除delete" class="headerlink" title="4）D-删除delete"></a>4）D-删除delete</h3><p>使用模型对象.delete()</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">proj_obj = Projects.objects.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;占领火星计划&#x27;</span>)<br>proj_obj.delete()<br></code></pre></td></tr></table></figure><ol><li>痛点</li></ol><p>​ 代码冗余大</p><p>​ 数据校验麻烦</p><p>​ 获取列表数据，没有分页、过滤、排序操作</p><p>​ 不支持以表单提交参数</p><p>​ 无法自动生成接口文档</p>]]></content>
    
    
    <categories>
      
      <category>django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DRF</title>
    <link href="/2023/06/17/django/DRF/"/>
    <url>/2023/06/17/django/DRF/</url>
    
    <content type="html"><![CDATA[<h1 id="DRF"><a href="#DRF" class="headerlink" title="DRF"></a>DRF</h1><h2 id="DRF知识树"><a href="#DRF知识树" class="headerlink" title="DRF知识树"></a>DRF知识树</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-01_15-55-51.png"><br><img src="/../.vuepress/public/picture/Snipaste_2021-06-01_15-55-51.png"><br><img src="/../.vuepress/public/picture/Snipaste_2021-06-01_15-56-43.png"></p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/5ee8c8dcf346fb1ae5676195"></iframe><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在Django框架基础上，进行二次开发，用于构建Restful API，简称DRF框架或REST framework框架</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>提供了强大的Serializer序列化器，可以高效地进行序列化与反序列化操作</p><p>提供了丰富的类视图、Mixin扩展类、ViewSet视图集</p><p>提供了直观的Web API界面</p><p>实现了多种身份认证和权限认证</p><p>实现了排序、过滤、分页、搜索、限流等功能</p><p>可扩展性强，插件丰富</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip3 install djangorestframework<br>pip3 install markdown<br></code></pre></td></tr></table></figure><h5 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h5><p>在全局settings.py中添加子应用，’rest_framework’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;rest_framework&#x27;</span>,<br>]<br></code></pre></td></tr></table></figure><h2 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h2><p>将变量从内存中取出变成可存储或传输的过程称之为序列化</p><p>将变量内容从序列化的对象写到内存里的过程为反序列化</p><h2 id="（一）作用"><a href="#（一）作用" class="headerlink" title="（一）作用"></a>（一）作用</h2><h5 id="1-数据校验"><a href="#1-数据校验" class="headerlink" title="1. 数据校验"></a>1. 数据校验</h5><p>​判断用户输入的数据是否合法</p><h5 id="2-数据转换"><a href="#2-数据转换" class="headerlink" title="2. 数据转换"></a>2. 数据转换</h5><p>​反序列化输入 —— 前端字段请求入库</p><p>​数据格式(json、xml、text)  &#x3D;&gt; 程序中的数据类型（保存、更新数据）</p><p>​序列化输出 —— 数据库字段返回给前端</p><p>​程序中的数据类型  &#x3D;&gt; 数据格式（前端可处理的数据，如json）</p><h2 id="（二）使用"><a href="#（二）使用" class="headerlink" title="（二）使用"></a>（二）使用</h2><h4 id="1-定义序列化器类"><a href="#1-定义序列化器类" class="headerlink" title="1. 定义序列化器类"></a>1. 定义序列化器类</h4><ul><li><p>继承Serializer</p></li><li><p>序列化器类字段名要与模型类中的字段名相同</p></li><li><p>序列化器类中定义的字段，如无特殊约束，必须传参，同时也都会返回</p></li><li><p>序列化器类的字段类型：CharField、BooleanField、IntegerField等要与模型类中的字段对应</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectModelSerializer</span>(serializers.Serializer):<br>    name = serializers.CharField(max_length=<span class="hljs-number">200</span>, label=<span class="hljs-string">&#x27;项目名称&#x27;</span>, help_text=<span class="hljs-string">&#x27;项目名称&#x27;</span>, read_only=<span class="hljs-literal">True</span>)<br>desc = serializers.CharField(max_length=<span class="hljs-number">200</span>, label=<span class="hljs-string">&#x27;项目简介&#x27;</span>, help_text=<span class="hljs-string">&#x27;项目简介&#x27;</span>, allow_null=<span class="hljs-literal">True</span>, allow_blank=<span class="hljs-literal">True</span>, default=<span class="hljs-string">&#x27;项目简介&#x27;</span>)<br>  update_time = serializers.DateTimeField(label=<span class="hljs-string">&#x27;更新时间&#x27;</span>, help_text=<span class="hljs-string">&#x27;更新时间&#x27;</span>, required=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>字段参数设置：</p><p>选项参数</p></li></ul><table><thead><tr><th align="left">参数名称</th><th>作用</th></tr></thead><tbody><tr><td align="left">max_length</td><td>最大长度</td></tr><tr><td align="left">min_length</td><td>最小长度</td></tr><tr><td align="left">allow_blank</td><td>是否允许为空（字段不传）</td></tr><tr><td align="left">trim_whitespace</td><td>是否截断空白字符</td></tr><tr><td align="left">max_value</td><td>最大值</td></tr><tr><td align="left">min_value</td><td>最小值</td></tr></tbody></table><p>​通用参数</p><table><thead><tr><th>参数名称</th><th align="left">说明</th></tr></thead><tbody><tr><td>required</td><td align="left">默认为None，指定前端必须传该字段，如果为False，则参数可以为空（与read_only不可同时设置）</td></tr><tr><td>read_only</td><td align="left">仅用于序列化输出，默认为False，若为True，则该字段在反序列化输入时可不用传，若传入字段也不做校验</td></tr><tr><td>write_only</td><td align="left">仅用于反序列化输入，默认为False，若为True，则该字段必传，但不会输出（与read_only不可同时设置）</td></tr><tr><td>default</td><td align="left">前端不传参，则使用默认值</td></tr><tr><td>allow_null</td><td align="left">指定传参时参数可以为空值，默认为False</td></tr><tr><td>validators</td><td align="left">字段指定校验器</td></tr><tr><td>error_messages</td><td align="left">设置错误信息，key为校验的参数名，value为校验失败后的返回信息，如：error_messages&#x3D;{“required”: “该字段必填”}</td></tr><tr><td>label</td><td align="left">与模型类中的verbose_name作用相同，HTML展示API页面时显示的字段名称</td></tr><tr><td>help_text</td><td align="left">与模型类中的help_text作用相同，HTML展示API页面时显示的字段帮助提示信息</td></tr></tbody></table><h4 id="2-序列化器操作"><a href="#2-序列化器操作" class="headerlink" title="2. 序列化器操作"></a>2. 序列化器操作</h4><h5 id="·-1-创建序列化器对象"><a href="#·-1-创建序列化器对象" class="headerlink" title="· 1.创建序列化器对象"></a>· 1.创建序列化器对象</h5><p>​①传递数据：序列化器类(dict_data)</p><p>​传入字典，将模型类对象转化为python中的数据类型，进行数据校验，生成数据模型，作用是反序列化输入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">serializer_obj = InterfacesModelSerializer(data=request.data)<br></code></pre></td></tr></table></figure><p>​②获取数据：序列化器类(instance&#x3D;模型类对象&#x2F;查询集, many&#x3D;True)</p><p>​传入模型类对象或查询集，作用是序列化输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">serializer_obj = InterfacesModelSerializer(instance=inter_obj, data=request.data, partial=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>​如果未传递many&#x3D;True，则序列化器对象返回字典，否则返回嵌套字典的列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">serializer_obj = InterfacesModelSerializer(instance=qs, many=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h5 id="·-2-数据校验"><a href="#·-2-数据校验" class="headerlink" title="· 2.数据校验"></a>· 2.数据校验</h5><p>​1）校验器的使用</p><p>​在定义序列化器字段时，使用参数validators&#x3D;[ ]，添加一个或多个校验器，指定校验规则</p><p>​validators列表中的校验规则会全部执行，即使其中有校验失败项</p><p>​2）校验器的种类</p><p>​① 定义在filed中的参数，如：max_length,、min_length、required…</p><p>​② drf自带校验规则，如：UniqueValidator(查询集, message&#x3D;’xxx不能重复’)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> validators<br><br><span class="hljs-comment"># 校验名称是否已存在</span><br>name = serializers.CharField(max_length=<span class="hljs-number">10</span>, label=<span class="hljs-string">&#x27;接口名称&#x27;</span>, help_text=<span class="hljs-string">&#x27;接口名称&#x27;</span>, validators=[<br>    validators.UniqueValidator(queryset=Interfaces.objects.<span class="hljs-built_in">all</span>(), message=<span class="hljs-string">&#x27;接口名称已存在&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>​③ 自定义校验器</p><p>​在序列化器类外部定义校验器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 校验名称中是否包含‘x’</span><br><span class="hljs-comment"># 如果校验失败，一定要抛出ValidationError，并给出报错信息</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_name_contain_x</span>(<span class="hljs-params">value</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-keyword">in</span> value:<br>        <span class="hljs-keyword">raise</span> serializers.ValidationError(<span class="hljs-string">&quot;接口名称中不能包含&#x27;X&#x27;&quot;</span>)<br></code></pre></td></tr></table></figure><p>​④ 单字段校验</p><p>​在序列化器类中对单字段进行校验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 校验器名称必须为validate_字段名</span><br><span class="hljs-comment"># 必须返回校验后的值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate_name</span>(<span class="hljs-params">self, value</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;-&#x27;</span> <span class="hljs-keyword">in</span> value:<br>        <span class="hljs-keyword">raise</span> serializers.ValidationError(<span class="hljs-string">&quot;接口名称中不能包含&#x27;-&#x27;&quot;</span>)<br>    <span class="hljs-keyword">return</span> value<br></code></pre></td></tr></table></figure><p>​⑤ 多字段联合校验</p><p>​在序列化器类中对多字段进行校验</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 函数名固定为</span><br><span class="hljs-comment"># 必须返回attrs</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">validate</span>(<span class="hljs-params">self, attrs</span>):<br>    <span class="hljs-keyword">if</span> attrs[<span class="hljs-string">&#x27;password&#x27;</span>] != attrs[<span class="hljs-string">&#x27;confirm_password&#x27;</span>]:<br>        <span class="hljs-keyword">raise</span> serializers.ValidationError(<span class="hljs-string">&#x27;输入密码与确认密码不一致&#x27;</span>)<br>    <span class="hljs-keyword">return</span> attrs<br></code></pre></td></tr></table></figure><p>​联合校验失败时，默认会将 “non_field_error”作为key，返回报错信息</p><p>​可在全局settings.py中的REST_FRAMEWORK修改DRF的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 校验失败时，以&#x27;error_message&#x27;作为key</span><br>REST_FRAMEWORK = &#123;<br>    <span class="hljs-comment"># &#x27;NON_FIELD_ERRORS_KEY&#x27;: &#x27;non_field_errors&#x27;,</span><br>    <span class="hljs-string">&#x27;NON_FIELD_ERRORS_KEY&#x27;</span>: <span class="hljs-string">&#x27;error_message&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="·-3-序列化器的校验顺序"><a href="#·-3-序列化器的校验顺序" class="headerlink" title="· 3 序列化器的校验顺序"></a>· 3 序列化器的校验顺序</h5><p>​字段定义时的校验（校验参数 —&gt; validators参数校验列表） —&gt; 单字段校验 —&gt; 多字段校验</p><p>​检验不通过，则不会继续之后的校验</p><h5 id="·-4-数据的校验"><a href="#·-4-数据的校验" class="headerlink" title="· 4.数据的校验"></a>· 4.数据的校验</h5><p>​开始校验：serializer_obj.is_valid() </p><p>​.is_valid(raise_exception&#x3D;True)：若验证错误，则抛出 serializers.ValidationError</p><p>​.data：最原始的没有经过验证的数据（通常校验通过后，返回该数据）</p><p>​必须先执行is_valid()之后才能访问：</p><p>​.errors：校验失败的信息</p><p>​.vaildated_data：校验通过后的数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 校验失败，返回校验失败的信息，否则返回校验通过的数据</span><br><span class="hljs-keyword">try</span>:<br>    serializer_obj.is_valid(raise_exception=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    res.update(serializer_obj.errors)<br>    <span class="hljs-keyword">return</span> JsonResponse(res, status=<span class="hljs-number">400</span>)<br></code></pre></td></tr></table></figure><p>​</p><h3 id="·-数据的增、查、改"><a href="#·-数据的增、查、改" class="headerlink" title="· 数据的增、查、改"></a>· 数据的增、查、改</h3><p>1）只涉及到数据的校验，无需对模型进行修改（create）</p><p>​创建序列化器对象：序列化器类(dict_data)</p><p>​开始校验数据：序列化对象.is_valid()</p><p>​获取错误信息：序列化对象.errors</p><p>​校验成功后，对数据进行修改：序列化对象.save()</p><p>​执行save()时，传递的关键字参数，会自动添加到create()的validated_data中，如：创建数据时，同时给出创建者的姓名：序列化对象.save(user&#x3D;’xxx’)</p><p>​获取校验成功后的数据：序列化对象.data &#x2F; 序列化对象.validated_data</p><p>2）只获取数据库中的数据（search）</p><p>​创建序列化器对象：</p><p>​序列化器类(instance&#x3D;模型类对象) </p><p>​序列化器类(instance&#x3D;查询集, many&#x3D;True)</p><p>​序列化器类(instance&#x3D;普通对象)</p><p>​序列化输出：序列化对象.data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询接口信息：id默认为空</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request, pk=<span class="hljs-literal">None</span></span>):<br>    res = &#123;&#125;<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">if</span> pk:<br>            <span class="hljs-comment"># 查询接口详情以及所属项目信息</span><br>            inter_obj = Interfaces.objects.get(<span class="hljs-built_in">id</span>=pk)<br>            serializer_obj = InterfacesSerializer(instance=inter_obj)<br>            projects_info = <span class="hljs-variable language_">self</span>.get_project_info(serializer_obj.data[<span class="hljs-string">&#x27;projects&#x27;</span>])<br>            res[<span class="hljs-string">&#x27;data&#x27;</span>] = serializer_obj.data<br>            res[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;projects&#x27;</span>] = projects_info<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 查询接口列表</span><br>            inter_obj = Interfaces.objects.<span class="hljs-built_in">all</span>()<br>            serializer_obj = InterfacesSerializer(instance=inter_obj, many=<span class="hljs-literal">True</span>)<br>            res[<span class="hljs-string">&#x27;data&#x27;</span>] = serializer_obj.data<br>        res[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">0</span><br>        res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;查询接口信息成功&#x27;</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        res[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">1</span><br>        res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">f&#x27;查询接口信息失败：<span class="hljs-subst">&#123;e&#125;</span>&#x27;</span><br>    <span class="hljs-keyword">return</span> JsonResponse(data)<br></code></pre></td></tr></table></figure><p>3）既需要做数据校验，也需要修改数据库中的数据（update）</p><p>​创建序列化器对象：</p><p>​序列化器类(instance&#x3D;模型类对象, data&#x3D;dict_data) </p><p>​开始校验数据：序列化对象.is_valid()</p><p>​获取错误信息：序列化对象.errors</p><p>​校验成功后，对数据进行修改：序列化对象.save()（根据是否有instance传参，判断是更新还是创建操作）</p><p>​获取校验成功后的数据：序列化对象.data &#x2F; 序列化对象.validated_data</p><h2 id="（三）ModelSerializer"><a href="#（三）ModelSerializer" class="headerlink" title="（三）ModelSerializer"></a>（三）ModelSerializer</h2><p>​1. 目的：为了简化序列化器类的定义</p><p>​2. 功能：</p><p>​基于模型类自动生成一系列字段</p><p>​基于模型类自动为Serializer生成validators，如：unique_together</p><p>​包含默认的create()和update()的实现</p><ol start="3"><li><p>ModelSerializer定义的字段若与模型类字段同名，会覆盖原有的模型类字段</p></li><li><p>ModelSerializer可以基于模型类自动生成validators，如：unique_together</p></li><li><p>模型序列化器类中的Meta类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Meta</span>:<br>    <span class="hljs-comment"># model类属性：在Meta内部类中指定具体的模型类</span><br>    <span class="hljs-comment"># fields类属性 指定模型类中需要输入或输出的字段</span><br>    <span class="hljs-comment"># 默认id主键会自动添加read_only=True</span><br>    <span class="hljs-comment"># create_time、update_time自动添加read_only=True</span><br>    model = Interfaces<br>    <span class="hljs-comment"># 将模型类的所有字段都声明到模型序列化器中</span><br>    <span class="hljs-comment"># fields = &#x27;__all__&#x27;</span><br>    <span class="hljs-comment"># 可以将需要/输出的字段放在fields元组中，在序列化器中定义的所有字段必须添加到fields中</span><br>    fields = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tester&#x27;</span>, <span class="hljs-string">&#x27;desc&#x27;</span>, <span class="hljs-string">&#x27;email&#x27;</span>, <span class="hljs-string">&#x27;projects&#x27;</span>)<br>    <span class="hljs-comment"># 把需要排除的字段放在exclude中，既不参与输入，也不参与输出</span><br>    <span class="hljs-comment"># exclude = (&#x27;desc&#x27;,)</span><br>    <span class="hljs-comment"># 可以在read_only_fields中指定只输出，不输入的字段</span><br>    read_only_fields = (<span class="hljs-string">&#x27;id&#x27;</span>,)<br>    <span class="hljs-comment"># 可以在extra_kwargs属性中定制某些字段，可以覆盖，也可以新增，序列化器中定义的字段优先级最高</span><br>    extra_kwargs = &#123;<br>        <span class="hljs-string">&#x27;tester&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;测试负责人&#x27;</span>,<br>            <span class="hljs-string">&#x27;write_only&#x27;</span>: <span class="hljs-literal">False</span>,<br>            <span class="hljs-string">&#x27;max_length&#x27;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&#x27;min_length&#x27;</span>: <span class="hljs-number">1</span><br>        &#125;,<br>        <span class="hljs-string">&#x27;name&#x27;</span>: &#123;<br>            <span class="hljs-string">&#x27;max_length&#x27;</span>: <span class="hljs-number">10</span>,<br>            <span class="hljs-string">&#x27;min_length&#x27;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;接口名称&#x27;</span>,<br>            <span class="hljs-string">&#x27;help_text&#x27;</span>: <span class="hljs-string">&#x27;接口名称&#x27;</span>,<br>            <span class="hljs-string">&#x27;validators&#x27;</span>: [validators.UniqueValidator(queryset=Interfaces.objects.<span class="hljs-built_in">all</span>(), message=<span class="hljs-string">&#x27;接口名称已存在&#x27;</span>)]<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>ModelSerializer和Serializer的区别</p><p>①字段的定义</p><p>​Serializer：需手动定义序列化器字段，与模型类字段匹配</p><p>​ModelSerializer：基于模型类自动生成一系列字段</p><p>②数据的创建或更新</p><p>​Serializer：需重写create&#x2F;update方法，完成数据的创建&#x2F;更新</p><p>​ModelSerializer：包含create&#x2F;update方法，无需重写</p><p>③字段校验</p><p>​Serializer：需手动指定校验器，如：validators&#x3D;[validators.UniqueValidator()]</p><p>​ModelSerializer：可基于模型类自动生成某些validators，如：unique_together</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用模型序列化器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request, pk=<span class="hljs-literal">None</span></span>):<br>    qs = Interfaces.objects.<span class="hljs-built_in">all</span>()<br>    serializer_obj = InterfacesModelSerializer(instance=qs, many=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> JsonResponse(serializer_obj.data, safe=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure></li></ol><h2 id="（四）关联字段序列化"><a href="#（四）关联字段序列化" class="headerlink" title="（四）关联字段序列化"></a>（四）关联字段序列化</h2><p>​1. 子表关联父表</p><p>​PrimaryKeyRelatedField：将父表的主键id返回</p><p>​StringRelatedField：将父表中对应对象的__str__方法结果返回</p><p>​SlugRelatedField：指定序列化输出时返回的父表某个字段值</p><p>​关联对象的序列化器：xxxModelSerializer，可以将某个序列化器对象定义为字段，支持Field中的所有参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># PrimaryKeyRelatedField：将父表的主键id返回</span><br><span class="hljs-comment"># 此处的字段名一定要与模型中的字段名一致</span><br>projects = serializers.PrimaryKeyRelatedField(<span class="hljs-attribute">read_only</span>=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># StringRelatedField：将父表中对应对象的__str__方法结果返回</span><br><span class="hljs-comment"># projects = serializers.StringRelatedField()</span><br><br><span class="hljs-comment"># serializers.SlugRelatedField：指定序列化输出时返回的父表某个字段值</span><br><span class="hljs-comment"># projects = serializers.SlugRelatedField(slug_field=&#x27;tester&#x27;, read_only=True)</span><br><br><span class="hljs-comment"># ProjectModelSerializer：将某个序列化器对象定义为字段，字典形式返回父序列化器所有字段</span><br>projects = ProjectModelSerializer(<span class="hljs-attribute">label</span>=<span class="hljs-string">&#x27;所属项目信息&#x27;</span>, <span class="hljs-attribute">help_text</span>=<span class="hljs-string">&#x27;所属项目信息&#x27;</span>, <span class="hljs-attribute">read_only</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ol start="2"><li><p>父表关联子表</p><p>父表中默认不会生成关联字段(从表字段)，可手动指定</p></li></ol><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 默认可以使用子表名模型类名小写_set<br># interfaces_set = InterfacesModelSerializer(label=<span class="hljs-string">&#x27;拥有的接口&#x27;</span>, many=<span class="hljs-literal">True</span>)<br># 如果某个字段返回的结果有多条，需要添加many=<span class="hljs-literal">True</span><br># interfaces_set = serializers.PrimaryKeyRelatedField(many=<span class="hljs-literal">True</span>)<br># 如果模型类中外键字段定义了related_name，则会使用该名称作为字段名<br># interface = serializers.StringRelatedField(many=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>​· 仅支持json格式传参，不支持form表单传参</p><p>​· 仅能返回json格式数据，其他类型不支持</p><p>​· 对于模型类的获取，仍然有冗余</p><h2 id="类视图"><a href="#类视图" class="headerlink" title="类视图"></a>类视图</h2><h2 id="（一）APIView"><a href="#（一）APIView" class="headerlink" title="（一）APIView"></a>（一）APIView</h2><h4 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h4><p>​继承了Django中的View，进行了拓展，是可浏览的API页面</p><p>​具备认证、授权、限流、不同请求数据的解析</p><h4 id="2-APIView与View的不同"><a href="#2-APIView与View的不同" class="headerlink" title="2. APIView与View的不同"></a>2. APIView与View的不同</h4><p>​1）传入到视图方法中的是Request对象，而不是Django中的HttpRequest对象</p><p>​2）视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式</p><p>​3）任何APIException异常都会被捕获到，并且处理成合适的响应信息</p><p>​4）在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制</p><h4 id="3-常用类属性"><a href="#3-常用类属性" class="headerlink" title="3. 常用类属性"></a>3. 常用类属性</h4><p>​authentication_classes列表或元组，身份认证类</p><p>​permission_classes列表或元组，权限检查类</p><p>​throttle_classes列表或元组，流量控制类</p><h4 id="4-Request"><a href="#4-Request" class="headerlink" title="4. Request"></a>4. Request</h4><p>​1）对Django中的HttpRequest进行了拓展</p><p>接收到请求后会根据请求头中的Content-Type，自动进行解析，解析为字典形式保存到Request对象</p><p>无论前端发送哪种格式的数据，都可以以统一的方式读取</p><p>​2）.data —— 获取json格式的参数、form表单的参数、files（类似于.body 、.POST、.FILES ）</p><p>利用了REST framework的parsers解析器，不仅支持表单类型数据，也支持JSON数据</p><p>可以对POST、PUT、PATCH的请求体参数进行解析</p><p>Render类Parse解析类</p><p>​3）.query_params —— 获取查询字符串参数（类似于.GET ）</p><p>​4）支持Django HttpRequest中所有的对象和方法</p><h4 id="5-Response"><a href="#5-Response" class="headerlink" title="5. Response"></a>5. Response</h4><p>​1）对Django中的HTTPResponse进行了拓展</p><p>​2）请求头中的Accept默认为：application&#x2F;json，浏览器访问时自动设置为：text&#x2F;html，返回html页面</p><p>​3）指定响应默认渲染类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在全局settings中的REST_FRAMEWORK修改DRF的配置</span><br><span class="hljs-comment"># DRF框架所有的全局配置都放在REST_FRAMEWORK字典中</span><br><br>REST_FRAMEWORK = &#123;<br>    <span class="hljs-string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: [<br>        <span class="hljs-comment"># 按列表中的元素顺序排优先级</span><br>        <span class="hljs-string">&#x27;rest_framework.renderers.JSONRenderer&#x27;</span>,<br>        <span class="hljs-string">&#x27;rest_framework.renderers.BrowsableAPIRenderer&#x27;</span>,<br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>​4）Response参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">Response(data, status=<span class="hljs-literal">None</span>, template_name=<span class="hljs-literal">None</span>, headers=<span class="hljs-literal">None</span>, content_type=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><ul><li><p>data</p><p>​序列化处理后的数据</p><p>​一般为serializer.data（python基本数据类型、字典、嵌套字典的列表）</p></li><li><p>status</p><p>​状态码，默认为200</p></li><li><p>template_name</p><p>​模板名称，使用HTMLRenderer渲染时需指明</p></li><li><p>headers</p><p>​请求头</p></li><li><p>content_type</p><p>​响应头中的content_type</p><p>​通常该参数无需设置，会自动根据前端所需类型数据来设置参数</p></li></ul><h2 id="（二）GenericAPIView"><a href="#（二）GenericAPIView" class="headerlink" title="（二）GenericAPIView"></a>（二）GenericAPIView</h2><p>GenericAPIView为APIView的子类，拓展了过滤、查询、分页的功能</p><h4 id="1-前提"><a href="#1-前提" class="headerlink" title="1. 前提"></a>1. 前提</h4><p>​1）安装过滤引擎 pip3 install django-filter</p><p>​2）必须指定的属性（继承APIView所用）</p><p>​queryset：定义查询集</p><p>​serializer_class：声明模型序列化器类</p><h4 id="2-过滤"><a href="#2-过滤" class="headerlink" title="2. 过滤"></a>2. 过滤</h4><p>​指定过滤引擎：filter_backends</p><p>​指定过滤字段：filterset_fields</p><p>· settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在全局settings.py中指定过滤引擎</span><br><span class="hljs-comment"># 添加应用</span><br>INSTALLED_APPS = [<br>    <span class="hljs-string">&#x27;django_filters&#x27;</span>,<br>]<br><span class="hljs-comment"># 配置DRF</span><br>REST_FRAMEWORK = &#123;<br>    <span class="hljs-string">&#x27;DEFAULT_FILTER_BANKENDS&#x27;</span>: [<br>   <span class="hljs-string">&#x27;django_filters.rest_framework.backends.DjangoFilterBackend&#x27;</span><br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>· views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django_filters.rest_framework <span class="hljs-keyword">import</span> DjangoFilterBackend<br><br><span class="hljs-comment"># 在filter_backends指定过滤引擎</span><br>filter_backends = [DjangoFilterBackend]<br><span class="hljs-comment"># 指定需要过滤的字段</span><br>filter_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tester&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br></code></pre></td></tr></table></figure><p>URL访问：</p><p>​name&#x3D;test1：&#x2F;?name&#x3D;test1</p><h4 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h4><p>​指定过滤引擎：filter_backends</p><p>​指定排序字段：ordering_fields</p><p>· settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在全局settings.py中指定排序引擎</span><br><span class="hljs-comment"># 配置DRF</span><br>REST_FRAMEWORK = &#123;<br>    <span class="hljs-string">&#x27;DEFAULT_FILTER_BANKENDS&#x27;</span>: [<br>        <span class="hljs-string">&#x27;rest_framework.filters.OrderingFilter&#x27;</span><br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>· views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.filters <span class="hljs-keyword">import</span> OrderingFilter<br><br><span class="hljs-comment"># 在filter_backends指定排序引擎</span><br>filter_backends = [OrderingFilter]<br><span class="hljs-comment"># 指定排序字段</span><br>ordering_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;create_time&#x27;</span>]<br></code></pre></td></tr></table></figure><p>URL访问：</p><p>​升序：&#x2F;?ordering&#x3D;name&amp;id</p><p>​降序：&#x2F;?ordering&#x3D;-name</p><h4 id="4-分页"><a href="#4-分页" class="headerlink" title="4. 分页"></a>4. 分页</h4><p>​指定分页引擎：pagination_class</p><p>· settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在全局settings.py中指定分页引擎</span><br><span class="hljs-comment"># 配置DRF</span><br>REST_FRAMEWORK = &#123;<br>    <span class="hljs-string">&#x27;DEFAULT_PAGINATION_CLASS&#x27;</span>: [<br>        <span class="hljs-comment"># 使用默认的分页引擎</span><br>        <span class="hljs-string">&#x27;rest_framework.pagination.PageNumberPagination&#x27;</span>,<br>        <span class="hljs-comment"># 指定每页展示数据的条数</span><br>        <span class="hljs-string">&#x27;PAGE_SIZE&#x27;</span>: <span class="hljs-number">5</span><br>    ],<br>&#125;<br></code></pre></td></tr></table></figure><p>重新定义分页引擎</p><p>​创建一个新目录utils，用于存放自定义模块，继承PageNumberPagination，重新定义分页引擎</p><p>​当自定义分页引擎与settings.py中分页引擎同时存在时，自定义的优先级更高</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.pagination <span class="hljs-keyword">import</span> PageNumberPagination<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPagination</span>(<span class="hljs-title class_ inherited__">PageNumberPagination</span>):<br><span class="hljs-comment"># 指定默认每一页的数据条数</span><br>page_size = <span class="hljs-number">4</span><br><span class="hljs-comment"># 设置当前页码的查询字符串key名称，不设置则默认key值为page</span><br>page_query_param = <span class="hljs-string">&#x27;p&#x27;</span><br><span class="hljs-comment"># 设置每页显示的数据条数的查询字符串key名称，不设置则无法指定每页显示的数据量</span><br>page_size_query_param = <span class="hljs-string">&#x27;s&#x27;</span><br>    <span class="hljs-comment"># 指定每一页数据条数的最大限制</span><br>max_page_size = <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h4 id="1）过滤-分页-排序查询"><a href="#1）过滤-分页-排序查询" class="headerlink" title="1）过滤+分页+排序查询"></a>1）过滤+分页+排序查询</h4><p>get_queryset()：获取查询集</p><p>filter_queryset()：对查询集进行过滤，并返回一个查询集</p><p>paginate_queryset()：对查询集进行分页</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django_filters.rest_framework <span class="hljs-keyword">import</span> DjangoFilterBackend<br><span class="hljs-keyword">from</span> rest_framework.filters <span class="hljs-keyword">import</span> OrderingFilter<br><span class="hljs-comment"># 导入自定义的分页引擎</span><br><span class="hljs-keyword">from</span> utils.pagination <span class="hljs-keyword">import</span> MyPagination<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfacesInfo</span>(<span class="hljs-title class_ inherited__">GenericAPIView</span>):<br><span class="hljs-comment"># 指定过滤引擎</span><br>filter_backends = [DjangoFilterBackend, OrderingFilter]<br><span class="hljs-comment"># 指定需要过滤的字段</span><br>filter_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tester&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br><span class="hljs-comment"># 指定排序字段</span><br>ordering_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br><span class="hljs-comment"># 在特定视图中指定分页引擎类（有些视图需要分页，有些不需要）</span><br>pagination_class = MyPagination<br><br>queryset = Interfaces.objects.<span class="hljs-built_in">all</span>()<br>serializer_class = InterfacesModelSerializer<br><br>    <span class="hljs-comment"># 查询接口</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-comment"># 传递查询集对象给filter_queryset()</span><br>        qs = <span class="hljs-variable language_">self</span>.filter_queryset(<span class="hljs-variable language_">self</span>.get_queryset())<br>        page = <span class="hljs-variable language_">self</span>.paginate_queryset(qs)<br>        <span class="hljs-comment"># 判断是否指定分页引擎</span><br>        <span class="hljs-keyword">if</span> page <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 调用序列化器，获取数据</span><br>            serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(instance=page, many=<span class="hljs-literal">True</span>)<br>            <span class="hljs-comment"># 将数据进行分页</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.get_paginated_response(serializer_obj.data)<br>        serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(instance=qs, many=<span class="hljs-literal">True</span>)<br>        <span class="hljs-keyword">return</span> Response(serializer_obj.data, status=status.HTTP_200_OK)<br></code></pre></td></tr></table></figure><h4 id="2）查询详情数据"><a href="#2）查询详情数据" class="headerlink" title="2）查询详情数据"></a>2）查询详情数据</h4><p>get_object()：获取url中的id，返回模型类对象</p><p>get_serializer()：返回序列化器类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectsDetail</span>(<span class="hljs-title class_ inherited__">GenericAPIView</span>):<br>    queryset = Projects.objects.<span class="hljs-built_in">all</span>()<br>    serializer_class = ProjectModelSerializer<br><br>    <span class="hljs-comment"># 查询项目：id默认为空，id为空时，查询所有项目，否则查询指定项目详情</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request, pk</span>):<br>        obj = <span class="hljs-variable language_">self</span>.get_object()<br>        serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(instance=obj)<br>        <span class="hljs-keyword">return</span> Response(serializer_obj.data, status=status.HTTP_200_OK)<br><br>    <span class="hljs-comment"># 创建项目：数据以json格式传入</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request</span>):<br>        serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(data=request.data)<br>        serializer_obj.is_valid(raise_exception=<span class="hljs-literal">True</span>)<br>        serializer_obj.save()<br>        <span class="hljs-keyword">return</span> Response(serializer_obj.data, status=status.HTTP_200_OK)<br><br>    <span class="hljs-comment"># 更新项目：传入需更新记录的id，修改数据以json形式传入</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, request, pk</span>):<br>        obj = <span class="hljs-variable language_">self</span>.get_object()<br>        serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(instance=obj, data=request.data)<br>        <span class="hljs-comment"># 在视图中抛出的异常，DRF会自动处理，报错信息以json格式返回</span><br>        serializer_obj.is_valid(raise_exception=<span class="hljs-literal">True</span>)<br>        serializer_obj.save()<br>        <span class="hljs-keyword">return</span> Response(serializer_obj.data, status=status.HTTP_201_CREATED)<br><br>    <span class="hljs-comment"># 删除项目：传入需删除记录的id</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, requset, pk</span>):<br>        obj = <span class="hljs-variable language_">self</span>.get_object()<br>        obj.delete()<br>        <span class="hljs-keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)<br></code></pre></td></tr></table></figure><ul><li><h3 id="GenericAPIView的特性"><a href="#GenericAPIView的特性" class="headerlink" title="GenericAPIView的特性"></a>GenericAPIView的特性</h3></li></ul><p>​1）GenericAPIView继承了APIView，实现了过滤、排序、分页的功能</p><p>​2）增加了对于列表视图和详情视图可能用到的通用支持方法， 每个具体通用视图都是一个GenericAPIView搭配一个或多个Mixin扩展类</p><p>​3）支持的属性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>queryset</td><td>指定列表视图的查询集</td></tr><tr><td>serializer_class</td><td>指定视图使用的序列化器</td></tr><tr><td>pagination_class</td><td>指定分页引擎</td></tr><tr><td>filter_backends</td><td>指定过滤引擎</td></tr><tr><td>lookup_field</td><td>查询单一数据库对象时使用的条件字段，默认为’pk’，可以指定为’id’</td></tr><tr><td>lookup_url_kwarg</td><td>查询单一数据时URL中的参数关键字名称，默认与look_field相同</td></tr></tbody></table><p>​4）提供的方法</p><table><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td>get_object</td><td>返回模型类数据对象（单条详情数据）</td></tr><tr><td>get_queryset(qs)</td><td>返回查询集</td></tr><tr><td>get_serializer</td><td>返回序列化器对象</td></tr><tr><td>filter_queryset</td><td>对查询集进行过滤</td></tr><tr><td>paginate_queryset</td><td>对查询集进行分页</td></tr></tbody></table><ul><li><h3 id="痛点-1"><a href="#痛点-1" class="headerlink" title="痛点"></a>痛点</h3></li></ul><p>GenericAPIView和APIView只支持对get、post、put、delete、patch等请求方法</p><p>如果要支持action：list、create、update、delete等，需继承视图集：ViewSet</p><h2 id="（三）Mixin"><a href="#（三）Mixin" class="headerlink" title="（三）Mixin"></a>（三）Mixin</h2><h4 id="拓展类"><a href="#拓展类" class="headerlink" title="拓展类"></a>拓展类</h4><ul><li><p>RetrieveModelMixin</p><p>提供 retrieve(request, *args, **kwargs) 方法，获取详情数据</p><p>获取成功，返回 200 OK，否则返回 404 Not Found</p></li><li><p>ListModelMixin</p><p>提供 list(request, *args, **kwargs) 方法，获取列表数据</p><p>获取成功，返回 200 OK，否则返回 404 Not Found</p></li><li><p>CreateModelMixin</p><p>提供 create(request, *args, **kwargs) 方法，创建数据</p><p>获取成功，返回 200 OK；请求参数有误，返回 400 Bad Request</p></li><li><p>UpdateModelMixin</p><p>提供 update(request, *args, **kwargs) 方法，全更新</p><p>提供 partial_update(request, *args, **kwargs) 方法，部分更新，支持PATCH方法</p><p>更新成功，返回 200 OK</p><p>请求参数有误，返回 400 Bad Request；不存在，返回 404 Not Found</p></li><li><p>DestoryModelMixin</p><p>提供 destory(request, *args, **kwargs) 方法，删除数据</p><p>删除成功，返回 204 No Content，不存在，返回 404 Not Found</p></li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 先继承DRF中的Mixin拓展类，最后继承GenericAPIView</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectInfo</span>(mixins.ListModelMixin, mixins.CreateModelMixin, <br>                  mixins.UpdateModelMixin, mixins.DestroyModelMixin, GenericAPIView):<br>    <br>    queryset = Projects.objects.<span class="hljs-built_in">all</span>()<br>    serializer_class = ProjectModelSerializer<br><br>    filter_backends = [DjangoFilterBackend, OrderingFilter]<br>    filter_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tester&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br>    ordering_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">list</span>(request, *args, **kwargs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.create(request, *args, **kwargs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.update(request, *args, **kwargs)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.destroy(request, *args, **kwargs)<br></code></pre></td></tr></table></figure><h2 id="（四）Concrete-Generic-Views"><a href="#（四）Concrete-Generic-Views" class="headerlink" title="（四）Concrete Generic Views"></a>（四）Concrete Generic Views</h2><h4 id="拓展类-1"><a href="#拓展类-1" class="headerlink" title="拓展类"></a>拓展类</h4><ul><li><p>RetrieveApIView</p><p>提供：get方法</p><p>继承：RetrieveModelMixin、GenericAPIView</p></li><li><p>UpdateApIView</p></li></ul><p>​提供：put、patch方法</p><p>​继承：UpdateModelMixin、GenericAPIView</p><ul><li>DestoryApIView</li></ul><p>​提供：delete方法</p><p>​继承：DestoryModelMixin、GenericAPIView</p><ul><li>ListAPIView</li></ul><p>​提供：get方法</p><p>​继承：ListModelMixin、GenericAPIView</p><ul><li>CreateAPIView</li></ul><p>​提供：post方法</p><p>​继承：CreateModelMixin、GenericAPIView</p><ul><li>ListCreateApIView</li></ul><p>​提供：post、get方法</p><p>​继承：ListModelMixin、CreateModelMixin、GenericAPIView</p><ul><li>RetrieveUpdateApIView</li></ul><p>​提供：get、put、patch方法</p><p>​继承：ListModelMixin、CreateModelMixin、GenericAPIView</p><ul><li>ListCreateApIView</li></ul><p>​提供：ge、createt方法</p><p>​继承：ListModelMixin、CreateModelMixin、GenericAPIView</p><ul><li>RetrieveUpdateApIView</li></ul><p>​提供get、put、patch方法</p><p>​继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView</p><ul><li>RetrieveDestoryApIView</li></ul><p>​提供get、delete方法</p><p>​继承：RetrieveModelMixin、DestoryModelMixin、GenericAPIView</p><ul><li>RetrieveUpdateDestoryApIView</li></ul><p>​提供get、put、patch、delete方法</p><p>​继承：RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin、GenericAPIView</p><h3 id="痛点-2"><a href="#痛点-2" class="headerlink" title="痛点"></a>痛点</h3><p>​列表视图和详情视图无法合并</p><p>​两个类视图中，有相同的get方法，会冲突</p><p>​两个类视图所对应的url地址不一致</p><h2 id="（五）ViewSet"><a href="#（五）ViewSet" class="headerlink" title="（五）ViewSet"></a>（五）ViewSet</h2><table><thead><tr><th>请求方法</th><th>动作</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>retrieve</td><td>获取详情数据（单条）</td></tr><tr><td>GET</td><td>list</td><td>获取列表数据（多条）</td></tr><tr><td>POST</td><td>create</td><td>创建数据</td></tr><tr><td>PUT</td><td>update</td><td>更新数据</td></tr><tr><td>PATCH</td><td>partial_update</td><td>部分更新</td></tr><tr><td>DELTE</td><td>destory</td><td>删除数据</td></tr></tbody></table><h3 id="ViewSet"><a href="#ViewSet" class="headerlink" title="ViewSet"></a>ViewSet</h3><p>​继承ViewSetMixin和Views.APIView</p><p>​ViewSetMixin支持action动作</p><p>​未提供get_object()、get_serializer()、queryset、serializer_class等</p><h3 id="GenericViewSet"><a href="#GenericViewSet" class="headerlink" title="GenericViewSet"></a>GenericViewSet</h3><p>​继承ViewSetMixin和generics.GenericAPIView</p><p>​提供get_object()、get_serializer()、queryset、serializer_class等</p><p>​在定义路由时，需将请求方法与action动作进行绑定</p><p>​使用Mixins类简化程序</p><ul><li><h3 id="ViewSet与GenericViewSet的区别"><a href="#ViewSet与GenericViewSet的区别" class="headerlink" title="ViewSet与GenericViewSet的区别"></a>ViewSet与GenericViewSet的区别</h3></li></ul><table><thead><tr><th>ViewSet</th><th>GenericViewSet</th></tr></thead><tbody><tr><td>继承：(ViewSetMixin, Views.APIView)</td><td>继承：(ViewSetMixin, generics.GenericAPIView)</td></tr><tr><td>未提供通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td><td>包含基本的通用View的方法集：get_object()、get_serializer()、queryset、serializer_class等</td></tr><tr><td>支持action动作</td><td>在定义路由时，需将请求方法与action动作进行映射</td></tr></tbody></table><h3 id="ModelViewSet"><a href="#ModelViewSet" class="headerlink" title="ModelViewSet"></a>ModelViewSet</h3><p>继承自GenericAPIVIew，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin</p><p>支持的Action</p><p>​列表视图：list、create</p><p>​详情视图： retrieve、 update、destory</p><p>urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 继承ViewSet后，支持在路由表中指定请求方法与action的映射</span><br><span class="hljs-comment"># as_view接收一个字典，key为请求方法，value为请求动作</span><br>urlpatterns = [<br>path(<span class="hljs-string">&#x27;projects/&#x27;</span>, views.ProjectViewSet.as_view(&#123;<br><span class="hljs-string">&#x27;get&#x27;</span>: <span class="hljs-string">&#x27;list&#x27;</span>, <span class="hljs-string">&#x27;post&#x27;</span>: <span class="hljs-string">&#x27;create&#x27;</span><br>&#125;)),<br>path(<span class="hljs-string">&#x27;projects/&lt;int:pk&gt;&#x27;</span>, views.ProjectViewSet.as_view(&#123;<br><span class="hljs-string">&#x27;get&#x27;</span>: <span class="hljs-string">&#x27;retrieve&#x27;</span>, <span class="hljs-string">&#x27;put&#x27;</span>: <span class="hljs-string">&#x27;update&#x27;</span>, <span class="hljs-string">&#x27;delete&#x27;</span>: <span class="hljs-string">&#x27;destory&#x27;</span><br>&#125;)),<br>]<br></code></pre></td></tr></table></figure><p>views.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.filters <span class="hljs-keyword">import</span> OrderingFilter<br><span class="hljs-keyword">from</span> django_filters.rest_framework <span class="hljs-keyword">import</span> DjangoFilterBackend<br><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> viewsets<br><span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Projects<br><span class="hljs-keyword">from</span> .serializers <span class="hljs-keyword">import</span> ProjectModelSerializer<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectViewSet</span>(viewsets.ModelViewSet):<br>    queryset = Projects.objects.<span class="hljs-built_in">all</span>()<br>    serializer_class = ProjectModelSerializer<br><br>    filter_backends = [DjangoFilterBackend, OrderingFilter]<br>    filter_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;tester&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br>    ordering_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="ReadOnlyModelViewSet"><a href="#ReadOnlyModelViewSet" class="headerlink" title="ReadOnlyModelViewSet"></a>ReadOnlyModelViewSet</h3><p>​继承ListModelMixin、RetrieveModelMixin、GenericAPIView</p><h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p>使用action装饰器：@action(methods, detail)</p><p>​methods：支持的请求方式</p><p>​默认值为[‘get’]，可定义多个请求方式[‘get’, ‘post’, ‘put’]</p><p>​detail：声明要处理的是否是详情资源对象（通过url路径获取主键）</p><p>​True 表示使用通过URL获取的主键对应的数据对象</p><p>​False 表示不使用URL获取主键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.decorators <span class="hljs-keyword">import</span> action<br><br><span class="hljs-comment"># 可以使用action装饰器自定义动作</span><br><span class="hljs-comment"># 默认methods参数为[&#x27;get&#x27;]，可定义多个请求方式[&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;]</span><br><span class="hljs-comment"># detail为必填参数，指定是否为详情数据，如需要传递主键ID，则detail=True，否则为列表数据，detail=False</span><br><span class="hljs-comment"># url_path指定url路径部分，默认为action名称</span><br><span class="hljs-comment"># url_name指定url的名称，默认为action名称(当前为names，完整的路由名称为/names-list)</span><br><span class="hljs-meta">@action(<span class="hljs-params">methods=[<span class="hljs-string">&#x27;get&#x27;</span>], detail=<span class="hljs-literal">False</span>, url_path=<span class="hljs-string">&#x27;test&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">names</span>(<span class="hljs-params">self, requset, *args, **kwargs</span>):<br>   qs = <span class="hljs-variable language_">self</span>.filter_queryset(<span class="hljs-variable language_">self</span>.get_queryset())<br>   serializer_obj = <span class="hljs-variable language_">self</span>.get_serializer(instance=qs, many=<span class="hljs-literal">True</span>)<br>   <span class="hljs-keyword">return</span> Response(serializer_obj.data)<br></code></pre></td></tr></table></figure><h4 id="router"><a href="#router" class="headerlink" title="router"></a>router</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.routers <span class="hljs-keyword">import</span> DefaultRouter, SimpleRouter<br><br><span class="hljs-comment"># 1. 定义路由对象</span><br>router = SimpleRouter()<br>router = DefaultRouter()<br><span class="hljs-comment"># 2. 使用路由对象，调用register()，进行注册</span><br><span class="hljs-comment"># 第一个参数指定路由前缀，子应用名称；第二个参数，指定视图集类，无需调用.as_view()</span><br>router.register(<span class="hljs-string">r&#x27;projects&#x27;</span>, views.ProjectViewSet)<br><span class="hljs-comment"># 使用路由对象.urls属性来获取自动生成的路由条目，往往为列表</span><br><span class="hljs-comment"># 需要将列表添加到urlpatterns</span><br>urlpatterns = [<br>   <span class="hljs-comment"># name可以指定路由名称</span><br>   path(<span class="hljs-string">&#x27;projects&#x27;</span>, views.ProjectViewSet.as_view(), name=<span class="hljs-string">&#x27;&#x27;</span>)<br>]<br>urlpatterns += router.urls<br></code></pre></td></tr></table></figure><h2 id="生成API文档"><a href="#生成API文档" class="headerlink" title="生成API文档"></a>生成API文档</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​生成API文档平台</p><p>​自动生成测试代码</p><p>​支持接口测试</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>django-rest-swagger、coreapi</p><p>可选：Pygments、Markdown</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="1-drf-yasg"><a href="#1-drf-yasg" class="headerlink" title="1. drf-yasg"></a>1. drf-yasg</h4><p>​安装：pip install drf-yasg</p><p>​添加到子应用：INSTALLED_APPS &#x3D; [ ‘drf_yasg’, ]</p><p>配置urls.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> drf_yasg <span class="hljs-keyword">import</span> openapi <br><span class="hljs-keyword">from</span> drf_yasg.views <span class="hljs-keyword">import</span> get_schema_view <br><br><span class="hljs-comment"># 声明schema_view</span><br>schema_view = get_schema_view( <br>    openapi.Info( <br>        title=<span class="hljs-string">&quot;Lemon API接口文档平台&quot;</span>, <span class="hljs-comment"># 必传 </span><br>        default_version=<span class="hljs-string">&#x27;v1&#x27;</span>, <span class="hljs-comment"># 必传 </span><br>        description=<span class="hljs-string">&quot;这是一个美轮美奂的接口文档&quot;</span>, <br>        terms_of_service=<span class="hljs-string">&quot;http://api.keyou.site&quot;</span>, <br>contact=openapi.Contact(email=<span class="hljs-string">&quot;keyou100@qq.com&quot;</span>),<br>        license=openapi.License(name=<span class="hljs-string">&quot;BSD License&quot;</span>), <br>),<br>    public=<span class="hljs-literal">True</span>, <br>)<br><br><span class="hljs-comment"># 设置urlpatterns</span><br>urlpatterns = [ <br>    re_path(<span class="hljs-string">r&#x27;^swagger(?P&lt;format&gt;\.json|\.yaml)$&#x27;</span>, <br>schema_view.without_ui(cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema-json&#x27;</span>), <br>    path(<span class="hljs-string">&#x27;swagger/&#x27;</span>, schema_view.with_ui(<span class="hljs-string">&#x27;swagger&#x27;</span>, cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema-swagger-ui&#x27;</span>), <br>    path(<span class="hljs-string">&#x27;redoc/&#x27;</span>, schema_view.with_ui(<span class="hljs-string">&#x27;redoc&#x27;</span>, cache_timeout=<span class="hljs-number">0</span>), name=<span class="hljs-string">&#x27;schema- redoc&#x27;</span>), ]<br></code></pre></td></tr></table></figure><h4 id="2-coreapi"><a href="#2-coreapi" class="headerlink" title="2. coreapi"></a>2. coreapi</h4><p>配置全局settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">REST_FRAMEWORK = &#123;<br><span class="hljs-string">&#x27;DEFAULT_SCHEMA_CLASS&#x27;</span>: <span class="hljs-string">&#x27;rest_framework.schemas.coreapi.AutoSchema&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.documentation <span class="hljs-keyword">import</span> include_docs_urls<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path, include<br>urlpatterns = [<br>path(<span class="hljs-string">&#x27;docs/&#x27;</span>, include_docs_urls(title=<span class="hljs-string">&#x27;接口测试文档&#x27;</span>)),<br>]<br></code></pre></td></tr></table></figure><p>添加注释</p><p>​单一方法的视图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接在视图类中添加注释</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectsListView</span>(<span class="hljs-title class_ inherited__">ListAPIView</span>): <br><span class="hljs-string">&quot;&quot;&quot; 返回所有项目信息 &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>​多个方法的视图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectsListCreateView</span>(<span class="hljs-title class_ inherited__">ListCreateAPIView</span>): <br><span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">get: 返回所有项目信息 </span><br><span class="hljs-string">post: 新建项目 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>​视图集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProjectsViewset</span>(viewsets.ModelViewSet):<br> <span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">create: 创建项目 </span><br><span class="hljs-string">retrieve: 获取项目详情数据 </span><br><span class="hljs-string">update: 完整更新项目 </span><br><span class="hljs-string">partial_update: 部分更新项目 </span><br><span class="hljs-string">destroy: 删除项目 </span><br><span class="hljs-string">list: 获取项目列表数据 </span><br><span class="hljs-string">names: 获取所有项目名称 </span><br><span class="hljs-string">interfaces: 获取指定项目的所有接口数据</span><br><span class="hljs-string"> &quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UI自动化</title>
    <link href="/2023/06/14/AutoTest/UI%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2023/06/14/AutoTest/UI%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="UI自动化"><a href="#UI自动化" class="headerlink" title="UI自动化"></a>UI自动化</h1><h2 id="知识树"><a href="#知识树" class="headerlink" title="知识树"></a>知识树</h2><p><img src="/the-nuo/picture/Snipaste_2021-05-18_23-07-36.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_23-09-36.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_23-10-16.png"><br>订正：JS处理滚动条-移动到页面顶部 driver.execute_script(“window.scrollTo(document.body.scrollHeight,0)”)  </p><p>processon地址：  </p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/5d81c22ce4b04c14c4e758e3"></iframe><h2 id="项目中开展web自动化测试流程"><a href="#项目中开展web自动化测试流程" class="headerlink" title="项目中开展web自动化测试流程"></a>项目中开展web自动化测试流程</h2><p><img src="/the-nuo/picture/Snipaste_2021-05-21_14-02-36.png"></p><h2 id="web自动化架构"><a href="#web自动化架构" class="headerlink" title="web自动化架构"></a>web自动化架构</h2><p><img src="/the-nuo/picture/QQ20210523-0.jpg"></p><h3 id="有哪些因素可提高或影响脚本稳定性"><a href="#有哪些因素可提高或影响脚本稳定性" class="headerlink" title="有哪些因素可提高或影响脚本稳定性"></a>有哪些因素可提高或影响脚本稳定性</h3><h4 id="外部因素"><a href="#外部因素" class="headerlink" title="外部因素"></a>外部因素</h4><ul><li>1.系统环境 依赖的系统里的数据</li><li>2.网络 设备</li></ul><h4 id="代码因素"><a href="#代码因素" class="headerlink" title="代码因素"></a>代码因素</h4><ul><li>1.元素定位</li><li>2.等待</li><li>3.用例复杂度 独立性 用例选择</li></ul><h4 id="辅助手段"><a href="#辅助手段" class="headerlink" title="辅助手段"></a>辅助手段</h4><ul><li>1.重运行</li><li>2.jenkis集成</li></ul><h2 id="自动化用例设计原则"><a href="#自动化用例设计原则" class="headerlink" title="自动化用例设计原则"></a>自动化用例设计原则</h2><ul><li>1.不是所有的手工用例都要转为自动化用例</li><li>2.考虑到脚本开发的成本，不要选择流程太复杂的用例，如有必要，可以考虑把流程拆分成多个用例来实现脚本</li><li>3.选择的用例最好可以构建成场景 例如一个功能模块 分多个用例 多个用例使用同一个场景</li><li>4.选择的用例可以带有目的性。例如一部分做冒烟测试一部分做回归测试，会存在重叠关系，如果当前的用例不能满足需求，可以修改用例来适应脚本和需求</li><li>5.选取的用例可以是你认为是重复执行很繁琐的部分，例如字段验证，提示信息验证这类。这部分适用于回归测试</li><li>6.选取的用例可以是主体流程，这部分适用于冒烟测试</li><li>7.自动化测试也可以用来做配置检查，数据库检查，这些可能超越了手工用例，但也算用例拓展的一部分。可以有选择增加</li><li>8.平时在手工测试中，如果需要构造一些复杂的数据或重复一些简单的机械性动作，可以由自动化脚本来做</li></ul><h3 id="在编写自动化测试用例应遵循以下原则"><a href="#在编写自动化测试用例应遵循以下原则" class="headerlink" title="在编写自动化测试用例应遵循以下原则"></a>在编写自动化测试用例应遵循以下原则</h3><ul><li>1.一个用例为一个完整的场景。从用户登录到最终退出关闭浏览器</li><li>2.一个用例只验证一个功能点，不要试图在用户登录系统后把所有的功能都验证一遍</li><li>3.尽量少的写逆向逻辑用例，一方面因为逆向逻辑用例很多（例如手机号输错有几十种情况），另一方面自动化脚本本身脆弱，对于复杂的逆向逻辑用例实现麻烦且容易出错。最重要的是用例的稳定性</li><li>4.用例与用例之间尽量避免产生依赖</li><li>5.一条用例完成测试之后需要对测试场景进行还原，以免影响其他用例的执行-数据清理。可以执行自动化脚本没在测试系统里删除产生的数据。</li></ul><h2 id="web自动化用例设计三步骤"><a href="#web自动化用例设计三步骤" class="headerlink" title="web自动化用例设计三步骤"></a>web自动化用例设计三步骤</h2><ul><li>1.前置(准备工作-)  通过代码来创建前置 - 尽量少的依赖环境数据例如通过接口准备一些前置数据  </li><li>2.步骤(用户页面操作)  </li><li>3.断言(页面操作)</li></ul><h2 id="selenium"><a href="#selenium" class="headerlink" title="selenium"></a>selenium</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li>pip install -U selenium</li><li>安装chrome浏览器 和chromedriver,浏览器版本和driver版本要匹配</li></ul><h4 id="selenium-webdriver原理"><a href="#selenium-webdriver原理" class="headerlink" title="selenium webdriver原理"></a>selenium webdriver原理</h4><ul><li>1.webdriver启动浏览器驱动程序，并设置侦听端口号</li><li>2.webdriver客户端与浏览器服务端即驱动建立连接，发送HTTP请求</li><li>3.连接成功后，python selenium webdriver客户端和浏览器服务端之间通过http通信传递命令，驱动收到指令后，驱动浏览器去执行命令</li><li>4.驱动把执行结果返回给selenim webdriver客户端</li><li>5.继续发下一个http请求</li><li>最后 断开连接 关闭驱动服务 关闭浏览器<br><img src="/the-nuo/picture/Snipaste_2021-05-19_11-16-22.png" alt="seleniumwebdriver"></li></ul><h3 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h3><ul><li>driver.finde_element(by&#x3D;BY.XPATH,表达式)</li><li>driver.finde_elements(by&#x3D;BY.XPATH,表达式)</li><li>driver.find_elemnt_by_xpath(表达式)</li></ul><h4 id="xpath定位补充"><a href="#xpath定位补充" class="headerlink" title="xpath定位补充"></a>xpath定位补充</h4><ul><li>1.逻辑运算 and or<br>&#x2F;&#x2F;标签名[@属性&#x3D;值 and @属性&#x3D;值 and contains(@属性&#x2F;text(),值)] <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">//<span class="hljs-keyword">a</span>[<span class="hljs-keyword">text</span>()=<span class="hljs-string">&quot;公告&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">contains</span>(@href,<span class="hljs-string">&quot;/index/courseid/&quot;</span>)]<br></code></pre></td></tr></table></figure></li></ul><h4 id="轴定位-分析元素之间的关系-页面结构"><a href="#轴定位-分析元素之间的关系-页面结构" class="headerlink" title="轴定位 分析元素之间的关系 页面结构"></a>轴定位 分析元素之间的关系 页面结构</h4><p>应用场景：页面显示为一个表格样式的数据列，需要通过组合来定位元素<br>注意：  后面接的是轴定位表达式前面是用&#x2F;<br>语法：  已知元素&#x2F;轴名称::标签名[@属性&#x3D;值]</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/p[@title=&quot;路飞&quot;]/preceding</span>-sibling::p[<span class="hljs-variable">@class</span>=<span class="hljs-string">&quot;stuo&quot;</span>]<br>/<span class="hljs-regexp">/p[@title=&quot;路飞&quot;]/parent</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:*/preceding-sibling</span><span class="hljs-symbol">:</span><span class="hljs-symbol">:li//p</span>[<span class="hljs-variable">@class</span>=<span class="hljs-string">&quot;sss&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="等待"><a href="#等待" class="headerlink" title="等待"></a>等待</h3><p>原则： 显性等待为主配合强制等待sleep保持用例稳定性</p><ul><li>强制等待 sleep</li><li>隐性等待<br>应用场景：元素存在 &#x2F; 1条命令执行完成<br>    每个会话中，只需要被调用一次。一般写在打开浏览器后</li><li>显性等待<br>应用场景：等待元素可见，等待元素可用，等待新的窗口出现，在你需要的地方使用显性等待</li></ul><h3 id="窗口切换"><a href="#窗口切换" class="headerlink" title="窗口切换"></a>窗口切换</h3><h4 id="什么情况下需要窗口切换？"><a href="#什么情况下需要窗口切换？" class="headerlink" title="什么情况下需要窗口切换？"></a>什么情况下需要窗口切换？</h4><p>  页面的操作，打开了一个新的窗口，你需要在新的窗口中进行下一步操作</p><h4 id="怎么知道要切换到哪一个窗口？代码怎么知道哪个窗口是新的窗口？"><a href="#怎么知道要切换到哪一个窗口？代码怎么知道哪个窗口是新的窗口？" class="headerlink" title="怎么知道要切换到哪一个窗口？代码怎么知道哪个窗口是新的窗口？"></a>怎么知道要切换到哪一个窗口？代码怎么知道哪个窗口是新的窗口？</h4><ul><li>1.得到当前打开的所有窗口 获取句柄 每个窗口都有一个句柄，句柄是一个列表，先出现的先追加到列表，最新的窗口，在列表的最后，最先打开的窗口在列表第一个<br>wins &#x3D; driver.window_handles</li><li>2.切换窗口<br>driver.switch_to.window(wins[-1])</li></ul><h3 id="iframe切换"><a href="#iframe切换" class="headerlink" title="iframe切换"></a>iframe切换</h3><p>driver.switch_to.iframe()<br>参数支持3种方式来确定切换到哪一个iframe</p><ul><li><ol><li>iframe下标，从0开始 driver.switch_to.frame(3)</li></ol></li><li>2.iframe元素的name属性 driver.switch_to.frame(“login_frame_qq)</li><li>3.iframe的这个webElement元素 driver.switch_to.frame(driver.find_element_by_xpath(‘&#x2F;&#x2F;iframe[@name&#x3D;”login”]’))<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">嵌套iframe回到上一级<br>driver<span class="hljs-selector-class">.switch_to</span><span class="hljs-selector-class">.parent_frame</span>()<br></code></pre></td></tr></table></figure></li></ul><h3 id="鼠标操作-ActionChaims"><a href="#鼠标操作-ActionChaims" class="headerlink" title="鼠标操作 ActionChaims"></a>鼠标操作 ActionChaims</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> selenium.webdriver.common.action_chains <span class="hljs-keyword">import</span> ActionChains<br>#  <span class="hljs-number">1.</span>找到鼠标要操作的元素<br>loc = (<span class="hljs-keyword">BY</span>.XPATH,<span class="hljs-string">&#x27;//div[@id=&quot;ui&quot;]//a[@name=&quot;setting&quot;]&#x27;</span>)  <br>ele = driver.find_element(*loc)<br># <span class="hljs-number">2.</span>实例化ActionChaims类<br>ac = ActionChaims(driver)<br># <span class="hljs-number">3.</span>调用鼠标行为执行鼠标动作<br>ac.move_to_element(ele).<span class="hljs-keyword">perform</span>()<br># <span class="hljs-number">4.</span>等待下拉列表中的元素可见<br>loc=(<span class="hljs-keyword">By</span>.XPATH,<span class="hljs-string">&#x27;/A[text()=&quot;高级搜索&quot;]&#x27;</span>)<br>WebDriverWait(driver,<span class="hljs-number">10</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br># <span class="hljs-number">5.</span>选择元素点击<br>driver.find_element(*loc).click()<br></code></pre></td></tr></table></figure><h3 id="键盘操作-Keys"><a href="#键盘操作-Keys" class="headerlink" title="键盘操作 Keys"></a>键盘操作 Keys</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">driver = webdriver<span class="hljs-selector-class">.Chrome</span>()<br>driver<span class="hljs-selector-class">.get</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>)<br>element = driver<span class="hljs-selector-class">.find_element_by_id</span>(<span class="hljs-string">&quot;kw&quot;</span>)<br>element<span class="hljs-selector-class">.send_keys</span>(<span class="hljs-string">&quot;selenium&quot;</span>,Keys.ENTER)<br><br>element<span class="hljs-selector-class">.send_keys</span>(Keys<span class="hljs-selector-class">.CONTROL</span>,<span class="hljs-string">&quot;c&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="js处理日历控件"><a href="#js处理日历控件" class="headerlink" title="js处理日历控件"></a>js处理日历控件</h3><h4 id="修改readonly属性为false-输入"><a href="#修改readonly属性为false-输入" class="headerlink" title="修改readonly属性为false 输入"></a>修改readonly属性为false 输入</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">from selenium import webdriver<br>driver = webdriver.Chrome()<br>loc =(<span class="hljs-string">&quot;xpath&quot;</span>,<span class="hljs-string">&quot;//*[@id=&#x27;train_date&#x27;]&quot;</span>)<br>ele = driver.find_elemnt(*loc)<br>now_time = time.datetime()<br><span class="hljs-comment"># 准备js语句</span><br>js = <span class="hljs-string">&quot;var a = arguments[0];a.readOnly=false;a.value=arguments[1]&quot;</span><br><span class="hljs-comment"># 传入js语句和要传入的参数。arguments接收一个参数列表，以下标来取数</span><br>driver.execute_script(js,ele,now_time)<br></code></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><h4 id="1-pywin32仅支持windows"><a href="#1-pywin32仅支持windows" class="headerlink" title="1.pywin32仅支持windows"></a>1.pywin32仅支持windows</h4><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs hsp">import win32gui                                                                     <br>import win32con                                                                     <br>                                                                                                                          <br>                                                                                    <br><span class="hljs-meta"># <span class="hljs-number">1</span> 找到输入框和打开按钮 元素；</span><br>  <span class="hljs-number">2</span> 输入地址，点击打开。                                                      <br>                                                                                    <br><span class="hljs-meta"># 前提 ：windows上传窗口已经出现。sleep1<span class="hljs-number">-2</span>秒等待弹出的出现。  </span><br><br>def upload(filePath,browser_type=<span class="hljs-string">&quot;chrome&quot;</span>):                                         <br>    <span class="hljs-keyword">if</span> browser_type == <span class="hljs-string">&quot;chrome&quot;</span>:                                                    <br>        <span class="hljs-keyword">title</span> = <span class="hljs-string">&quot;打开&quot;</span>                                                                <br>    <span class="hljs-keyword">else</span>:                                                                           <br>        <span class="hljs-keyword">title</span> = <span class="hljs-string">&quot;&quot;</span>                                                                  <br>                                                                                    <br>    <span class="hljs-meta">#找元素                                                                            </span><br>    <span class="hljs-meta">#一级窗口<span class="hljs-string">&quot;#32770&quot;</span>,<span class="hljs-string">&quot;打开&quot;</span>                                                              </span><br>    <span class="hljs-keyword">dialog</span> = win32gui.FindWindow(<span class="hljs-string">&quot;#32770&quot;</span>,<span class="hljs-keyword">title</span>)                                    <br>    <span class="hljs-meta">#                                                                               </span><br>    ComboBoxEx32 = win32gui.FindWindowEx(<span class="hljs-keyword">dialog</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;ComboBoxEx32&quot;</span>,None)  <span class="hljs-meta">#二级         </span><br>    comboBox = win32gui.FindWindowEx(ComboBoxEx32,<span class="hljs-number">0</span>,<span class="hljs-string">&quot;ComboBox&quot;</span>,None)   <span class="hljs-meta">#三级          </span><br>    <span class="hljs-meta">#编辑按钮                                                                           </span><br>    edit = win32gui.FindWindowEx(comboBox,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;Edit&#x27;</span>,None)    <span class="hljs-meta">#四级                     </span><br>    <span class="hljs-meta">#打开按钮                                                                           </span><br>    <span class="hljs-keyword">button</span> = win32gui.FindWindowEx(<span class="hljs-keyword">dialog</span>,<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;Button&#x27;</span>,<span class="hljs-string">&quot;打开(&amp;O)&quot;</span>)   <span class="hljs-meta">#二级                </span><br>                                                                                    <br>                                                                                    <br>    <span class="hljs-meta">#往编辑当中，输入文件路径 。                                                                 </span><br>    win32gui.SendMessage(edit,win32con.WM_SETTEXT,None,filePath)    <span class="hljs-meta">#发送文件路径         </span><br>    win32gui.SendMessage(<span class="hljs-keyword">dialog</span>, win32con.WM_COMMAND, <span class="hljs-number">1</span>, <span class="hljs-keyword">button</span>)    <span class="hljs-meta">#点击打开按钮         </span><br>                                                                                    <br>                                                                                    <br>==============运行=========                                                          <br><span class="hljs-meta"># ## 前提：上传窗口弹出来 -- 页面操作。</span><br>driver.find_element().click()                             <br><span class="hljs-meta"># time.sleep(<span class="hljs-number">2</span>) # 必须等待                                                             </span><br><span class="hljs-meta"># upload(<span class="hljs-string">&quot;D:\\chromedriver.log&#x27; &#x27;D:\\chromedriver_server.log&quot;</span>)                      </span><br>                                                                                    <br>                                                                                    <br></code></pre></td></tr></table></figure><h4 id="2-pywinauto"><a href="#2-pywinauto" class="headerlink" title="2.pywinauto"></a>2.pywinauto</h4><p>pywinauto 的使用介绍<br>关于文件上传的弹窗，在 python 中可以通过 pywinauto 模块来进行操作，pywinauto 是 python 中用来做的 PC 端自动化的一个库。PC 端的所有窗口都可以使用它来进行操作。<br>需要先学习下pywinauto的控件定位。在进行文件上传的时候，我们需要这个窗口进行操作的一共是三个步骤：</p><p>操作步骤：</p><ul><li>1、文件路径填写</li><li>2、文件名填写</li><li>3、点击打开<br>在进行操作之前，我们就需要定位到这几个控件  </li><li>1、路径输入框</li><li>2、文件输入框</li><li>3、打开按钮<br>关于控件定位操作的具体细节，大家可以去自行学习 pywinauto 的使用<br>具体定位代码如下：<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> pywinauto<br><br><span class="hljs-meta"># 使用pywinautoc创建一个操作桌面窗口的对象</span><br><span class="hljs-title">app</span> = pywinauto.<span class="hljs-type">Desktop</span>()<br><span class="hljs-meta"># 选中文件上传的窗口</span><br><span class="hljs-title">dlg</span> = app[<span class="hljs-string">&quot;打开&quot;</span>]<br><br><span class="hljs-meta"># 选中文件地址输入框</span><br><span class="hljs-title">dlg</span>[<span class="hljs-string">&quot;Toolbar3&quot;</span>]<br><br><span class="hljs-meta"># 选中文件名输入框</span><br><span class="hljs-title">dlg</span>[<span class="hljs-string">&quot;文件名(&amp;N):Edit&quot;</span>]<br><br><span class="hljs-meta"># 选择打开按钮</span><br><span class="hljs-title">dlg</span>[<span class="hljs-string">&quot;打开(&amp;O)&quot;</span>]<br></code></pre></td></tr></table></figure>文件上传小案例<br>小编事先找好了一个文件上传的地址，这边给大家来演示一个案例</li></ul><p>第一步通过 selenium 打开文件上传的地址，点击上传文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> selenium import webdriver<br><br>url= <span class="hljs-string">&quot;https://www.layui.com/demo/upload.html&quot;</span><br>browser = webdriver.Chrome()<br><span class="hljs-comment"># 访问图片上传的网页地址</span><br>browser.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">url</span>=url)<br><span class="hljs-comment"># 点击图片上传按钮，打开文件选择窗口</span><br>browser.find_element_by_xpath(<span class="hljs-string">&quot;//button[@id=&#x27;test2&#x27;]&quot;</span>).click()<br><br></code></pre></td></tr></table></figure><p><img src="/the-nuo/picture/Snipaste_2021-05-20_15-17-44.png"><br>2.通过 pywinauto 选择上传文件，点击进行上传</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-built_in">import</span> pywinauto<br>from pywinauto.keyboard <span class="hljs-built_in">import</span> send_keys<br><span class="hljs-comment"># 使用pywinauto来选择文件</span><br>a<span class="hljs-attr">pp</span> <span class="hljs-operator">=</span> pywinauto.Desktop()<br><span class="hljs-comment"># 选择文件上传的窗口</span><br>d<span class="hljs-attr">lg</span> <span class="hljs-operator">=</span> app[<span class="hljs-string">&quot;打开&quot;</span>]<br><br><span class="hljs-comment"># 选择文件地址输入框，点击激活</span><br>dlg[<span class="hljs-string">&quot;Toolbar3&quot;</span>].click()<br><span class="hljs-comment"># 键盘输入上传文件的路径</span><br>send_keys(<span class="hljs-string">&quot;C:<span class="hljs-char escape_">\课</span>件<span class="hljs-char escape_">\i</span>mages&quot;</span>)<br><span class="hljs-comment"># 键盘输入回车，打开该路径</span><br>send_keys(<span class="hljs-string">&quot;&#123;VK_RETURN&#125;&quot;</span>)<br><br><span class="hljs-comment"># 选中文件名输入框，输入文件名</span><br>dlg[<span class="hljs-string">&quot;文件名(&amp;N):Edit&quot;</span>].type_keys(<span class="hljs-string">&quot;9.png&quot;</span>)<br><br><span class="hljs-comment"># 点击打开</span><br>dlg[<span class="hljs-string">&quot;打开(&amp;O)&quot;</span>].click()<br><br></code></pre></td></tr></table></figure><h2 id="PO设计模式"><a href="#PO设计模式" class="headerlink" title="PO设计模式"></a>PO设计模式</h2><h3 id="核心思想：测试对象（页面），测试用例（页面操作-测试数据）彻底分离"><a href="#核心思想：测试对象（页面），测试用例（页面操作-测试数据）彻底分离" class="headerlink" title="核心思想：测试对象（页面），测试用例（页面操作+测试数据）彻底分离"></a>核心思想：测试对象（页面），测试用例（页面操作+测试数据）彻底分离</h3><p>在做web 测试时，无论是什么业务，都是在页面上去操作，即所有的测试用例都是在页面中操作的。比如一个用例是由5个页面的功能串行组成的。<br>假设一个产品有30个页面，有500个功能测试用例。那么这500个功能测试用例就是有30个页面的功能组成。<br>如此，如果能够把30个页面的功能封装起来，500个用例按照业务场景从30个页面当中调用需要的页面即可。  </p><p>这种方式叫做PO模式，全称 Page object ,页面对象模型。  </p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>1.将页面的元素定位和元素行为封装成一个 page 类。 </li><li>2.用例中直接调用页面当中的页面操作，实现页面对象和测试用例分离。 用例中看不到元素定位和操作</li></ul><p>在测试用例中，调用所需页面对象中的行为，组成测试用例。  </p><h3 id="PO设计模式优势"><a href="#PO设计模式优势" class="headerlink" title="PO设计模式优势"></a>PO设计模式优势</h3><ul><li>1、当某个页面的元素发生变化，只需要修改该页面对象中的代码即可，测试用例不需要修改。</li><li>2、提高代码重用率。结构清晰，维护代码更容易。</li><li>3、测试用例发生变化时，不需要或者只需要修改少数页面对象代码即可</li></ul><h2 id="Pytest"><a href="#Pytest" class="headerlink" title="Pytest"></a>Pytest</h2><h3 id="pytest和unittest区别"><a href="#pytest和unittest区别" class="headerlink" title="pytest和unittest区别"></a>pytest和unittest区别</h3><ul><li>1.表达用例 unittest:定义一个类，继承unittest.TestCase pytest:类&#x2F;函数</li><li>2.断言的表达 unitest:self.assert() pytest:assert 表达式（结果为True断言成功否则断言失败）逻辑&#x2F;成员&#x2F;函数返回值&#x2F;比较</li><li>3.用例收集 unittest:TestLoader类+TestSuite类，discover收集用例 pytest:自动收集用例</li><li>4.fixture前置后置：unittest:setup&#x2F;teardown  setupClass&#x2F;teardownClass (名称固定)<br>             pytest:function(用例)class(测试类)Module(.py模块)Session(会话）</li><li>5.插件:unittest:无 pytest:700+ <a href="http://plugincompat.herokuapp.com/">http://plugincompat.herokuapp.com/</a> html插件 allure报告</li></ul><h3 id="pytest用例收集机制"><a href="#pytest用例收集机制" class="headerlink" title="pytest用例收集机制"></a>pytest用例收集机制</h3><ul><li>1.目录：pytest命令在哪个目录下执行，那就默认从哪个目录下开始搜索用例    </li><li>2.文件&#x2F;子包python package：1）.py结尾 2）文件名以test_开头或者以_test结尾  </li><li>3.用例名称：以test_开头的函数，或者以Test开头的类名下（不含__init__)，以test_开头的方法</li></ul><h3 id="pytest用例执行顺序"><a href="#pytest用例执行顺序" class="headerlink" title="pytest用例执行顺序"></a>pytest用例执行顺序</h3><ul><li>1.文件名称顺序 -ASCII顺序 哪个文件先识别，哪个文件下的用例，先执行</li><li>2.文件内部：代码的先后顺序 从上到下</li></ul><h3 id="pytest常用命令"><a href="#pytest常用命令" class="headerlink" title="pytest常用命令"></a>pytest常用命令</h3><p>pytest -h<br>命令行输入pytest -h，找到里面两个命令行参数： –lf 和 –ff  </p><ul><li>–lf, –last-failed   只重新运行上次运行失败的用例（或如果没有失败的话会全部跑）  </li><li>–ff, –failed-first  运行所有测试，但首先运行上次运行失败的测试（这可能会重新测试，从而导致重复的fixture setup&#x2F;teardown）<br>pytest –lf<br>pytest –ff</li></ul><h3 id="分布式执行用例，用例设计原则："><a href="#分布式执行用例，用例设计原则：" class="headerlink" title="分布式执行用例，用例设计原则："></a>分布式执行用例，用例设计原则：</h3><p>1.用例之间都是独立的，<br>2.用例a不要去依赖用例b<br>3.用例执行没先后顺序<br>4.随机都能执行每个用例都能独立运行成功每个用例都能重复运行，不影响其它用例<br>这跟就我们平常多个人工测试一样，用例都是独立的，可以随机分配不同人员执行，互相不依赖，用例之间也不存在先后顺序。<br>pytest-xdist  </p><h3 id="并行测试"><a href="#并行测试" class="headerlink" title="并行测试"></a>并行测试</h3><p>多cpu并行执行用例，直接加个-n参数即可，后面num参数就是并行数量，比如num设置为3<br> pytest -n 3</p><h3 id="html测试报告"><a href="#html测试报告" class="headerlink" title="html测试报告"></a>html测试报告</h3><p>安装：pip install pytest-html<br>命令：pytest –html&#x3D;相对路径（）<br>使用pytest-xdist插件也能生成html报告,完美支持pytest-html插件<br> pytest -n 3 –html&#x3D;report.html –self-contained-html</p><h3 id="重复执行用例："><a href="#重复执行用例：" class="headerlink" title="重复执行用例："></a>重复执行用例：</h3><p>使用–count命令行选项指定要运行测试用例和测试次数</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">py<span class="hljs-selector-class">.test</span> <span class="hljs-attr">--count</span>=<span class="hljs-number">10</span> test_file<span class="hljs-selector-class">.py</span><br>pytest baidu/test_1_baidu<span class="hljs-selector-class">.py</span> -s <span class="hljs-attr">--count</span>=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>会第一个用例运行5次 然后运行第二个用例5次 如果希望 第一个用例 第二个用例这样按顺序重复5次 要用到–repeat-scope  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pytest tearr_function.py -s <span class="hljs-attribute">--count</span>=5 <span class="hljs-attribute">--repeat-scope</span>=session<br></code></pre></td></tr></table></figure><p>如果要在代码中标记要重复多次的用例 可以使用</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">@pytest.<span class="hljs-keyword">mark</span>.<span class="hljs-keyword">repeat</span>(<span class="hljs-keyword">count</span>)<br></code></pre></td></tr></table></figure><p>这样执行用例时候，就不用带上–count参数，只针对test_02重复执行5次</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pytest</span> tearr_function.py -s<br></code></pre></td></tr></table></figure><p>果您正在尝试诊断间歇性故障，那么一遍又一遍地运行相同的测试直到失败是有用的。您可以将pytest的-x选项与pytest-repeat结合使用，以强制测试运行器在第一次失败时停止。例如：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">py</span>.test --<span class="hljs-built_in">count</span>=<span class="hljs-number">1000</span> -<span class="hljs-keyword">x</span> test_file.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><p>这将尝试运行test_file.py 1000次，但一旦发生故障就会停止</p><h3 id="Pytest之fixture前置后置"><a href="#Pytest之fixture前置后置" class="headerlink" title="Pytest之fixture前置后置"></a>Pytest之fixture前置后置</h3><h4 id="unittest与pytest前置后置区别："><a href="#unittest与pytest前置后置区别：" class="headerlink" title="unittest与pytest前置后置区别："></a>unittest与pytest前置后置区别：</h4><ul><li>unittest: 固定名称 setup teardown作用域测试函数 setupClass teardownClass 作用域测试类  </li><li>pytest: 不固定名称&#x2F;前置后置放在一个函数里&#x2F;独立存在不与测试类放在一起&#x2F;作用域为函数&#x2F;类&#x2F;模块&#x2F;会话</li></ul><h4 id="pytest-fixture申明"><a href="#pytest-fixture申明" class="headerlink" title="pytest fixture申明"></a>pytest fixture申明</h4><p>1.测试用例文件中定义<br>2.conftest.py文件中定义，在conftest所在的文件夹中fxiture共享，conftest名称固定</p><ul><li>1）专门用来存放fixture.</li><li>2）作用域：conftest.py所在的文件夹内的用例都可以使用</li><li>3）用例文件当中不需要引入，直接调用fixture名称就可以了。</li><li>4）可以在不同的层级，创建conftest.py</li></ul><h4 id="fixture前置后置定义"><a href="#fixture前置后置定义" class="headerlink" title="fixture前置后置定义"></a>fixture前置后置定义</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@pytest</span>.fixture<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">access_web</span>():<br>    <span class="hljs-comment"># 前置 - 打开浏览器访问网址</span><br>    driver = webdriver.<span class="hljs-title class_">Chrome</span>()<br>    driver.get(<span class="hljs-variable constant_">CD</span>.web_login_url)<br>    <span class="hljs-comment"># 分界线+返回值</span><br>    <span class="hljs-keyword">yield</span> driver       <br>    <span class="hljs-comment"># 后置 - 关闭浏览器</span><br>    driver.quit()<br></code></pre></td></tr></table></figure><h4 id="如何区分前置后置：yield关键字-yield关键字之前为前置-yield关键字之后为后置"><a href="#如何区分前置后置：yield关键字-yield关键字之前为前置-yield关键字之后为后置" class="headerlink" title="如何区分前置后置：yield关键字 yield关键字之前为前置 yield关键字之后为后置"></a>如何区分前置后置：yield关键字 yield关键字之前为前置 yield关键字之后为后置</h4><h4 id="测试用例中如何调用前置后置"><a href="#测试用例中如何调用前置后置" class="headerlink" title="测试用例中如何调用前置后置"></a>测试用例中如何调用前置后置</h4><p>在测试用例&#x2F;类的前面<br>@pytest.mark.usefixture(“定义的fixture名称”)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># 使用了access_web函数的前置和后置</span><br><span class="hljs-variable">@pytest</span>.mark.usefixtures(<span class="hljs-string">&quot;access_web&quot;</span>)  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLogin</span>:<br><br>    <span class="hljs-comment"># 正常用例 - 登陆+首页</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_2_success</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,access_web</span>): <br>            pass<br><br></code></pre></td></tr></table></figure><h4 id="如何返回前置中的变量：yield-返回值"><a href="#如何返回前置中的变量：yield-返回值" class="headerlink" title="如何返回前置中的变量：yield + 返回值"></a>如何返回前置中的变量：yield + 返回值</h4><h4 id="测试函数接收fixture返回值的方式-fixture函数名作为参数传入"><a href="#测试函数接收fixture返回值的方式-fixture函数名作为参数传入" class="headerlink" title="测试函数接收fixture返回值的方式-fixture函数名作为参数传入"></a>测试函数接收fixture返回值的方式-fixture函数名作为参数传入</h4><p>将fixture函数名称，作为用例的参数传入即可 即 用例的参数&#x3D;fixture函数名&#x3D;yield后返回值<br>如果你要使用fixture的返回值，那一定要传参，这个时候不用@pytest.mark.usefixtures(“access_web”)申明<br>如果fixture没有返回值，要使用必须申明@pytest.mark.usefixtures(“access_web”)  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_a</span>(<span class="hljs-params">self,access_web</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">@pytest.mark.usefixtures(<span class="hljs-params"><span class="hljs-string">&quot;access_web&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_a</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="后一个fixture需要使用前一个fixture的返回值，同样把前一个fixture的函数名作为参数传入到后一个fixture中，调用后一个fixture时会自动线执行前一个fixture"><a href="#后一个fixture需要使用前一个fixture的返回值，同样把前一个fixture的函数名作为参数传入到后一个fixture中，调用后一个fixture时会自动线执行前一个fixture" class="headerlink" title="后一个fixture需要使用前一个fixture的返回值，同样把前一个fixture的函数名作为参数传入到后一个fixture中，调用后一个fixture时会自动线执行前一个fixture"></a>后一个fixture需要使用前一个fixture的返回值，同样把前一个fixture的函数名作为参数传入到后一个fixture中，调用后一个fixture时会自动线执行前一个fixture</h3><p>一个fixture只能使用比他高的&#x2F;与他同级的fixture作为它的参数</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@pytest</span>.fixture<br>def <span class="hljs-built_in">access_web</span>():<br>    # 前置 - 打开浏览器访问网址<br>    driver = webdriver.<span class="hljs-built_in">Chrome</span>()<br>    driver.<span class="hljs-built_in">get</span>(CD.web_login_url)<br>    yield driver   # 分界线+返回值<br>    # 后置 - 关闭浏览器<br>    driver.<span class="hljs-built_in">quit</span>()<br><br><span class="hljs-variable">@pytest</span>.fixture<br>def <span class="hljs-built_in">login_web</span>(access_web):<br>    # 前置-登录网址<br>    <span class="hljs-built_in">LoginPage</span>(access_web).<span class="hljs-built_in">login</span>(CD.user, CD.passwd)<br>    yield access_web<br>    logging.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;=====每一个用例后置：关闭浏览器会话========&quot;</span>)<br><br>===============执行顺序================<br>access_web的前置<br>login_web的前置<br>。。。测试用例。。。。<br>login_web的后置<br>access_web的后置<br><br></code></pre></td></tr></table></figure><p>如果测试类下所有的测试用例都使用同一个函数级别的前置后置，可以直接在类名上申明调用@pytest.mark.usefixtures(“fixture名”)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@pytest</span>.mark.usefixtures(<span class="hljs-string">&quot;access_web&quot;</span>)  <span class="hljs-comment"># 使用了access_web函数的前置和后置</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLogin</span>:<br><br><br>    <span class="hljs-comment"># 正常用例 - 登陆+首页</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_login_2_success</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,access_web</span>): <span class="hljs-comment"># fixture的函数名称=返回值</span><br>        <span class="hljs-comment"># logging.info(&quot;用例1-正常场景-登陆成功-使用到测试数据-&quot;)</span><br></code></pre></td></tr></table></figure><h4 id="autouse-True-自动调用fixture功能无需申明"><a href="#autouse-True-自动调用fixture功能无需申明" class="headerlink" title="autouse&#x3D;True 自动调用fixture功能无需申明"></a>autouse&#x3D;True 自动调用fixture功能无需申明</h4><p>平常写自动化用例会写一些前置的fixture操作，用例需要用到就直接传该函数的参数名称就行了。当用例很多的时候，每次都传这个参数，会比较麻烦。<br>fixture里面有个参数autouse，默认是Fasle没开启的，可以设置为True开启自动使用fixture功能，这样用例就不用每次都去传参了    </p><p>设置autouse&#x3D;True<br>autouse设置为True，自动调用fixture功能<br>设置scope为module级别，在当前.py用例模块前后自动执行一次<br>设置scope为function级别,每个用例前都调用一次，自动调用     </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-comment"># 申明一个模块级别的fixture</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span>,autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n----开始执行module------&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;module : %s&#x27;</span>% request.module.__name__)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;------启动浏览器-------&#x27;</span>)<br>    <span class="hljs-keyword">yield</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;------结束测试 end!----------&quot;</span>)<br><br><span class="hljs-comment"># 申明一个函数级别的fixture</span><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span>,autouse=<span class="hljs-literal">True</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">open_home</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;function:%s \n--回到首页--&quot;</span>% request.function.__name__)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_01</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----用例01-----&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_02</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----用例02-----&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;autouse.py&quot;</span>])<br><br><br>执行结果<br><br>----开始执行module------<br>module : autouse<br>------启动浏览器-------<br><br>function:test_01 --回到首页--<br>.----用例01-----<br>function:test_02 --回到首页--<br>.----用例02-----<br><br>------结束测试 end!----------<br>                                <br></code></pre></td></tr></table></figure><h3 id="pytest之xfail使用"><a href="#pytest之xfail使用" class="headerlink" title="pytest之xfail使用"></a>pytest之xfail使用</h3><p>设置xfail_strict &#x3D; true可以让那些标记为@pytest.mark.xfail但实际通过的测试用例被报告为失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_hello</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;hello World!&quot;</span>)<br><br><span class="hljs-comment">#预期会失败 结果运行失败 会被标记为xfail</span><br><span class="hljs-meta">@pytest.mark.xfail</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test1</span>():<br>    a=<span class="hljs-string">&quot;hello&quot;</span><br>    b=<span class="hljs-string">&quot;helloworld&quot;</span><br>    <span class="hljs-keyword">assert</span> a==b<br><br><span class="hljs-comment">#预期会失败 结果运行通过 会被标记为xpass</span><br><span class="hljs-meta">@pytest.mark.xfail</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>():<br>    a=<span class="hljs-string">&quot;hello&quot;</span><br>    b=<span class="hljs-string">&quot;helloworld&quot;</span><br>    <span class="hljs-keyword">assert</span> a != b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-v&quot;</span>,<span class="hljs-string">&quot;testXPass.py&quot;</span>])<br><br><br><span class="hljs-comment">#运行结果 1 passed, 1xfailed,1 xpassed in 0.27seconds</span><br></code></pre></td></tr></table></figure><p>预期会失败 结果运行失败 会被标记为xfail，预期会失败 结果运行通过 会被标记为xpass，<br>为了让两个都显示x’fail 那就加个配置 xfail_strict&#x3D;true</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">pytest.ini<br>[pytest]<br>markers=<br>     webtest:<span class="hljs-built_in">Run</span> the webtest case<br>     hello:<span class="hljs-built_in">Run</span> the hello case<br>  <span class="hljs-attribute">xfail_strict</span>=<span class="hljs-literal">true</span><br><br><br>运行结果：1 failed, 1 passed, 1 xfailed <span class="hljs-keyword">in</span> 0.16 seconds<br></code></pre></td></tr></table></figure><h3 id="pytest之使用多个fixture"><a href="#pytest之使用多个fixture" class="headerlink" title="pytest之使用多个fixture"></a>pytest之使用多个fixture</h3><p>使用多个fixture<br>如果用例需要用到多个fixture的返回数据，fixture也可以return一个元组、list或字典，然后从里面取出对应数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取用户名&quot;</span>)<br>    a =<span class="hljs-string">&quot;nuo&quot;</span><br>    b=<span class="hljs-string">&quot;123456&quot;</span><br>    <span class="hljs-keyword">return</span> (a,b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">user</span>):<br>    u=user[<span class="hljs-number">0</span>]<br>    p=user[<span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s,密码“%s&quot;</span>%(u,p))<br>    <span class="hljs-keyword">assert</span> u ==<span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtures.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="当然也可以分开定义成多个fixture，然后test-用例传多个fixture参数"><a href="#当然也可以分开定义成多个fixture，然后test-用例传多个fixture参数" class="headerlink" title="当然也可以分开定义成多个fixture，然后test_用例传多个fixture参数"></a>当然也可以分开定义成多个fixture，然后test_用例传多个fixture参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">user</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取用户名&quot;</span>)<br>    a=<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">psw</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取密码&quot;</span>)<br>    b=<span class="hljs-string">&quot;123456&quot;</span><br>    <span class="hljs-keyword">return</span> b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">user,psw</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;传多个fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s,测试密码：%s&quot;</span>%(user,psw))<br>    <span class="hljs-keyword">assert</span> user == <span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtures.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="fixture与fixture互相调用"><a href="#fixture与fixture互相调用" class="headerlink" title="fixture与fixture互相调用"></a>fixture与fixture互相调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;获取用户名&quot;</span>)<br>    a =<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">second</span>(<span class="hljs-params">first</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;pswd调用user fixture&#x27;&#x27;&#x27;</span><br>    a=first<br>    b=<span class="hljs-string">&quot;1234556&quot;</span><br>    <span class="hljs-keyword">return</span> (a,b)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">second</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s,密码：%s&quot;</span>%(second[<span class="hljs-number">0</span>],second[<span class="hljs-number">1</span>]))<br>    <span class="hljs-keyword">assert</span> second[<span class="hljs-number">0</span>]==<span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtures.py&quot;</span>])<br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;fixture的scope=session 跨.py文件调用&#x27;&#x27;&#x27;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">first</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>    <span class="hljs-keyword">assert</span> first == <span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtures.py&quot;</span>])<br></code></pre></td></tr></table></figure><h3 id="python之fixture作用范围"><a href="#python之fixture作用范围" class="headerlink" title="python之fixture作用范围"></a>python之fixture作用范围</h3><h4 id="fixture作用范围"><a href="#fixture作用范围" class="headerlink" title="fixture作用范围"></a>fixture作用范围</h4><p>fixture里面有个scope参数可以控制fixture的作用范围:session &gt; module &gt; class &gt; function  </p><ul><li>function 每一个函数或方法都会调用</li><li>class  每一个类调用一次，一个类可以有多个方法</li><li>module，每一个.py文件调用一次，该文件内又有多个function和class</li><li>session 是多个文件调用一次，可以跨.py文件调用，每个.py文件就是module</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pytest<br><br><span class="hljs-string">&#x27;scope为function级别&#x27;</span><br><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取用户名&quot;</span>)<br>    a=<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">second</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取密码&quot;</span>)<br>    b=<span class="hljs-string">&quot;123455&quot;</span><br>    <span class="hljs-keyword">return</span> b<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">first</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>    <span class="hljs-keyword">assert</span> first==<span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">second</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试密码：%s&quot;</span>%second)<br>    <span class="hljs-keyword">assert</span> second==<span class="hljs-string">&quot;123455&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtureandscope.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="fixture放到类里"><a href="#fixture放到类里" class="headerlink" title="fixture放到类里"></a>fixture放到类里</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture()</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取用户名&quot;</span>)<br>    a =<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;function&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">second</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取密码&quot;</span>)<br>    b=<span class="hljs-string">&quot;123456&quot;</span><br>    <span class="hljs-keyword">return</span> b<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">self,first</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>        <span class="hljs-keyword">assert</span> first ==<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">self,second</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试密码：%s&quot;</span>%second)<br>        <span class="hljs-keyword">assert</span> second==<span class="hljs-string">&quot;123456&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtureandscope.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="‘scope-class’"><a href="#‘scope-class’" class="headerlink" title="‘scope&#x3D;class’"></a>‘scope&#x3D;class’</h4><p>‘fixture为class级别的时候，如果一个class里面有多个用例，都调用了此fixture，那么此fixture只在该class里所有用例开始前执行一次’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;class&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取用户名，scope为class级别只运行一次&quot;</span>)<br>    a=<span class="hljs-string">&quot;nuo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">self,first</span>):<br>        <span class="hljs-string">&#x27;用例传fixture&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>        <span class="hljs-keyword">assert</span> first == <span class="hljs-string">&quot;nuo&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">self,first</span>):<br>        <span class="hljs-string">&#x27;用例传fixture&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>        <span class="hljs-keyword">assert</span> first == <span class="hljs-string">&quot;nuo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtureandscope.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="‘scope-module’"><a href="#‘scope-module’" class="headerlink" title="‘scope&#x3D;module’"></a>‘scope&#x3D;module’</h4><p>‘’’fixture为module级别时在当前.py脚本里面所有用例开始前只执行一次’’’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.fixture(<span class="hljs-params">scope=<span class="hljs-string">&quot;module&quot;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">first</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;\n获取用户名，scope为module级别当前.py模块只运行一次&quot;</span>)<br>    a = <span class="hljs-string">&quot;yoyo&quot;</span><br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_1</span>(<span class="hljs-params">first</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>    <span class="hljs-keyword">assert</span> first == <span class="hljs-string">&quot;yoyo&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCase</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_2</span>(<span class="hljs-params">self,first</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;用例传fixture&#x27;&#x27;&#x27;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试账号：%s&quot;</span>%first)<br>        <span class="hljs-keyword">assert</span> first == <span class="hljs-string">&quot;yoyo&quot;</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    pytest.main([<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;fixtureandscope.py&quot;</span>])<br></code></pre></td></tr></table></figure><h4 id="scope-session"><a href="#scope-session" class="headerlink" title="scope&#x3D;session"></a>scope&#x3D;session</h4><p>fixture为session级别是可以跨.py模块调用的,也就是当我们有多个.py文件的用例时候，如果多个用例只需调用一次fixture，那就可以设置为scope&#x3D;”session”，并且写到conftest.py文件里<br>conftest.py文件名称是固定的，pytest会自动识别该文件。放到工程的根目录下，就可以全局调用了，如果放到某个package包下，那就只在该package内有效<br>如果想同时运行test_fixture11.py和test_fixture12.py，在cmd执行<br>pytest -s test_fixture11.py test_fixture12.py</p><h3 id="pytest-mark"><a href="#pytest-mark" class="headerlink" title="pytest-mark"></a>pytest-mark</h3><p>对测试用例打标签，在运行测试用例时，可根据标签名来过滤要运行的用例</p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><ul><li>1.注册标签名</li><li>2.在测试用例&#x2F;测试类前面加上:@pytest.mark.已注册的标签名</li></ul><h4 id="注册方式"><a href="#注册方式" class="headerlink" title="注册方式"></a>注册方式</h4><ul><li>1.创建pytest.ini文件，在文件中按如下形式添加签名：<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[pytest]</span><br>markers=<br>      slow:just <span class="hljs-keyword">for</span> demo 冒号之后是可选的描述信息<br>      serial<br></code></pre></td></tr></table></figure></li><li>2.在conftest.py文件当中通过hook注册<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">pytest_configure</span>(config):<br>     config.<span class="hljs-built_in">addinivalue_line</span>(<span class="hljs-string">&quot;markers&quot;</span>,<span class="hljs-string">&quot;smoke1:标记只运行冒烟用例&quot;</span>)<br>     config.<span class="hljs-built_in">addinivalue_line</span>(<span class="hljs-string">&quot;markers&quot;</span>,<span class="hljs-string">&quot;demo1:示例运行&quot;</span>)<br></code></pre></td></tr></table></figure>在测试类里，使用以下申明（测试类下，所有用例都被打上标签）<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">class</span> TestClass(object):<br>      pytestmark=pytest.<span class="hljs-keyword">mark</span>.已注册标签名<br>      pytestmark=[pytest.<span class="hljs-keyword">mark</span>.标签1,pytest.<span class="hljs-keyword">mark</span>.标签2]   # 多标签模式<br></code></pre></td></tr></table></figure>在模块文件里，同理（py文件下，所有测试函数和测试类里的测试函数，都有该标签）<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">import pytest<br>pytestmark=pytest.mark.已注册标签名<br>pytestmark=[pytest.mark.标签1,pytest.mark.标签2]   <span class="hljs-comment"># 多标签模式</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="pytest参数化"><a href="#pytest参数化" class="headerlink" title="pytest参数化"></a>pytest参数化</h3><p>在测试用例前加上：@pytest.mark.parametrize(“参数名”，列表数据)<br>参数名：用来接收每一项数据，并作为测试用例的参数<br>列表数据：一组测试数据<br>@pytest.mark.parametrize(“参数1,参数2”，[(数据1，数据2),(数据1，数据2)])   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@pytest.mark.parametrize(<span class="hljs-params"><span class="hljs-string">&quot;a,b,c&quot;</span>,[(<span class="hljs-params"><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span></span>),(<span class="hljs-params"><span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span></span>),(<span class="hljs-params"><span class="hljs-number">14</span>,<span class="hljs-number">15</span>,<span class="hljs-number">64</span></span>)]</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add</span>(<span class="hljs-params">a,b,c</span>)<br>    res = a+b<br>    <span class="hljs-keyword">assert</span> c == res<br><br></code></pre></td></tr></table></figure><h4 id="组合参数化：多组参数-依次组合"><a href="#组合参数化：多组参数-依次组合" class="headerlink" title="组合参数化：多组参数 依次组合"></a>组合参数化：多组参数 依次组合</h4><p>使用多个@pytest.mark.parametrize</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@pytest</span>.mark.<span class="hljs-built_in">parametrize</span>(<span class="hljs-string">&quot;x&quot;</span>,[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br><span class="hljs-variable">@pytest</span>.mark.<span class="hljs-built_in">parametrize</span>(<span class="hljs-string">&quot;y&quot;</span>,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>])<br>def <span class="hljs-built_in">test_f</span>(x,y):<br>    pass<br></code></pre></td></tr></table></figure><h3 id="pytest重运行机制-rerunfailures"><a href="#pytest重运行机制-rerunfailures" class="headerlink" title="pytest重运行机制 rerunfailures"></a>pytest重运行机制 rerunfailures</h3><p>插件名称：rerunfailures<br>安装方法:pip install pytest-rerunfailures<br>重试方法：用例一旦失败了马上重运行用例<br>使用方式：  </p><ul><li>命令行参数形式 pytest –reruns 重试次数 比如pytest reruns 2 表示运行失败的用例可以重新运行2次  </li><li>pytest –reruns 重试次数 –reruns-delay 次数  表示次数之间的延时设置）单位：秒   </li><li>pytest –reruns 2 –reruns-delay 5表示失败的用例可以重运行两次 第一次和第二次间隔时间为5秒钟，失败后会立马重运行</li></ul><p><img src="/the-nuo/picture/pytest.png" alt="pytest"></p><h2 id="pytest-Allure-jenkis集成"><a href="#pytest-Allure-jenkis集成" class="headerlink" title="pytest+Allure+jenkis集成"></a>pytest+Allure+jenkis集成</h2><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><ul><li>1.命令行安装：<a href="https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/">https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/</a><br>mac系统：brew install allure  </li><li>2.解压</li><li>3.把bin配置到公共环境变量 ~&#x2F;.bash_profile</li></ul><h4 id="与pytest集成"><a href="#与pytest集成" class="headerlink" title="与pytest集成"></a>与pytest集成</h4><p>需要pytest执行用例后，生成allure能够解析的测试结果文件</p><ul><li>1.安装：pip install allure-pytest</li><li>2.使用：pytest –alluredir&#x3D;&#x2F;tmp&#x2F;my_allure_results</li><li>3.使用allure命令，生成html样式的报告  allure serve alluredir的路径</li></ul><h4 id="pytest-Allure-jenkis集成-1"><a href="#pytest-Allure-jenkis集成-1" class="headerlink" title="pytest+Allure+jenkis集成"></a>pytest+Allure+jenkis集成</h4><p><a href="https://www.cnblogs.com/Simple-Small/p/11512337.html">https://www.cnblogs.com/Simple-Small/p/11512337.html</a></p><h4 id="web自动化集成之jenkis-MS模式"><a href="#web自动化集成之jenkis-MS模式" class="headerlink" title="web自动化集成之jenkis-MS模式"></a>web自动化集成之jenkis-MS模式</h4><ul><li>1.允许master将任务分配到其他的slave机上去执行</li><li>2.1个master N个slave  master和slave不能是同一台设备</li><li>3.只有master装jenkis,slave机不需要装jenkis</li><li>4.查看master slave方法：manage jenkis - manage Nodes</li><li>5.Master:执行任务&#x2F;任务管理&#x2F;slave管理-资源 数据 配置</li><li>6.slave:执行任务&#x2F;反馈任务进展和结果&#x2F;执行能力-同事执行2个任务 任务在slave上执行，任务需要的数据&#x2F;脚本必须在slave上，slave必须具备执行任务的环境</li><li>7.slave得向master注册 每一个任务都涉及到任务的执行环境&#x2F;任务的数据 任务类别</li></ul><h4 id="怎么添加slave机："><a href="#怎么添加slave机：" class="headerlink" title="怎么添加slave机："></a>怎么添加slave机：</h4><ul><li>1.管理员身份在Master机上manage jenkis - manage Nodes-新建节点 准备一个slave信息&#x2F;位置<ul><li>1.并发构建数一般为1</li><li>2.远程工作目录：master分配的任务所有的数据包括脚本存放的目录 一定要是slave机上存在的</li><li>3.标签：对任务进行分类，方便区分 例如autotest master分配时可以根据类别选择slave机分配</li><li>4.用法：only build jobs with label expression matching this node</li><li>5.启动方式（跟master之间的报到方式）<ul><li>mac&#x2F;linux 通过SSH launch agent agents via SSH</li><li>windows Let jenkis control this window slave as a windows service启动代理。 代理启动步骤manage jenkis-configure global security-Agents选择最后一个JAVA WEB START代理协议&#x2F;4(TLS加密)</li></ul></li><li>6.可用性：尽量保持代理在线</li><li>7.保存</li></ul></li><li>2.slave主动向master发起链接-注册<ul><li>1）进入小弟机的界面点击Launch</li></ul></li></ul><p>jenkis切换国内源下载插件<br><a href="https://www.cnblogs.com/whm-blog/p/10448096.html">https://www.cnblogs.com/whm-blog/p/10448096.html</a></p>]]></content>
    
    
    <categories>
      
      <category>AutoTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>restful接口</title>
    <link href="/2023/05/17/django/restful%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/05/17/django/restful%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="restful接口"><a href="#restful接口" class="headerlink" title="restful接口"></a>restful接口</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><ul><li><p>1）restful是一种开发风格而非标准</p></li><li><p>2）Representational State Transfer，具象状态传输</p></li><li><p>3）每一个url代表一种资源：json格式数据、text文本、图片视频等</p></li><li><p>4）客户端与服务器之间，传递这种资源的某种表现形式</p></li></ul><p>​ · 通过请求头中Content-Type来指明传给服务端的参数类型</p><p>“text&#x2F;plain”、”application&#x2F;xml”、”text&#x2F;html”、”application&#x2F;json”、”image&#x2F;gif”、”image&#x2F;jpeg”、”application&#x2F;x-www-form-urlencoded”</p><p>​ · 通过请求头中Accept来指明希望接受服务端的数据类型</p><p>Accept: application&#x2F;json,application&#x2F;xml;q&#x3D;0.9,*&#x2F; *;q&#x3D;0.8</p><ul><li>5）客户端通过HTTP动词，指明对服务器端资源要进行的操作</li></ul><p></p><table><thead><tr><th>HTTP METHOD</th><th>CRUD</th></tr></thead><tbody><tr><td>POST</td><td>Create</td></tr><tr><td>GET</td><td>Search</td></tr><tr><td>PUT</td><td>Update&#x2F;Replace</td></tr><tr><td>PATCH</td><td>Partial Update&#x2F;Modify</td></tr><tr><td>DELETE</td><td>Delete</td></tr></tbody></table><h2 id="2-REST常用设计规则"><a href="#2-REST常用设计规则" class="headerlink" title="2. REST常用设计规则"></a>2. REST常用设计规则</h2><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一般使用Https协议</p><h3 id="路径命名"><a href="#路径命名" class="headerlink" title="路径命名"></a>路径命名</h3><p>​- 尽量用名词复数形式</p><p>​- 往往与数据库表明对应</p><p>​ - 如：&#x2F;getProjects、&#x2F;users、&#x2F;testcaseById?Id&#x3D;6</p><h3 id="过滤信息"><a href="#过滤信息" class="headerlink" title="过滤信息"></a>过滤信息</h3><p>若记录数量很多，服务器不可能将所有数据都返回给前端</p><ul><li><p>?limit&#x3D;10：指定返回记录的数量</p></li><li><p>?offset&#x3D;10：指定返回记录的开始位置</p></li><li><p>?page&#x3D;2&amp;size&#x3D;10：指定第几页和每页的数据条数</p></li><li><p>?sort&#x3D;name：指定返回结果按照哪个属性排序，以及排序顺序</p></li></ul><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><p>​尽量使用专用域名：<a href="http://api.er.site/">http://api.er.site</a></p><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><p>​- 在URL中呈现版本号：<a href="http://api.er.site/app/0.1/">http://api.er.site/app/0.1/</a></p><p>​- 在请求头中呈现版本号：Accept：application&#x2F;vnd.example+json;version&#x3D;1.1</p><h3 id="Http请求动词"><a href="#Http请求动词" class="headerlink" title="Http请求动词"></a>Http请求动词</h3><p>含义</p><table><thead><tr><th>GET</th><th>从服务器获取资源</th></tr></thead><tbody><tr><td>POST</td><td>服务器中新建资源</td></tr><tr><td>PUT</td><td>在服务器更新资源</td></tr><tr><td>DELETE</td><td>从服务器删除资源</td></tr><tr><td>PATCH</td><td>在服务器部分更新资源</td></tr><tr><td>HEAD</td><td>获取资源的元数据</td></tr><tr><td>OPTIONS</td><td>获取关于资源的哪些属性是客户端可以改变的信息</td></tr></tbody></table><p>例</p><table><thead><tr><th>GET　&#x2F;projects</th><th>获取所有项目信息</th></tr></thead><tbody><tr><td>POST　&#x2F;projects</td><td>创建一个新项目</td></tr><tr><td>GET　&#x2F;projects&#x2F;6</td><td>获取ID为6的项目信息</td></tr><tr><td>PUT　&#x2F;projects&#x2F;6</td><td>更新ID为6的项目信息（全更新）</td></tr><tr><td>PATCH　&#x2F;projects&#x2F;6</td><td>更新ID为6的项目信息（部分更新）</td></tr><tr><td>DELETE　&#x2F;projects&#x2F;6</td><td>删除ID为６的项目</td></tr><tr><td>GET　&#x2F;projects&#x2F;6&#x2F;interfaces</td><td>获取ID为6的项目信息中所有的接口信息</td></tr><tr><td>GET　&#x2F;projects&#x2F;6&#x2F;interfaces&#x2F;1</td><td>获取ID为6的所有项目信息中ID为1的接口信息</td></tr></tbody></table><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>200ok - [GET]：服务器返回用户请求的数据</p><p>201CREATED - [POST&#x2F;PUT&#x2F;PATCH]：用户新建或修改数据成功</p><p>204No Content - [DELETE]：用户删除数据成功</p><p>400INVAILD REQUEST - [POST&#x2F;PUT&#x2F;PATCH]：用户请求有误（请求参数有误）</p><p>401Unauthorized - [*]：表示用户没有权限</p><p>403Forbidden - [*]：表示用户得到授权，但是访问被禁止</p><p>404Not Found - [*]：用户请求的路径不存在</p><p>406用户请求的格式错误</p><p>500Internal Server Error - [*]：服务器发生错误</p><h3 id="返回结果"><a href="#返回结果" class="headerlink" title="返回结果"></a>返回结果</h3><table><thead><tr><th>GET　&#x2F;projects</th><th>返回所有项目列表（json数组</th></tr></thead><tbody><tr><td>POST　&#x2F;projects</td><td>返回新创建的项目信息（单个json</td></tr><tr><td>GET　&#x2F;projects&#x2F;6</td><td>返回单个项目信息 (单个json</td></tr><tr><td>PUT　&#x2F;projects&#x2F;6</td><td>返回更新之后，完整的项目信息（单个json</td></tr><tr><td>PATCH　&#x2F;projects&#x2F;6</td><td>返回更新之后，完整的项目信息（单个json</td></tr><tr><td>DELETE　&#x2F;projects&#x2F;6</td><td>返回空</td></tr><tr><td>GET　&#x2F;projects&#x2F;6&#x2F;interfaces&#x2F;1</td><td>返回单个接口信息（单个json</td></tr></tbody></table><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当请求有误时，需将错误信息以json格式返回</p><p>{“error”:”xxx错误”,”status_code”:401}</p><h3 id="Hypermedia-API"><a href="#Hypermedia-API" class="headerlink" title="Hypermedia API"></a>Hypermedia API</h3><p>超链接API，返回结果中提供链接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<span class="hljs-string">&quot;link&quot;</span>: &#123;<br>  <span class="hljs-string">&quot;rel&quot;</span>:   <span class="hljs-string">&quot;collection https://www.example.com/zoos&quot;</span>,<br>  <span class="hljs-string">&quot;href&quot;</span>:  <span class="hljs-string">&quot;https://api.example.com/zoos&quot;</span>,<br>  <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;List of zoos&quot;</span>,<br>  <span class="hljs-string">&quot;type&quot;</span>:  <span class="hljs-string">&quot;application/vnd.yourformat+json&quot;</span><br>&#125;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django基础</title>
    <link href="/2023/05/17/django/django%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/17/django/django%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Django基础"><a href="#Django基础" class="headerlink" title="Django基础"></a>Django基础</h1><h2 id="django基础知识树"><a href="#django基础知识树" class="headerlink" title="django基础知识树"></a>django基础知识树</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-01_15-50-38.png"></p><iframe id="embed_dom" name="embed_dom" frameborder="0" style="display:block;width:525px; height:245px;" src="https://www.processon.com/embed/5ee8c8dcf346fb1ae5676195"></iframe><h2 id="一：创建django项目"><a href="#一：创建django项目" class="headerlink" title="一：创建django项目"></a>一：创建django项目</h2><ul><li><p>1.创建项目虚拟环境（使用pycharm创建）打开pycharm,点击File&#x3D;&gt;new Project &#x3D;&gt;Django</p></li><li><p>2.安装Django<br> pip install -i <a href="https://pypi.douban/simple">https://pypi.douban/simple</a> django</p></li><li><p>3.创建项目工程目录</p><ul><li>a.专业版本 在创建时选择Django 选项</li><li>b.社区版本 Django-admin startproject 项目名 .</li><li>c.项目名建议和工程目录同名</li><li>d.“.”:代表在当前工程目录下创建，把项目名所在目录作为根目录</li></ul></li><li><p>4.运行项目</p><ul><li>a.python3.7 manage.py runserver    运行项目默认8080端口  </li><li>或者Tools-run manage.py task进入manage.py运行环境 直接输入 runserver启动项目</li><li>b.python3.7 manage.py runserver 127.0.0.1：8888    修改运行的端口 ip:端口号（端口号要大于1024）</li><li>c.可以创建运行器，在右上角 使用add configure来添加</li></ul></li></ul><h4 id="2-配置初始配置"><a href="#2-配置初始配置" class="headerlink" title="2: 配置初始配置"></a>2: 配置初始配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">*指定简体中文*<br>mydev/settins.py LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span> 改为中文<br>*指定时区*<br>mydev/settins.py TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span> 修改时区<br></code></pre></td></tr></table></figure><h2 id="二-django工程目录结构"><a href="#二-django工程目录结构" class="headerlink" title="二: django工程目录结构"></a>二: django工程目录结构</h2><ul><li>mydev               项目同名的目录 主要存放相关配置信息</li><li>mydev&#x2F;<strong>init</strong>.py   当前mydev为一个包</li><li>mydev&#x2F;asgi.py       主要用于存放ASGI异步请求的入口配置信息</li><li>mydev&#x2F;settings.py   存放的是项目全局配置信息</li><li>mydev&#x2F;urls.py       主要存放项目的路由信息</li><li>mydev&#x2F;wsgi.py       主要用于存放WSGI协议服务的入口配置信息（一般在部署的时候使用）</li><li>db.sqlite3:         默认的关系型文本数据库</li><li>manage.py：         为命令行管理工具，用于开发阶段的项目的启动 管理数据迁移 静态文件收集等等</li></ul><h2 id="三-定制一个页面"><a href="#三-定制一个页面" class="headerlink" title="三: 定制一个页面"></a>三: 定制一个页面</h2><ul><li><p>1.子应用的作用<br>  · 实现业务功能模块的复用</p><p> ​ · 将工程项目拆分为不同的子功能模块，以子应用的形式存在</p><p> ​ · 各功能模块之间可以保持相对的独立</p></li></ul><p>​    · 实现路由的分发，便于管理各模块的url，减少代码维护成本</p><ul><li><p>2.创建子应用</p><ul><li>a.python manage.py startapp projects（子应用名）   推荐子应用名小写复数形式，不要用中文</li><li>b.Tools &#x3D;&gt; run manage.py task     输入命令 startapp projects</li><li>c.projects&#x2F;migrations:     存放数据库迁移脚本和迁移历史记录等信息、</li><li>d.projects&#x2F;admin.py:       admin后台站点的相关配置（需要后台站点时才会用到）</li><li>f.projects&#x2F;apps.py:        为app_label的相关配置，很少使用</li><li>g.projects&#x2F;models.py:      存放数据库模型相关信息</li><li>h.projects&#x2F;tests.py:       对当前子应用进行自测，写单元测试</li><li>i.projects&#x2F;views.py:       定义业务逻辑（向前端返回的页面）</li></ul></li><li><p>3.在全局配置文件 mydev&#x2F;settings.py的INSTALLED_APPS中，对子应用进行注册 </p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">子应用名<span class="hljs-selector-class">.apps</span>.子应用名首字母大小Config<br><span class="hljs-string">&#x27;projects.apps.ProjectsConfig&#x27;</span><br>或者直接应用名 <span class="hljs-string">&#x27;projects&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>4.创建视图函数</p><ul><li>在projects&#x2F;views.py下创建视图函数</li></ul></li><li><p>5.在全局路由表中添加路由信息</p></li></ul><h2 id="四-路由"><a href="#四-路由" class="headerlink" title="四: 路由"></a>四: 路由</h2><p>前端访问url获取页面 –&gt; 后端调用指定函数func(a, b, …)</p><ul><li><p>1.定义<br>  路由表：url与后端视图函数的一个一一映射关系表<br>  路由系统的本质就是URL与要调用URL的视图函数的一个映射表，它的主要作用就是让views里面的执行函数与与请求的url建立映射关系，当请求来了的时候根据这个url映射来调用对应的执行函数，从而返回给客户端相应的信息</p></li><li><p>2.全局路由<br>  全局路由的作用：所有的路由在寻址时都会先从主路由开始找 因此即便在子路由中定义了，也需要在主路由中注册一下 path(‘page&#x2F;‘, include(‘projects.urls’))<br>  子路由的作用：可以定义每个项目中自己的路由</p></li><li><p><strong>3.路由匹配规则</strong></p><ul><li>a 从列表的第一个元素开始（从上到下）开始匹配</li><li>b 一但调用成功 会自动调用path第二个函数所指定的视图函数</li><li>c 一但匹配成功，不会再往下匹配</li><li>d 如果匹配不成功，会返回一个状态码为404的页面</li><li>e url路由信息推荐使用&#x2F;结尾</li><li>f.可以再子应用中定义子路由，子应用名&#x2F;urls.py中定义</li><li>g.可以使用include函数来加载子路由，第一个参数为字符串 第二个参数为（’子应用名.urls’）  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">**总路由**<br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-type">path</span>, <span class="hljs-keyword">include</span><br><br>urlpatterns = [<br>path(<span class="hljs-string">&#x27;admin/&#x27;</span>, <span class="hljs-keyword">admin</span>.site.urls),<br>path(<span class="hljs-string">&#x27;page/&#x27;</span>, <span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;projects.urls&#x27;</span>))<br>]<br><br>**子路由**<br>urlpatterns = [<br>*函数视图路由*<br>path(<span class="hljs-string">&#x27;index/&#x27;</span>, index_page),<br><br>*类视图定义路由*<br>a. <span class="hljs-type">path</span>函数的第二个参数为类视图名.as_view()<br>path(<span class="hljs-string">&#x27;index3/&#x27;</span>, Index_page.as_view())]<br></code></pre></td></tr></table></figure></li><li>6.所有路由在寻址时都会先从主路由开始找，如果url第一部分匹配成功 那么会将url剩下的部分拿到子路由中匹配。</li></ul><p>         </p></li><li><p>4.路由分发<br>​    在子路由中，将url和需要调用的视图函数之间进行映射，全局路由对各个应用进行绑定，利用include加载子路由，从而实现路由的分发，便于根据不同的应用来管理各自的url,减少代码维护成本</p></li></ul><h2 id="五-视图"><a href="#五-视图" class="headerlink" title="五:视图"></a>五:视图</h2><h4 id="1-函数视图"><a href="#1-函数视图" class="headerlink" title="1. 函数视图"></a>1. 函数视图</h4><ul><li>1.第一个参数为HttpRequest对象或者HttpRequest子类对象，无需手动传递</li><li>2.一般会使用request</li><li>3.一定要返回HttpResponse对象或者HttpResponse子类对象  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">index01_page</span>(<span class="hljs-params">request</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">HttpResponse</span>(<span class="hljs-string">&#x27;&lt;h2&gt;Hello World&lt;/h2&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-类视图"><a href="#2-类视图" class="headerlink" title="2.类视图"></a>2.类视图</h4><ul><li>1.一定要继承View父类 或者View的子类</li><li>2.可以定义get post put delete 方法 来实现get请求 post请求 put请求 delete请求</li><li>3.get post put delete方法名称固定，且均为小写</li><li>4.实例方法的第二个参数为HttpRequest对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Index_page</span>(<span class="hljs-title class_ inherited__">View</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, request</span>):<br><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        1.url后面的？号参数 称为query string查询字符串参数 ？参数名1=参数值1&amp;参数名2=参数值2</span><br><span class="hljs-string">        2.request.GET获取查询字符串参数</span><br><span class="hljs-string">        3.request.GET返回QueryDict对象 类似于一个字典 支持字典中的所有操作 </span><br><span class="hljs-string">        4.request.GET[KEY],request.GET.get(key),request.GET.getlist（）去获取值 request.GET.getlist（）可以获取相同key的多个参数值合成一个list</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param request:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;&lt;h1&gt;get方法呀&lt;/h1&gt;&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">self, request</span>):.....<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        可以使用request.POST方法，获取application/x-www-urlencoded类型的参数</span><br><span class="hljs-string">        可以使用request.body方法，获取application/json类型的参数</span><br><span class="hljs-string">        可以使用request.META方法，获取请求头参数，key为HTTP_请求头key的大写</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param request:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        data_dict = json.loads(request.body, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">f&#x27;&lt;h2&gt;post请求<span class="hljs-subst">&#123;data_dict[<span class="hljs-string">&quot;name&quot;</span>]&#125;</span>&lt;/h2&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="六：请求与响应"><a href="#六：请求与响应" class="headerlink" title="六：请求与响应"></a>六：请求与响应</h2><h3 id="1-请求参数类型"><a href="#1-请求参数类型" class="headerlink" title="1. 请求参数类型"></a>1. 请求参数类型</h3><p>利用HTTP协议向服务器传参的几种途径</p><p>1）查询字符串传参</p><p>​ 如：ip:port&#x2F;index&#x2F;?name&#x3D;ergui&amp;age&#x3D;18 ​ url后面的?参数，可以使用request.GET获取，返回QueryDict对象，可通过request.GET[key]、request.GET.get(key)、request.GET.getlist()获取参数值</p><p>2）请求体参数</p><p>​ <strong>form表单传参</strong></p><p>​ 使用request.POST方法，获取application&#x2F;x-www-form-urlencoded类型的参数</p><p>​ <strong>json格式参数</strong></p><p>​ 使用request.body方法，获取application&#x2F;json类型的参数</p><p>​ <strong>上传文件</strong></p><p>​ 使用request.body方法，获取到文件的二进制格式数据,新建一个文件写入</p><p>3）路径参数</p><p>​ 如：ip:port&#x2F;index&#x2F;10&#x2F;</p><p>​ 把参数伪装成路径，传递到后端</p><p>​ 在路由中配置路径：&lt; url类型转换器:路径参数名 &gt; int path uuid slug；请求函数中配置请求参数：def post(self, request, pk)</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lisp">path(&#x27;index04/&lt;int<span class="hljs-symbol">:pk&gt;/&lt;username&gt;/</span>&#x27;, views.IndexPage.as_view())<br></code></pre></td></tr></table></figure><h3 id="2-响应"><a href="#2-响应" class="headerlink" title="2. 响应"></a>2. 响应</h3><p>视图中必须返回HTTPResponse对象或子对象</p><p>HttpResponse(content&#x3D;响应体, content_type&#x3D;响应体数据类型, status&#x3D;状态码)<br>HttpResponse对象 第一个参数为字符串或者字节类型 会将字符串内容返回到前端<br>jsonResponse</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IndexPage</span>(View):<br>    def <span class="hljs-keyword">get</span>(self, request):<br>        <span class="hljs-keyword">data</span> = [<br>            &#123;<br>                <span class="hljs-string">&#x27;project_name&#x27;</span>: <span class="hljs-string">&#x27;王者项目&#x27;</span>,<br>                <span class="hljs-string">&#x27;leader&#x27;</span>: <span class="hljs-string">&#x27;ergui&#x27;</span>,<br>                <span class="hljs-string">&#x27;app_name&#x27;</span>: <span class="hljs-string">&#x27;王者农药&#x27;</span><br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&#x27;project_name&#x27;</span>: <span class="hljs-string">&#x27;活到最后项目&#x27;</span>,<br>                <span class="hljs-string">&#x27;leader&#x27;</span>: <span class="hljs-string">&#x27;star&#x27;</span>,<br>                <span class="hljs-string">&#x27;app_name&#x27;</span>: <span class="hljs-string">&#x27;吃鸡&#x27;</span><br>            &#125;<br>        ]<br>        <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-keyword">data</span>, content_type=<span class="hljs-string">&quot;application/json&quot;</span>, status=<span class="hljs-number">201</span>)<br>        <br>        # render()主要用于渲染模板，生成一个html页面，第一个参数为request，第二个参数为在templates目录下的模板名，第三个参数为context，只能传字典<br>        # <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;demo.html&#x27;</span>)<br>        # locals()，获取当前命名空间中的所有变量值，存放在一个字典中<br>        # <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;demo.html&#x27;</span>, locals())<br>        <br>        # JsonResponse是HttpResponse的子类，第一个参数为字典或者嵌套字典的列表，如果使用非字典格式，需设置safe为False<br>        <span class="hljs-keyword">return</span> JsonResponse(<span class="hljs-keyword">data</span>, safe=False)<br></code></pre></td></tr></table></figure><h2 id="七：MVT模式和两种开发模式"><a href="#七：MVT模式和两种开发模式" class="headerlink" title="七：MVT模式和两种开发模式"></a>七：MVT模式和两种开发模式</h2><p>1.MVT</p><p>M：Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理</p><p>V：View，与MVC中的C功能相同，接收请求，进行业务处理，返回响应</p><p>T：Template，与MVC中的V功能相同，负责构造要返回的html页面</p><ol><li>两种开发模型</li></ol><p>1）前后不分离</p><p>​ 前端数据的展示由后端来控制，后端渲染或重定向页面 ​ 耦合严重 ​ 返回的为html页面，实用性差，拓展性差，只能用于浏览器，与其他终端不适配</p><p>​</p><p>2）前后分离</p><p>​ 前后端独立，后端只需对数据进行处理，向前端提供数据，由前端负责页面的展示 ​ 解耦合 ​ 前后端可同时进行开发，缩小业务上线周期 ​ 大部分情况下，前端发送json格式参数，后端同样以json格式数据返回 ​ 扩展性、适应性好，可多终端运行同一套接口，如PC、APP、小程序等</p>]]></content>
    
    
    <categories>
      
      <category>django</category>
      
    </categories>
    
    
    <tags>
      
      <tag>django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>httprunner</title>
    <link href="/2023/04/17/AutoTest/httprunner/"/>
    <url>/2023/04/17/AutoTest/httprunner/</url>
    
    <content type="html"><![CDATA[<h1 id="httprunner"><a href="#httprunner" class="headerlink" title="httprunner"></a>httprunner</h1><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>面向https 协议的通用开源测试框架，支持三种格式用例 YAML JSON PYTEST,不支持 websocket dubbo.<br>httprunner可以直接写pytest风格的测试用例</p><p><img src="/the-nuo/picture/httprunner3.png"> </p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>pip install httprunner</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>hrun –startproject (项目名）</p><h4 id="执行用例"><a href="#执行用例" class="headerlink" title="执行用例"></a>执行用例</h4><p>在terminal控制台下执行 hrun yaml  配置文件（json配置文件）的相对路径或绝对路径</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>1.接口自动化测试（unittest等）</li><li>2.接口进行压测（locust等）</li><li>3.持续继承</li><li>4.日志器</li><li>5.轻轻松松进行接口测试平台化</li><li>6.UI自动化测试（较弱）</li></ul><h2 id="HttpRunner-2-x工程目录结构"><a href="#HttpRunner-2-x工程目录结构" class="headerlink" title="HttpRunner 2.x工程目录结构"></a>HttpRunner 2.x工程目录结构</h2><ul><li>1.api目录<ul><li>主要存放接口的最小执行单元（正向用例）</li></ul></li><li>2.reports目录<ul><li>主要存放测试报告</li></ul></li><li>3.testcases目录<ul><li>接口复杂的执行逻辑（处理接口依赖）</li></ul></li><li>4.testsuites目录<ul><li>批量执行测试（参数化处理）</li></ul></li><li>5.env目录<ul><li>存放全局环境变量 比如管理员账号密码</li></ul></li></ul><ol start="6"><li>debugtalk文件<ul><li>主要用于处理动态参数（接口参数的动态化，测试数据的动态化）</li></ul></li></ol><h2 id="yaml文件用例编写规则"><a href="#yaml文件用例编写规则" class="headerlink" title="yaml文件用例编写规则"></a>yaml文件用例编写规则</h2><ul><li>a.yaml配置文件（json文件类似），主要用于实现测试数据存储或者测试的执行逻辑</li><li>b.强缩进的格式，默认缩进4个空格</li><li>c.冒号前面为key,冒号后面为value，如key: value</li><li>d.缩进一致的且没有’-‘，往往为嵌套的字典，如果有’-‘,那么为列表</li><li>e.yaml中所有的key不可以加引号，value如果加单引号或者双引号，那么一定为字符串类型</li><li>f.如果值为数字或小数，那么为int或float类型，如果值中有字母符号，那么一定为字符串类型</li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># name固定 指定当前接口名称</span><br><br><span class="hljs-params">name:</span> 项目的列表信息接口<br><br><span class="hljs-params">base_url:</span> http:<span class="hljs-operator">//</span>api.keyou.site:<span class="hljs-number">8000</span><br><br><span class="hljs-comment"># 指定当前用例需要用到的变量</span><br><br><span class="hljs-params">variables:</span><br><br>    <span class="hljs-comment"># 定义两个变量 变量名可以随便定义</span><br>    <span class="hljs-comment"># 变量名：变量值</span><br>    <span class="hljs-comment"># 定义变量后可以在定义语句的下方任意地方调用 使用$变量名</span><br><br>    <span class="hljs-params">uname:</span> <span class="hljs-string">&quot;lemon3333&quot;</span><br>    <span class="hljs-params">passwd:</span> <span class="hljs-string">&quot;123456&quot;</span><br>    <span class="hljs-params">token:</span> <span class="hljs-string">&quot;$token&quot;</span><br><br><span class="hljs-comment"># 指定接口的请求信息</span><br><br><span class="hljs-params">request:</span><br>    <span class="hljs-comment"># 指定请求的url路径</span><br>    <span class="hljs-params">url:</span> <span class="hljs-operator">/</span>projects<span class="hljs-symbol">/</span><br><br>    <span class="hljs-comment"># 指定请求方式 大写小写都可以 get post put</span><br>    <span class="hljs-params">method:</span> GET<br><br>    <span class="hljs-comment"># 指定请求头信息</span><br>    <span class="hljs-params">headers:</span><br>        <span class="hljs-params">User-Agent:</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;get_random_user_agent()&#125;</span>&quot;</span><br>        <span class="hljs-params">Authorization:</span> <span class="hljs-string">&quot;JWT $token&quot;</span><br>    <br>    <span class="hljs-comment"># json区域来指定json格式请求参数</span><br>    <span class="hljs-comment"># data区域来指定form表单请求参数</span><br>    <span class="hljs-comment"># params区域来指定查询字符串参数</span><br>    <span class="hljs-comment"># files指定文件请求参数</span><br>    <span class="hljs-comment"># 可以查看request库传参 一模一样</span><br>    <span class="hljs-params">params:</span><br>        <span class="hljs-params">page:</span> <span class="hljs-number">1</span><br>        <span class="hljs-params">size:</span> <span class="hljs-number">3</span><br><br><br><span class="hljs-comment"># 指定断言方式</span><br><span class="hljs-params">validate:</span><br><br>      <span class="hljs-comment"># eq指定做相等断言 [实际值,期望值]</span><br>      <span class="hljs-comment"># 默认能使用的属性有：status_code, cookies, elapsed, headers, content, text, json, encoding, ok, reason, url</span><br>      <span class="hljs-comment"># headers为响应头、content 字节,text 字符串, json 都为响应体数据（如果响应数据为json格式的话，那么会自动转化为字典）</span><br>      <span class="hljs-comment"># 字典获取值：content或text或json.字典key</span><br>      <span class="hljs-comment"># 列表获取值：content或text或json.数字索引值.字典key  content.0.username</span><br><br>     <span class="hljs-operator">-</span> <span class="hljs-params">eq:</span> [<span class="hljs-string">&quot;status_code&quot;</span>, <span class="hljs-number">200</span>]<br>     <span class="hljs-operator">-</span> <span class="hljs-params">eq:</span> [<span class="hljs-string">&quot;content.username&quot;</span>, <span class="hljs-string">&quot;keyou1&quot;</span>]<br>     <span class="hljs-operator">-</span> <span class="hljs-params">contains:</span> [<span class="hljs-string">&quot;content.username&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>]<br>     <span class="hljs-operator">-</span> &#123;<span class="hljs-string">&quot;check&quot;</span>: <span class="hljs-string">&quot;status_code&quot;</span>, <span class="hljs-string">&quot;comparator&quot;</span>: <span class="hljs-string">&quot;eq&quot;</span>, <span class="hljs-string">&quot;expect&quot;</span>: <span class="hljs-number">200</span>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="env文件下定义全局环境变量，可以在任何地方调用"><a href="#env文件下定义全局环境变量，可以在任何地方调用" class="headerlink" title=".env文件下定义全局环境变量，可以在任何地方调用"></a>.env文件下定义全局环境变量，可以在任何地方调用</h3><p>语法：${ENV(环境变量名)}</p><p>调用：${ENV(USERNAME)}</p><p>.env文件：<br>USERNAME&#x3D;lemon1<br>PASSWORD&#x3D;123456</p><h3 id="动态变化的参数"><a href="#动态变化的参数" class="headerlink" title="动态变化的参数"></a>动态变化的参数</h3><p>语法： ${方法名()}</p><p>调用： ${get_random_topic_name()}</p><p>debugtalk文件下定义函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">def <span class="hljs-title">get_random_topic_name</span>():</span><br><span class="hljs-function">    </span><br><span class="hljs-function">    H</span> = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;</span><br><br>    topic_name = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-number">5</span></span>):</span><br><span class="hljs-function">        topic_name +</span>= random.choice(H)<br><br>    <span class="hljs-keyword">return</span> topic_name<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AutoTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP自动化</title>
    <link href="/2023/03/17/AutoTest/APP%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2023/03/17/AutoTest/APP%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="APP自动化"><a href="#APP自动化" class="headerlink" title="APP自动化"></a>APP自动化</h1><h2 id="Appium工作原理"><a href="#Appium工作原理" class="headerlink" title="Appium工作原理"></a>Appium工作原理</h2><p><img src="/the-nuo/picture/Snipaste_2021-05-28_20-21-57.png">  </p><ul><li>Appium的核心其实就是一个暴露了一系列REST API的server  </li><li>这个server的功能很简单：监听一个端口（4723），接收由客户端发送过来的命令command,翻译这些command</li><li>把这些command转换成移动设备可以理解的形式发送给移动设备,调用设备上内置的自动化框架api去执行操作</li><li>移动设备执行完这些command后把执行结果返回给appium server,最后Appium server再把执行后的结果返回给client客户端<br><img src="/the-nuo/picture/Snipaste_2021-05-28_20-22-10.png"></li></ul><p>手机端运行原理如下：  </p><ul><li>1.appium使用adb向手机&#x2F;模拟器部署Bootstrap.jar</li><li>2.Bootstrap.jar接收appium发过来的指令</li><li>3.Bootstrap.jar再次将命令发给uiautomator</li><li>4.uiautomator再次执行命令</li></ul><h4 id="移动端自带的自动化框架"><a href="#移动端自带的自动化框架" class="headerlink" title="移动端自带的自动化框架"></a>移动端自带的自动化框架</h4><p>ios9.3及以上：苹果的XCUITest<br>ios9.3及以下：苹果的UIAutomation<br>Android4.2+: 谷歌的UiAutomator  UiAutomator<br>Android2.3+: 谷歌的lnstrumentation</p><h2 id="Appium安装五大件"><a href="#Appium安装五大件" class="headerlink" title="Appium安装五大件"></a>Appium安装五大件</h2><ul><li>1.appium desktop <a href="http://appium.io/">http://appium.io</a></li><li>2.appium-python库 pip install Appium-Python-Client</li><li>3.ADT工具包 安装AndroidStudio版本然后配置环境变量<br>参考此篇文章 <a href="https://blog.csdn.net/legolas_gd/article/details/106569571">https://blog.csdn.net/legolas_gd/article/details/106569571</a></li><li>4.模拟器&#x2F;真机 真机需要在开发者选项中开启USB调试模式</li><li>5.JDK 安装JDK1.8，配置环境变量</li></ul><h2 id="app元素定位三个工具"><a href="#app元素定位三个工具" class="headerlink" title="app元素定位三个工具"></a>app元素定位三个工具</h2><p>元素定位出错后我们首先要检查：</p><ul><li>1.adb能识别到设备吗</li><li>2.定位时设备有被其他程序占用吗（即便是appium server在占用也不可以，必须等appium server停止运行才可以定位到)</li><li>3.ADT的版本正确吗</li></ul><h4 id="每一种工具正确定位的前提："><a href="#每一种工具正确定位的前提：" class="headerlink" title="每一种工具正确定位的前提："></a>每一种工具正确定位的前提：</h4><ul><li><p>1、通过 adb devices命令能够识别到至少一个android设备；</p></li><li><p>2、设备当前没有被任何其它的应用程序所占用；</p></li></ul><h3 id="第一种：android-ADT自带工具：uiAutormatorViewer"><a href="#第一种：android-ADT自带工具：uiAutormatorViewer" class="headerlink" title="第一种：android ADT自带工具：uiAutormatorViewer"></a>第一种：android ADT自带工具：uiAutormatorViewer</h3><p>android 4.2以上的版本，自带的自动化测试框架是uiAutomator。<br>uiAutomatorViewer就是它的元素定位工具了</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>不支持jdk1.8以上的版本。所以为了启动成功，要安装jdk1.8的版本。</p><p>mac下若安装了jdk11和jdk1.8，需要编辑uiautomatorviewer文件，找到javaCmd&#x3D;”java”,</p><p>修改为 javaCmd&#x3D;”&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_231.jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java”</p><p>&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_231.jdk&#x2F;Contents&#x2F;Home&#x2F;bin&#x2F;java为jdk1.8版本对应的java.) </p><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><p>uiAutomatorViewer是安卓调试工具(ADT)中的一部分。所以只需要安装ADT就可以了(不需要安装SDK哦)。</p><ul><li><ol><li>安装Android Studio</li></ol></li><li><p>2）在Android Studio的启动页面当中，选择右下角的Configure -&gt; SDK Manager</p></li></ul><p>会弹出下图：选择Android SDK -&gt; SDK Tools ，按图中勾选，点击OK进入安装,安装完成即可关闭Android Studio。 记住图中Android SDK Location对应<br><img src="/the-nuo/picture/Snipaste_2021-05-25_18-38-39.png">  </p><h4 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h4><p>1、找到ADT安装目录，在其tools&#x2F;bin目录下，找到uiAutomatorViewer程序，双击打开。</p><p>例如：ADT的目录为：&#x2F;Users&#x2F;liyuan&#x2F;Library&#x2F;Android&#x2F;sdk&#x2F;tools&#x2F;bin<br><img src="/the-nuo/picture/Snipaste_2021-05-25_18-36-25.png"></p><ol start="2"><li>定位元素<br><img src="/the-nuo/picture/Snipaste_2021-05-25_19-09-22.png"></li></ol><h3 id="第二种：appium的appium-inspector"><a href="#第二种：appium的appium-inspector" class="headerlink" title="第二种：appium的appium inspector"></a>第二种：appium的appium inspector</h3><p>appium是目前最流行的开源的app功能测试框架。</p><p>同时支持IOS和Android的自动化测试，也支持多语言(python&#x2F;java&#x2F;C#……)</p><h4 id="安装：-1"><a href="#安装：-1" class="headerlink" title="安装："></a>安装：</h4><p>只要安装appium，那么appium inspector也就有了。</p><p>appium desktop下载地址：<a href="http://appium.io/">http://appium.io/</a></p><h4 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h4><ol><li>启动appium desktop之后，点击右上角的第一个按钮</li></ol><p><img src="/the-nuo/picture/Snipaste_2021-05-25_19-11-47.png">  </p><p>2)在打开如下界面当中，按图中所示，填写信息  </p><p><img src="/the-nuo/picture/Snipaste_2021-05-25_19-19-48.png">   </p><p>3)会根据启动参数，去打开对应的app,然后会截取app当中的页面</p><p><img src="/the-nuo/picture/Snipaste_2021-05-25_19-40-09.png"></p><h3 id="第三种：python版uiAutomator2中的weditor"><a href="#第三种：python版uiAutomator2中的weditor" class="headerlink" title="第三种：python版uiAutomator2中的weditor"></a>第三种：python版uiAutomator2中的weditor</h3><p>python语言实现的一个app自动化测试框架。</p><h4 id="安装：-2"><a href="#安装：-2" class="headerlink" title="安装："></a>安装：</h4><p>安装uiAutomator2：pip install -U uiautomator2</p><p>初始化命令(往手机上推送apk包)：python -m uiautomator2 init</p><p>安装定位工具weditor： pip install -U weditor</p><p>安装完成之后：命令行运行：weditor –help确认是否安装成功。</p><h4 id="使用：-2"><a href="#使用：-2" class="headerlink" title="使用："></a>使用：</h4><ol><li>命令行输入：python -m weditor 会自动打开在浏览器当中打开一个页面 </li><li>选择Android，输入设备序列号，点击connect。点击Dump Hierarchy，就可以看到元素的信息了。<br>3)如果xpath定位使用了sourceid代表sourceid是唯一的可以直接用find_element_by_id</li></ol><p><img src="/the-nuo/picture/Snipaste_2021-05-25_20-05-02.png"></p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>以上3种定位告诉你： 任何一个app自动化测试的框架，都会给你提供一个对应的定位工具哦！</p><p>android自带的UiAutomator测试框架，提供 uiAutomatorViewer。</p><p>appium测试框架，提供appium inspector.</p><p>python实现的uiAutomator2测试框架，提供weditor</p><p>在app自动化测试的过程中，可以使用任意一种或多种来帮你进行元素定位。<br>推荐使用第三种</p><h2 id="元素六大定位方式"><a href="#元素六大定位方式" class="headerlink" title="元素六大定位方式"></a>元素六大定位方式</h2><p><img src="/the-nuo/picture/Snipaste_2021-05-26_15-36-07.png"> </p><h2 id="元素九大操作"><a href="#元素九大操作" class="headerlink" title="元素九大操作"></a>元素九大操作</h2><h3 id="1-模拟滑屏上拉下拉操作-TouchAction-swipe"><a href="#1-模拟滑屏上拉下拉操作-TouchAction-swipe" class="headerlink" title="1.模拟滑屏上拉下拉操作 TouchAction swipe"></a>1.模拟滑屏上拉下拉操作 TouchAction swipe</h3><p>1.元素行为   </p><pre><code class="hljs">  tap屏幕点击 press 按住屏幕 long_press 长按 release 释放 move_to 从一个点移动到另一个店 wait等待</code></pre><p>2.元素操作 perform()  </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> appium.webdriver.common.touch_action <span class="hljs-keyword">import</span> TouchAction<br><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><br># <span class="hljs-number">1.</span>准备参数：告诉appium，你要打开哪个设备上的哪个app。<br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:<span class="hljs-literal">True</span><br>&#125;<br><br># <span class="hljs-number">2.</span>、连接appium server，把启动参数发送<br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br># <span class="hljs-number">3.</span>元素定位 使用ID定位方式<br>loc = (MobileBy.ID,<span class="hljs-string">&#x27;com.lemon.lemonban:id/navigation_tiku&#x27;</span>)<br># <span class="hljs-number">4.</span>等待 - <span class="hljs-number">3</span>大等待方式<br>WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.visibility_of_element_located(loc))<br># <span class="hljs-number">5.</span>点击进入题库界面<br>driver.find_element(*loc).click()  <br># 等待所有题库都出来了，再滑动<br>time.sleep(<span class="hljs-number">6</span>)<br><br><br># <span class="hljs-number">1.</span>获取整屏的大小 size返回一个字典&#123;width,height&#125;<br>size = driver.get_window_size()<br><br># <span class="hljs-number">2.</span>按压屏幕从一个点移动到另一个点<br>driver.swipe(size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.9</span>,size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.3</span>,<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><h4 id="自己实现swipe滑屏操作"><a href="#自己实现swipe滑屏操作" class="headerlink" title="自己实现swipe滑屏操作"></a>自己实现swipe滑屏操作</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 2.实例化TouchAction类</span><br>tc = TouchAction(driver)<br><br><span class="hljs-comment"># 3.按压屏幕上一个点移动到另一个点后释放。</span><br>    注意：move_to和release之间不要添加等待 <br>         width<span class="hljs-number">*50</span>代表中间 height<span class="hljs-number">*0</span>.9 整个屏幕高度90%部分移动到这个屏幕高度30%部分<br>tc.press(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.5,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.9).wait(200).\<br>   move_to(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.5,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.3).\<br>   release()<br><br>tc.perform()<br><br></code></pre></td></tr></table></figure><h3 id="2-页面滑动多次寻找某个页面的某一个元素点击-swipe"><a href="#2-页面滑动多次寻找某个页面的某一个元素点击-swipe" class="headerlink" title="2.页面滑动多次寻找某个页面的某一个元素点击 swipe"></a>2.页面滑动多次寻找某个页面的某一个元素点击 swipe</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> appium.webdriver.common.touch_action <span class="hljs-keyword">import</span> TouchAction<br><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 1.准备参数：告诉appium，你要打开哪个设备上的哪个app。</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:<span class="hljs-literal">True</span><br>&#125;<br><br><span class="hljs-comment"># 2.、连接appium server，把启动参数发送</span><br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br><span class="hljs-comment"># 3.元素定位</span><br>loc = (MobileBy.ID,<span class="hljs-string">&#x27;com.lemon.lemonban:id/navigation_tiku&#x27;</span>)<br><span class="hljs-comment"># 4.等待 - 3大等待方式</span><br>WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.visibility_of_element_located(loc))<br><span class="hljs-comment"># 5.点击 进入题库界面</span><br>driver.find_element(*loc).click() <br><span class="hljs-comment"># 6.等待所有题库都出来了，再滑动</span><br>time.sleep(<span class="hljs-number">3</span>)<br><br><br><span class="hljs-comment"># 1、获取整屏的大小</span><br>size = driver.get_window_size()<br><br><span class="hljs-comment"># 循环/滑动</span><br><span class="hljs-comment"># 什么时候滑？滑几次？滑到什么时候终止？滑到底部了如何不再滑动？</span><br><span class="hljs-comment"># 滑动以前的内容  != 滑动以后的内容 =&gt; 继续滑</span><br><span class="hljs-comment"># 滑动以前的内容  == 滑动以后的内容 =&gt; 已经到底部</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"># 滑动以前的内容</span><br><span class="hljs-string">old = None</span><br><span class="hljs-string"># 滑动后的内容</span><br><span class="hljs-string">new = driver.page_source</span><br><span class="hljs-string">while 滑动以前的内容  != 滑动以后的内容:</span><br><span class="hljs-string">    如果元素找着了(driver.find_element()/page_source.find())：</span><br><span class="hljs-string">        break</span><br><span class="hljs-string">    如果没找着：</span><br><span class="hljs-string">        滑动操作 - </span><br><span class="hljs-string">        sleep(3)</span><br><span class="hljs-string">        old = new</span><br><span class="hljs-string">        new = driver.page_source   </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 滑动以前的内容</span><br>old = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 返回新页面源码</span><br>new = driver.page_source<br><br><span class="hljs-keyword">while</span> old != new:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 通过android uiatumator的UiSelector类查询名为安全测试的元素</span><br>        driver.find_element_by_android_uiautomator(<span class="hljs-string">&#x27;new UiSelector().text(&quot;安全测试&quot;)&#x27;</span>)<br>    <span class="hljs-keyword">except</span>:<br>        <span class="hljs-comment"># 在200ms内从中心屏幕高度90%的地方滑到屏幕高度30%的地方</span><br><br>        driver.swipe(size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.9</span>,size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.3</span>,<span class="hljs-number">200</span>)<br><br>        time.sleep(<span class="hljs-number">3</span>)<br><br>        old = new<br>        <span class="hljs-comment"># 重新获取页面源码</span><br>        new = driver.page_source<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;找到了安全测试&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure><h3 id="多点触控-multi-action"><a href="#多点触控-multi-action" class="headerlink" title="多点触控 multi_action"></a>多点触控 multi_action</h3><p>实现了多个单点触控，同时执行</p><ul><li><ol><li>add  添加单点触控的行为</li></ol></li><li><p>2.perfrom 执行</p></li></ul><h4 id="百度地图放大操作"><a href="#百度地图放大操作" class="headerlink" title="百度地图放大操作"></a>百度地图放大操作</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> appium.webdriver.common.multi_action import MultiAction<br><br><br><span class="hljs-keyword">from</span> appium import webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby import MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait import WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support import expected_conditions as EC<br>import time<br><span class="hljs-keyword">from</span> appium.webdriver.common.touch_action import TouchAction<br><br><br><br><span class="hljs-comment"># 1.准备参数：告诉appium，你要打开哪个设备上的哪个app。</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>: <span class="hljs-string">&quot;com.baidu.BaiduMap&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>: <span class="hljs-string">&quot;com.baidu.baidumaps.WelcomeScreen&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:True<br>&#125;<br><br><span class="hljs-comment"># 2.、连接appium server，把启动参数发送</span><br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br>time.sleep(15)<br><br><span class="hljs-comment"># 3.、获取整屏的大小</span><br>size = driver.get_window_size()<br><br><span class="hljs-comment"># 4.实例化 TouchAction对象</span><br>a = TouchAction(driver)<br><br><span class="hljs-comment"># 5.一个点从屏幕中心位置移动到屏幕右下角</span><br><br>a.press(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.5,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.5).wait(200).move_to(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.1,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.9).release()<br><br><span class="hljs-comment"># 6.一个点从屏幕中心向右上角滑动</span><br><br>b = TouchAction(driver)<br>b.press(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.5,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.5).wait(200).move_to(<span class="hljs-attribute">x</span>=size[<span class="hljs-string">&quot;width&quot;</span>]<span class="hljs-number">*0</span>.9,<span class="hljs-attribute">y</span>=size[<span class="hljs-string">&quot;height&quot;</span>]<span class="hljs-number">*0</span>.1).release()<br><br><span class="hljs-comment"># 7.加入Multiaction</span><br><br>ma = MultiAction(driver)<br>ma.<span class="hljs-built_in">add</span>(a,b)<br>ma.perform()<br></code></pre></td></tr></table></figure><h3 id="4-tap-最多用5根手指点击一个地方"><a href="#4-tap-最多用5根手指点击一个地方" class="headerlink" title="4.tap 最多用5根手指点击一个地方"></a>4.tap 最多用5根手指点击一个地方</h3><p>用法：传一个嵌套元祖的列表。为点的坐标</p><p>driver.tap([(100, 20), (100, 60), (100, 100)], 500)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> appium.webdriver.common.touch_action <span class="hljs-keyword">import</span> TouchAction<br><br><br># <span class="hljs-number">1</span>\准备参数：告诉appium，你要打开哪个设备上的哪个app。<br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>: <span class="hljs-string">&quot;com.baidu.BaiduMap&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>: <span class="hljs-string">&quot;com.baidu.baidumaps.WelcomeScreen&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:<span class="hljs-literal">True</span><br>&#125;<br><br># <span class="hljs-number">3</span>、连接appium server，把启动参数发送<br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br><br><br>driver.tap()<br></code></pre></td></tr></table></figure><h3 id="5-toast处理"><a href="#5-toast处理" class="headerlink" title="5.toast处理"></a>5.toast处理</h3><p>1.toast只能用ui automator2来处理</p><p>2.appium server1.15以上版本自动为uiautomtor2, 低于这个版本需要指明”automationName”:”UiAutomator2”</p><p>3.toast只有文本，只支持xpath定位， &#x2F;&#x2F;*[contains(@text,”手机号码”) 不能够用等待元素可见，只能用元素存在否则会报错</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><br><span class="hljs-comment"># 1\准备参数：告诉appium，你要打开哪个设备上的哪个app。</span><br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:True<br>&#125;<br><br><span class="hljs-comment"># 3、连接appium server，把启动参数发送</span><br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br><br>loc = (MobileBy.ID,<span class="hljs-string">&quot;com.lemon.lemonban:id/navigation_my&quot;</span>)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br><br>loc = (MobileBy.ID,<span class="hljs-string">&quot;com.lemon.lemonban:id/fragment_my_lemon_avatar_layout&quot;</span>)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br><br>loc = (MobileBy.ID,<span class="hljs-string">&quot;com.lemon.lemonban:id/btn_login&quot;</span>)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br><br><span class="hljs-comment"># xpath表达式</span><br>loc = (MobileBy.XPATH,<span class="hljs-string">&#x27;//*[contains(@text,&quot;手机号码或密码&quot;)]&#x27;</span>)<br>try:<br>    <span class="hljs-comment"># 等待元素存在</span><br>    <span class="hljs-comment"># 短期内就会消失的，要缩小巡查周期</span><br>    WebDriverWait(driver,<span class="hljs-number">6</span>,<span class="hljs-number">0.01</span>).<span class="hljs-keyword">until</span>(EC.presence_of_element_located(loc))<br>    <span class="hljs-comment"># 获取文本</span><br>    text = driver.find_element(*loc).text<br>    <span class="hljs-built_in">print</span>(text)<br>except:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我没有获取到toast的提示信息！！&quot;</span>)<br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="6-应用切换-driver-start-activity-包名，应用名）"><a href="#6-应用切换-driver-start-activity-包名，应用名）" class="headerlink" title="6.应用切换 driver.start_activity(包名，应用名）"></a>6.应用切换 driver.start_activity(包名，应用名）</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> time<br><br><br># <span class="hljs-number">1</span>\准备参数：告诉appium，你要打开哪个设备上的哪个app。<br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;automationName&quot;</span>:<span class="hljs-string">&quot;UiAutomator2&quot;</span>,<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,<br>    <span class="hljs-string">&quot;appPackage&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:<span class="hljs-literal">True</span><br>&#125;<br><br># <span class="hljs-number">3</span>、连接appium server，把启动参数发送<br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br><br><br>loc = (MobileBy.ID,<span class="hljs-string">&quot;com.lemon.lemonban:id/navigation_my&quot;</span>)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).until(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br><br># 传包名和应用名<br>driver.start_activity(<span class="hljs-string">&quot;com.baidu.BaiduMap&quot;</span>,<span class="hljs-string">&quot;com.baidu.baidumaps.WelcomeScreen&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="7-混合应用-hybird操作"><a href="#7-混合应用-hybird操作" class="headerlink" title="7.混合应用-hybird操作"></a>7.混合应用-hybird操作</h3><p>Hybrid 是 native 嵌套了 Web，对于 native 页面，我们可以采用原生的自动化框架 UIAutomator，而对于 Web 页面，我们可以采用 ChromeDriver，两者相结合完成自动化测试。现在流行的说法是移动端内嵌的 Web 可以称为 H5，虽然严格意义上来说 H5 不等同 Web。为了实现 H5 页面的自动化，其中 H5 页面的调试开关我们是必须要打开，否则通过 inspector 元素探测工具是定位不到页面的元素信息。</p><p>混合应用：html页面和原生控件都在app里边儿<br>混合应用自动化测试：web自动化+app自动化的组合。  </p><h4 id="如何识别混合应用？怎么知道当前这个页面含有html"><a href="#如何识别混合应用？怎么知道当前这个页面含有html" class="headerlink" title="如何识别混合应用？怎么知道当前这个页面含有html?"></a>如何识别混合应用？怎么知道当前这个页面含有html?</h4><ul><li>元素定位：class属性为 android.webkit.WebView 网页视图  </li><li>开发者模式当中，打开显示布局边界 html会显示为一个整体</li></ul><h4 id="切换到html页面步骤"><a href="#切换到html页面步骤" class="headerlink" title="切换到html页面步骤"></a>切换到html页面步骤</h4><ul><li><p>1.1、开启调试模式<br> 开启调试模式。参考文章：混合app如何打开调试模式<a href="http://www.lemfix.com/topics/317">http://www.lemfix.com/topics/317</a></p></li><li><p>1.2、获取到目前的conTexts   driver.contexts  # 返回一个列表 [‘NATIVE_APP’,’WEBVIEW_com.lemon.lemonban’]</p></li><li><p>1.3、从页面的原生控件，切换到了html页面。  在启动参数当中指定了chromdriver<br> switch_to.context(‘WEBVIEW_com.lemon.lemonban’)<br> context:上下文。 </p></li><li><p>1.4. 进入web自动化</p></li></ul><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Web自动化 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;   </p><h5 id="1-驱动要跟浏览器匹配-—-安卓系统的webview的版本"><a href="#1-驱动要跟浏览器匹配-—-安卓系统的webview的版本" class="headerlink" title="1.驱动要跟浏览器匹配 —  安卓系统的webview的版本"></a>1.驱动要跟浏览器匹配 —  安卓系统的webview的版本</h5><ul><li>chromedriver version和手机系统有关，默认找的chrome驱动是appium安装的时候自带的。 </li><li>可以先执行 switch_to.context(‘WEBVIEW_com.lemon.lemonban’)查看报错，便知道当前chrome和chromedriver版本是否匹配  </li><li>所以当chrome和chromedriver.exe驱动版本不一致时，可以下一个与之匹配的驱动版本，放在指定目录里。</li><li>每次用到的安卓版本不一样自带的chrome可能也不一样，所以在desired_caps启动参数里配置”chromedriverExecutable”:”D:\ChromeDrivers\chrome67-69\chromedriver.exe”,保持和安卓版本 chrome版本等匹配</li></ul><h5 id="2-通过uc-devtool等工具定位页面html元素"><a href="#2-通过uc-devtool等工具定位页面html元素" class="headerlink" title="2.通过uc-devtool等工具定位页面html元素"></a>2.通过uc-devtool等工具定位页面html元素</h5><ul><li>1、下载uc-devtool工具 -设置里改为 本地Devtools Inspector UI资源 点击inspector 查看元素定位</li><li>2、chrome:&#x2F;&#x2F;inspect&#x2F;#devices   翻墙查看</li><li>3、driver.page_source — 获取当前的html，</li><li>4、找开发 - 谁写的页面找谁</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy<br><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">import</span> <span class="hljs-type">time</span><br><br># *******************   App自动化    **********************<br><br># <span class="hljs-number">1</span>\准备参数：告诉appium，你要打开哪个设备上的哪个app。<br>desired_caps = &#123;<br>    &quot;automationName&quot;:&quot;UiAutomator2&quot;,<br>    &quot;platformName&quot;:&quot;Android&quot;,<br>    &quot;platformVersion&quot;:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    &quot;deviceName&quot;:&quot;emulator-5554&quot;,<br>    &quot;appPackage&quot;:&quot;com.lemon.lemonban&quot;,<br>    &quot;appActivity&quot;:&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;,<br>    &quot;noReset&quot;:<span class="hljs-keyword">True</span>,<br>    &quot;chromedriverExecutable&quot;:&quot;D:\\ChromeDrivers\\chrome67-69\\chromedriver.exe&quot;,<br>    # &quot;chromedriverExecutableDir&quot;:&quot;D:\\ChromeDrivers&quot;<br>&#125;<br><br># <span class="hljs-number">3</span>、连接appium <span class="hljs-keyword">server</span>，把启动参数发送<br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br><br>loc = (MobileBy.ANDROID_UIAUTOMATOR,&quot;new UiSelector().text(\&quot;全程班\&quot;)&quot;)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br><br>loc = (MobileBy.CLASS_NAME,&quot;android.webkit.WebView&quot;)<br><span class="hljs-type">time</span>.sleep(<span class="hljs-number">2</span>)<br><br># 获取当前所有的contexts<br>cons = driver.contexts<br>print(cons)<br><br># 切换到webview - html页面去<br>driver.switch_to.context(<span class="hljs-string">&#x27;WEBVIEW_com.lemon.lemonban&#x27;</span>)<br><br><br># *******************   web自动化  <span class="hljs-comment">-- 操作html页面了   **********************</span><br><br>loc = (MobileBy.XPATH,&quot;//span[text()=\&quot;加群\&quot;]&quot;)<br>WebDriverWait(driver,<span class="hljs-number">20</span>).<span class="hljs-keyword">until</span>(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br></code></pre></td></tr></table></figure><h3 id="8-微信小程序自动化操作步骤"><a href="#8-微信小程序自动化操作步骤" class="headerlink" title="8.微信小程序自动化操作步骤"></a>8.微信小程序自动化操作步骤</h3><h4 id="1-识别"><a href="#1-识别" class="headerlink" title="1.识别"></a>1.识别</h4><ul><li>1.元素定位：class属性为 android.webkit.WebView 网页视图  </li><li>2.开发者模式当中，打开显示布局边界 html会显示为一个整体</li><li>3.问开发 小程序是html的吗</li></ul><h4 id="2、开启调试模式："><a href="#2、开启调试模式：" class="headerlink" title="2、开启调试模式："></a>2、开启调试模式：</h4><p>微信版本在7.0+，微信有对H5开关做了调整，需要在任意聊天窗口输入如下：</p><p><a href="http://debugmm.qq.com/?forcex5=true">http://debugmm.qq.com/?forcex5=true</a>  打开微信调试 false关闭微信调试  </p><p><a href="http://debugx5.qq.com/">http://debugx5.qq.com</a> 配置 </p><p><img src="/the-nuo/picture/Snipaste_2021-05-27_23-15-42.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-27_23-16-27.png"></p><h4 id="3、获取小程序所在的进程-微信有多个进程，需要知道小程序运行时是在哪个进程当中-："><a href="#3、获取小程序所在的进程-微信有多个进程，需要知道小程序运行时是在哪个进程当中-：" class="headerlink" title="3、获取小程序所在的进程(微信有多个进程，需要知道小程序运行时是在哪个进程当中)："></a>3、获取小程序所在的进程(微信有多个进程，需要知道小程序运行时是在哪个进程当中)：</h4><ul><li>1.打开微信进入小程序后，在cmd当中运行：</li><li>2.获取进程号命令：adb shell dumpsys activity top | grep ACTIVITY</li><li>3.获取进程名称：adb shell ps 进程号</li></ul><h4 id="4、appium代码-启动参数当中："><a href="#4、appium代码-启动参数当中：" class="headerlink" title="4、appium代码 - 启动参数当中："></a>4、appium代码 - 启动参数当中：</h4><p>   1.腾讯小程序在安卓自带的webview基础上封装了一个webview叫做X5内核，因此小程序自动化不使用安卓默认自带的webview 需要设置开启新的webview会话</p><p>   desired_caps[“recreateChromeDriverSessions”] &#x3D; True</p><p>   2.切换到webview时，需要指定进程号</p><p>   desired_caps[“chromeOptions”] &#x3D; {“androidProcess”:”com.tencent.mm:appbrand0”}   </p><h4 id="5、进入小程序之后，获取当前所有的上下文，切换与4当中的进程名称一致的webview-com-tencent-mm-appbrand0"><a href="#5、进入小程序之后，获取当前所有的上下文，切换与4当中的进程名称一致的webview-com-tencent-mm-appbrand0" class="headerlink" title="5、进入小程序之后，获取当前所有的上下文，切换与4当中的进程名称一致的webview:com.tencent.mm:appbrand0"></a>5、进入小程序之后，获取当前所有的上下文，切换与4当中的进程名称一致的webview:com.tencent.mm:appbrand0</h4><p>   cons &#x3D; driver.contexts<br>   driver.switch_to.context(‘WEBVIEW_com.tencent.mm:appbrand0’)</p><h4 id="6、获取小程序当中所有的窗口。"><a href="#6、获取小程序当中所有的窗口。" class="headerlink" title="6、获取小程序当中所有的窗口。"></a>6、获取小程序当中所有的窗口。</h4><p>   hs &#x3D; driver.window_handles</p><p>   遍历所有窗口，并切入窗口的html中，查找有代表性的元素。 </p><p>   driver.find_element<br>   driver.page_source.find(“”) !&#x3D; -1:<br>      break</p><h4 id="7-启动appium时要获取腾讯X5版本所对应的chromedriver驱动"><a href="#7-启动appium时要获取腾讯X5版本所对应的chromedriver驱动" class="headerlink" title="7. 启动appium时要获取腾讯X5版本所对应的chromedriver驱动"></a>7. 启动appium时要获取腾讯X5版本所对应的chromedriver驱动</h4><p>原因：启动appium时，chromedriver版本要与腾讯x5版本匹配，而不是原生的webview。<br>步骤：</p><ul><li>1.需要指定chromedriver.exe的目录。使用appium默认目录下的会报错。</li><li>2.在切换到小程序webview时，会去匹配chrome内核的的驱动。在切换完成之后，在打印所有的窗口时，会使用x5内核的版本。</li><li>3.所以指定一个非默认目录下面的chromedriver.exe(X5内核对应的版本)，此问题就不会出现 。</li><li><ol start="4"><li>在appium server上设置chromedriver的路径：D:\ChromeDrivers\chromedriver.exe</li></ol></li></ul><h5 id="如何获取腾讯X5的chrome版本"><a href="#如何获取腾讯X5的chrome版本" class="headerlink" title="如何获取腾讯X5的chrome版本"></a>如何获取腾讯X5的chrome版本</h5><ul><li>1.下载uc-devtools</li><li>2.设置里改为 本地 Devtools Inspector UI 资源</li><li>3.手机打开开发者模式进入小程序</li><li>4.devtools点击Home 可以看到小程序所影响的chrome版本</li><li>5.根据获取到的chrome版本下载对应的chromedriver驱动<br><img src="/the-nuo/picture/Snipaste_2021-05-27_23-42-11.png"></li></ul><h5 id="1-准备工作及进入微信小程序页面"><a href="#1-准备工作及进入微信小程序页面" class="headerlink" title="1.准备工作及进入微信小程序页面"></a>1.准备工作及进入微信小程序页面</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy <span class="hljs-keyword">as</span> MB<br><br># 引入appium包<br><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><br><br>desired_caps = &#123;&#125;<br><br># 支持X5内核应用自动化配置<br>desired_caps[<span class="hljs-string">&quot;recreateChromeDriverSessions&quot;</span>] = <span class="hljs-literal">True</span><br><br># android <span class="hljs-number">4.4</span>以下的版本通过Selendroid来切换到webview<br>desired_caps[<span class="hljs-string">&quot;automationName&quot;</span>] = <span class="hljs-string">&quot;UiAutomator2&quot;</span><br>desired_caps[<span class="hljs-string">&quot;platformName&quot;</span>] = <span class="hljs-string">&quot;Android&quot;</span><br>desired_caps[<span class="hljs-string">&quot;platformVersion&quot;</span>] = <span class="hljs-string">&quot;8.1&quot;</span><br>desired_caps[<span class="hljs-string">&quot;deviceName&quot;</span>] = <span class="hljs-string">&quot;Android Emulator&quot;</span><br>desired_caps[<span class="hljs-string">&quot;appPackage&quot;</span>] = <span class="hljs-string">&quot;com.tencent.mm&quot;</span><br>desired_caps[<span class="hljs-string">&quot;appActivity&quot;</span>] = <span class="hljs-string">&quot;com.tencent.mm.ui.LauncherUI&quot;</span><br>desired_caps[<span class="hljs-string">&quot;chromedriverExecutableDir&quot;</span>] = <span class="hljs-string">&#x27;D:\\ChromeDrivers\\chrome66&#x27;</span><br>desired_caps[<span class="hljs-string">&quot;noReset&quot;</span>] = <span class="hljs-literal">True</span><br># 支持输入中文<br>desired_caps[<span class="hljs-string">&quot;unicodeKeyboard&quot;</span>] = <span class="hljs-literal">True</span><br># desired_caps[<span class="hljs-string">&quot;resetKeyboard&quot;</span>] = <span class="hljs-literal">True</span><br><br># ChromeOptions使用来定制启动选项，因为在appium中切换context识别webview的时候,<br># 会有多个进程，我们要指定为微信小程序所在的进程<br><br>desired_caps[<span class="hljs-string">&quot;chromeOptions&quot;</span>] = &#123;<span class="hljs-string">&quot;androidProcess&quot;</span>: <span class="hljs-string">&quot;com.tencent.mm:appbrand0&quot;</span>&#125;<br><br><br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>, desired_caps)<br><br>wait = WebDriverWait(driver,<span class="hljs-number">30</span>)<br><br># 微信页面下拉屏幕<br>loc = (MB.ID,<span class="hljs-string">&#x27;com.tencent.mm:id/baj&#x27;</span>)<br>wait.until(EC.visibility_of_all_elements_located(loc))<br>time.sleep(<span class="hljs-number">3</span>)<br>size = driver.get_window_size()<br>driver.swipe(size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.2</span>,size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0.5</span>,size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0.9</span>,<span class="hljs-number">100</span>)<br><br># 小程序界面中点击  软件测试 小程序<br>loc = (MB.ANDROID_UIAUTOMATOR,<span class="hljs-string">&#x27;new UiSelector().text(&quot;柠檬班软件…&quot;).resourceId(&quot;com.tencent.mm:id/dd&quot;)&#x27;</span>)<br>WebDriverWait(driver,<span class="hljs-number">30</span>).until(EC.visibility_of_element_located(loc))<br>driver.find_element(*loc).click()<br>time.sleep(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h5 id="2-切换到小程序所在的上下文"><a href="#2-切换到小程序所在的上下文" class="headerlink" title="2.切换到小程序所在的上下文"></a>2.切换到小程序所在的上下文</h5><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta"># ==================  进入了 软件测试  小程序界面===============</span><br><br><span class="hljs-meta"># 1.获取所有的上下文</span><br>cons = driver.contexts<br>print(<span class="hljs-string">&quot;当前所有的上下文为：&quot;</span>,cons)   <span class="hljs-meta"># [<span class="hljs-string">&quot;NATIVE_APP&quot;</span>,<span class="hljs-string">&quot;WEBVIEW_com.tencent.mm:appbrand0&quot;</span>,<span class="hljs-string">&quot;WEBVIEW_com.tencent.mm&quot;</span>]</span><br><br><span class="hljs-meta"># 2.切换到小程序webview</span><br>driver.switch_to.context(<span class="hljs-string">&#x27;WEBVIEW_com.tencent.mm:appbrand0&#x27;</span>)<br><br>time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h5 id="3，进入到web自动化"><a href="#3，进入到web自动化" class="headerlink" title="3，进入到web自动化"></a>3，进入到web自动化</h5><p>小程序一个页面可能有多个窗口，打印当前所有的窗口，遍历查询所有的handles,通过元素查找找到当前页面所在的handle<br>进行定位等操作</p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs leaf">print(&quot;=================进入web自动化环节===============================&quot;)<br><br><span class="hljs-punctuation">#</span> <br><br>hs = driver.window_handles<br>print(&quot;当前所有的窗口为：&quot;,hs)<br>print(&quot;当前所在的窗口为：&quot;,driver.current_window_handle)<br><br><span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span>需要找到哪一个窗口有柠檬班信息的窗口，然后再在其下找元素操作。<br><span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span>遍历所有的handles，找到当前页面所在的handle：如果pageSource有包含你想要的元素，就是所要找的handle。也可以使用元素定位 try:find_element_by<br><span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span>小程序的页面来回切换也需要：遍历所有的handles，切换到元素所在的handle<br><br>for handle in hs:<br>    driver.switch_to.window(handle)<br>    print(&quot;切换到窗口：&quot;,handle)<br>    time.sleep(3)<br>    <span class="hljs-punctuation">#</span><span class="hljs-keyword">print</span><span class="hljs-params">(<span class="hljs-variable">driver</span>.<span class="hljs-variable">page_source</span>)</span>    <span class="hljs-punctuation">#</span> 也可以使用元素定位<br>    if driver.page_source.find(&quot;柠檬班&quot;) != -1:<br>        break<br><br><span class="hljs-punctuation">#</span> 元素定位操作<br>WebDriverWait(driver,20).until(EC.visibility_of_element_located((MB.XPATH,&#x27;//ul[@id=&quot;js-tab-bar&quot;]//a[contains(text(),&quot;老师&quot;)]&#x27;))).click()<br><br>WebDriverWait(driver,20).until(EC.presence_of_element_located((MB.XPATH,&quot;//em[text()=&#x27;土豆&#x27;]&quot;)))<br>time.sleep(0.5)<br><span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span>找到老师<br><span class="hljs-punctuation">#</span> ele = driver.find_element_by_xpath(&quot;//em[text()=&#x27;歪歪&#x27;]&quot;)<br><span class="hljs-punctuation">#</span> <span class="hljs-punctuation">#</span>拖动到可见区域<br><span class="hljs-punctuation">#</span> driver.execute_script(&quot;arguments[0].scrollIntoViewIfNeeded(true);&quot;,ele)<br><br>time.sleep(10)<br>driver.quit()<br><br></code></pre></td></tr></table></figure><h3 id="9-微信公众号自动化"><a href="#9-微信公众号自动化" class="headerlink" title="9.微信公众号自动化"></a>9.微信公众号自动化</h3><p>公众号文章都是html</p><h5 id="启动进入公众号"><a href="#启动进入公众号" class="headerlink" title="启动进入公众号"></a>启动进入公众号</h5><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> selenium.webdriver.support.wait <span class="hljs-keyword">import</span> WebDriverWait<br><span class="hljs-keyword">from</span> selenium.webdriver.support <span class="hljs-keyword">import</span> expected_conditions <span class="hljs-keyword">as</span> EC<br><span class="hljs-keyword">from</span> appium.webdriver.common.mobileby <span class="hljs-keyword">import</span> MobileBy <span class="hljs-keyword">as</span> MB<br><br># 引入appium包<br><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br><span class="hljs-keyword">import</span> time<br><br><br>desired_caps = &#123;&#125;<br># 支持X5内核应用自动化配置<br>desired_caps[<span class="hljs-string">&quot;recreateChromeDriverSessions&quot;</span>] = <span class="hljs-literal">True</span><br># android <span class="hljs-number">4.4</span>以下的版本通过Selendroid来切换到webview<br>desired_caps[<span class="hljs-string">&quot;automationName&quot;</span>] = <span class="hljs-string">&quot;UiAutomator2&quot;</span><br>desired_caps[<span class="hljs-string">&quot;platformName&quot;</span>] = <span class="hljs-string">&quot;Android&quot;</span><br>desired_caps[<span class="hljs-string">&quot;platformVersion&quot;</span>] = <span class="hljs-string">&quot;8.1&quot;</span><br>desired_caps[<span class="hljs-string">&quot;deviceName&quot;</span>] = <span class="hljs-string">&quot;Android Emulator&quot;</span><br>desired_caps[<span class="hljs-string">&quot;appPackage&quot;</span>] = <span class="hljs-string">&quot;com.tencent.mm&quot;</span><br>desired_caps[<span class="hljs-string">&quot;appActivity&quot;</span>] = <span class="hljs-string">&quot;com.tencent.mm.ui.LauncherUI&quot;</span><br>desired_caps[<span class="hljs-string">&quot;chromedriverExecutableDir&quot;</span>] = <span class="hljs-string">&#x27;D:\\ChromeDrivers\\chrome66&#x27;</span><br>desired_caps[<span class="hljs-string">&quot;noReset&quot;</span>] = <span class="hljs-literal">True</span><br>desired_caps[<span class="hljs-string">&quot;unicodeKeyboard&quot;</span>] = <span class="hljs-literal">True</span><br># desired_caps[<span class="hljs-string">&quot;resetKeyboard&quot;</span>] = <span class="hljs-literal">True</span><br><br># ChromeOptions使用来定制启动选项，因为在appium中切换context识别webview的时候,<br># 会有多个进程，我们要指定为微信小程序所在的进程<br><br>desired_caps[<span class="hljs-string">&quot;chromeOptions&quot;</span>] = &#123;<span class="hljs-string">&quot;androidProcess&quot;</span>: <span class="hljs-string">&quot;com.tencent.mm:toolsmp&quot;</span>&#125;<br><br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>, desired_caps)<br>wait = WebDriverWait(driver,<span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><h5 id="2-找到想要测试的公众号-可以用滑屏，也可以直接星标公众号这样子第一个就是"><a href="#2-找到想要测试的公众号-可以用滑屏，也可以直接星标公众号这样子第一个就是" class="headerlink" title="2.找到想要测试的公众号,可以用滑屏，也可以直接星标公众号这样子第一个就是"></a>2.找到想要测试的公众号,可以用滑屏，也可以直接星标公众号这样子第一个就是</h5><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs apache"><br><span class="hljs-comment"># 主页的元素</span><br><span class="hljs-attribute">loc</span> = (MB.ID,&#x27;com.tencent.mm:id/baj&#x27;)<br><span class="hljs-attribute">wait</span>.until(EC.visibility_of_all_elements_located(loc))<br><span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment"># 1、整个屏幕的大小 size</span><br><span class="hljs-attribute">device_size</span> = driver.get_window_size() # width  height<br><span class="hljs-attribute">print</span>(device_size)<br><br><span class="hljs-comment"># 找到订阅号信息  这个元素滑屏找到该元素</span><br><span class="hljs-comment"># 也可以把公众号设为星标。不用滑屏找了</span><br><br><span class="hljs-attribute">old_page</span> = None<br><span class="hljs-attribute">new_page</span> = driver.page_source<br><span class="hljs-attribute">while</span> old_page != new_page:<br>    <span class="hljs-comment"># 等待并找元素</span><br>    <span class="hljs-attribute">loc</span> = (MB.ANDROID_UIAUTOMATOR,&#x27;new UiSelector().text(<span class="hljs-string">&quot;订阅号消息&quot;</span>).resourceId(<span class="hljs-string">&quot;com.tencent.mm:id/baj&quot;</span>)&#x27;)<br>    <span class="hljs-attribute">try</span>:<br>        <span class="hljs-attribute">WebDriverWait</span>(driver,<span class="hljs-number">10</span>).until(EC.visibility_of_element_located(loc))<br>    <span class="hljs-attribute">except</span>:<br>        <span class="hljs-comment"># 如果不存在呢，滑动。页面的更新：更新前后页面的内容。</span><br>        <span class="hljs-attribute">driver</span>.swipe(device_size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,device_size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0</span>.<span class="hljs-number">9</span>,device_size[<span class="hljs-string">&quot;width&quot;</span>]*<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,device_size[<span class="hljs-string">&quot;height&quot;</span>]*<span class="hljs-number">0</span>.<span class="hljs-number">3</span>,<span class="hljs-number">200</span>)<br>        <span class="hljs-attribute">time</span>.sleep(<span class="hljs-number">2</span>)<br>        <span class="hljs-attribute">old_page</span> = new_page<br>        <span class="hljs-attribute">new_page</span> = driver.page_source<br>    <span class="hljs-attribute">else</span>:<br>        <span class="hljs-attribute">driver</span>.find_element(*loc).click()  # 点击订阅号进入<br>        <span class="hljs-attribute">break</span><br></code></pre></td></tr></table></figure><h5 id="3-点击公众号进入，选择一篇文章进入"><a href="#3-点击公众号进入，选择一篇文章进入" class="headerlink" title="3.点击公众号进入，选择一篇文章进入"></a>3.点击公众号进入，选择一篇文章进入</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stata"># 点击软件测试<br><span class="hljs-keyword">loc</span> = (MB.ANDROID_UIAUTOMATOR,&#x27;new UiSelector().text(<span class="hljs-string">&quot;软件测试&quot;</span>).resourceId(<span class="hljs-string">&quot;com.tencent.mm:id/a_0&quot;</span>)&#x27;)<br>WebDriverWait(driver,10).until(EC.visibility_of_element_located(<span class="hljs-keyword">loc</span>))<br>driver.find_element(*<span class="hljs-keyword">loc</span>).click()<br><br># 进入公众号页面 - 点一个链接进入 - 进入一篇公众号文章<br><span class="hljs-keyword">loc</span> = (MB.ID,&#x27;com.tencent.mm:id/dd&#x27;)  <br>WebDriverWait(driver,10).until(EC.visibility_of_element_located(<span class="hljs-keyword">loc</span>))<br>eles = driver.find_elements(*<span class="hljs-keyword">loc</span>)<br>eles[-1].click()<br><br># web页面出现<br>time.<span class="hljs-keyword">sleep</span>(3)<br><br><span class="hljs-keyword">cons</span> = driver.contexts<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;所有的上下文：&quot;</span>,<span class="hljs-keyword">cons</span>)<br># 切换<br>driver.switch_to.context(&#x27;WEBVIEW_com.tencent.mm:toolsmp&#x27;)<br></code></pre></td></tr></table></figure><h5 id="4-查看文章。一个页面可能有多个页面，需要先遍历"><a href="#4-查看文章。一个页面可能有多个页面，需要先遍历" class="headerlink" title="4.查看文章。一个页面可能有多个页面，需要先遍历"></a>4.查看文章。一个页面可能有多个页面，需要先遍历</h5><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stata">time.<span class="hljs-keyword">sleep</span>(3)<br>wins = driver.window_handles<br><span class="hljs-keyword">print</span>(<span class="hljs-string">&quot;所有的窗口&quot;</span>,wins)<br><span class="hljs-keyword">loc</span> = (MB.XPATH,&#x27;<span class="hljs-comment">//h2[@id=&quot;activity-name&quot;]&#x27;)  # 每篇文章的标题元素</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">win</span> <span class="hljs-keyword">in</span> wins:<br>    <span class="hljs-keyword">print</span>(<span class="hljs-keyword">win</span>)<br>    driver.switch_to.<span class="hljs-keyword">window</span>(<span class="hljs-keyword">win</span>)<br>    try:<br>        WebDriverWait(driver,10).until(EC.visibility_of_element_located(<span class="hljs-keyword">loc</span>))<br>    except:<br>        pass<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">break</span><br><br># 滑动html页面 --<br>time.<span class="hljs-keyword">sleep</span>(2)<br><br># 退出html页面<br>driver.switch_to.content(<span class="hljs-string">&quot;NATIVE_APP&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="脚本执行常见报错及解决办法"><a href="#脚本执行常见报错及解决办法" class="headerlink" title="脚本执行常见报错及解决办法"></a>脚本执行常见报错及解决办法</h2><p>1.报错：  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs qml">UiAutomator exited unexpectedly <span class="hljs-keyword">with</span> code <span class="hljs-number">255</span>,<span class="hljs-keyword">signal</span><span class="hljs-string"> null</span><br></code></pre></td></tr></table></figure><p>原因：<br>weditor在手机安装了ATX应用，会影响appium执行自动化脚本，uiautomator框架服务启动失败</p><p>解决办法：<br>手机上atx关闭uiautomator服务或者直接删除ATX应用<br><img src="/the-nuo/picture/Snipaste_2021-05-26_11-35-34.png"></p><p>2.报错：  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">selenium.common.exceptions.WebDriverException: Message: An unknown server-side <span class="hljs-keyword">error</span> occurred <span class="hljs-keyword">while</span> processing <span class="hljs-keyword">the</span> command. Original <span class="hljs-keyword">error</span>: The instrumentation process cannot be initialized. Make sure <span class="hljs-keyword">the</span> <span class="hljs-built_in">application</span> under test <span class="hljs-keyword">does</span> <span class="hljs-keyword">not</span> crash <span class="hljs-keyword">and</span> investigate <span class="hljs-keyword">the</span> logcat output.<br></code></pre></td></tr></table></figure><p>原因：<br>打开了weditor服务正在元素定位，此时服务不停止，会导致运行脚本时进程冲突，会报此错误 </p><p>解决办法：<br>ctrl + c 退出weditor进程 ，重新运行脚本</p><p>3.报错</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">urllib3.exceptions.MaxRetryError: HTTPConnectionPool(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-attribute">port</span>=4723): Max retries exceeded with url: /wd/hub/session (Caused by NewConnectionError(<span class="hljs-string">&#x27;&lt;urllib3.connection.HTTPConnection object at 0x7f95e84624d0&gt;: Failed to establish a new connection: [Errno 61] Connection refused&#x27;</span>))<br></code></pre></td></tr></table></figure><p>原因：<br>appium server 未开启  </p><p>解决办法：<br>开启appium server</p><h2 id="建立了连接，打开app首页步骤"><a href="#建立了连接，打开app首页步骤" class="headerlink" title="建立了连接，打开app首页步骤"></a>建立了连接，打开app首页步骤</h2><h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><ul><li>1.启动appium程序 </li><li>2.至少有一个设备是能够识别到的 adb devices</li><li>3.获取应用包名appPackage和appActivity</li></ul><h4 id="aapt命令-apk获取应用包名appPackage和appActivity"><a href="#aapt命令-apk获取应用包名appPackage和appActivity" class="headerlink" title="aapt命令:apk获取应用包名appPackage和appActivity"></a>aapt命令:apk获取应用包名appPackage和appActivity</h4><ul><li>aapt目录：&#x2F;adt-bundle-mac-x86_64-20140624&#x2F;sdk&#x2F;build-tools&#x2F;android-4.4W&#x2F;aapt  </li><li>命令用法：aapt dump badging apk应用名</li><li>示例:aapt dump badging D:\BaiduNetdiskDownload\Future-release-2019.apk</li><li>launchable activity后就是 appActivity</li></ul><h4 id="1-准备启动参数：告诉appium-要打开哪个设备上的哪个app"><a href="#1-准备启动参数：告诉appium-要打开哪个设备上的哪个app" class="headerlink" title="1.准备启动参数：告诉appium,要打开哪个设备上的哪个app"></a>1.准备启动参数：告诉appium,要打开哪个设备上的哪个app</h4><p>原理:</p><ul><li>appium desktop服务同时支持android和ios,android和ios有自带的自动化框架    </li><li>Android和iOS有很多的版本且版本之间存在自动化框架上的差异，所有代码当中必须告诉appium  </li><li>你是要在 哪个平台的哪个版本上，对哪个app进行操作。</li></ul><p>启动参数获取地址：<a href="http://appium.io/docs/en/writing-running-appium/caps/#general-capabilities">http://appium.io/docs/en/writing-running-appium/caps/#general-capabilities</a>  </p><ul><li>1.告诉平台 android&#x2F;ios</li><li>2.系统版本号 </li><li>3.设备名称 需要这个参数但是没有实际用处</li><li>4.包名</li><li>5.appActivity入口页面</li><li>6.noReset：不重置应用的数据，假如现在已经登录上app.如果是noReset&#x3D;false，那么appium执行的时候会将应用的数据清除，反之noReset&#x3D;true,appium执行时候不会清掉数据进行测试。默认是noReset&#x3D;false</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs autoit">申明了appPackage和appActivity，代表设备上已经提前安装了app，不需要通过代码安装<br>desired_caps = &#123;<br>    <span class="hljs-string">&quot;platformName&quot;</span>:<span class="hljs-string">&quot;Android&quot;</span>,<br>    <span class="hljs-string">&quot;platformVersion&quot;</span>:<span class="hljs-string">&#x27;7.1.2&#x27;</span>,<br>    <span class="hljs-string">&quot;deviceName&quot;</span>:<span class="hljs-string">&quot;emulator-5554&quot;</span>,  <span class="hljs-meta"># adb devices获取到的设备名称</span><br>    <span class="hljs-string">&quot;appPackage&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban&quot;</span>,<br>    <span class="hljs-string">&quot;appActivity&quot;</span>:<span class="hljs-string">&quot;com.lemon.lemonban.activity.WelcomeActivity&quot;</span>,<br>    <span class="hljs-string">&quot;noReset&quot;</span>:<span class="hljs-literal">True</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-启动appium-server程序-查看端口号"><a href="#2-启动appium-server程序-查看端口号" class="headerlink" title="2.启动appium server程序 查看端口号"></a>2.启动appium server程序 查看端口号</h4><h4 id="3-连接appium-server，把端口替换为appium启动后的端口号，开启appium-server"><a href="#3-连接appium-server，把端口替换为appium启动后的端口号，开启appium-server" class="headerlink" title="3.连接appium server，把端口替换为appium启动后的端口号，开启appium server"></a>3.连接appium server，把端口替换为appium启动后的端口号，开启appium server</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> appium <span class="hljs-keyword">import</span> webdriver<br># 把端口替换为appium启动后的端口号<br>driver = webdriver.Remote(<span class="hljs-string">&#x27;http://127.0.0.1:4723/wd/hub&#x27;</span>,desired_caps)<br></code></pre></td></tr></table></figure><p><img src="/the-nuo/picture/Snipaste_2021-05-25_11-54-49.png">  </p><h4 id="4-运行代码"><a href="#4-运行代码" class="headerlink" title="4.运行代码"></a>4.运行代码</h4><h4 id="5-一个完整的请求过程"><a href="#5-一个完整的请求过程" class="headerlink" title="5.一个完整的请求过程"></a>5.一个完整的请求过程</h4><p>1、收到http请求<br>2、创建会话<br>3、确认当前是否有连接的设备，并且确认是否匹配安卓版本<br>4、确认设备上有没有指定包名的app<br>5、往设备上安装appium自己的 setting apk包。若已安装，需要确认apk版本是否匹配。<br>6、appium会往设备上推送一个appiumbootstrap.jar包。–java代码<br>   —运行jar包，在手机上启动一个ip+端口。接收来自appium server的请求,调用手机上的自动化框架执行操作。  </p><p>  io.appium.uiautomator2.server<br>  io.appium.uiautomator2.server.test  </p><p>7、响应http请求<br>8、下一个http请求。。   </p><p>安卓系统本身，有自动化框架。 — 直接写java代码，调用自动化框架里的api。丢到手机上。<br>uiautomatorviewer.bat</p><h4 id="命令行启动appium"><a href="#命令行启动appium" class="headerlink" title="命令行启动appium"></a>命令行启动appium</h4><p>&#x2F;Applications&#x2F;Appium.app&#x2F;Contents&#x2F;Resources&#x2F;app&#x2F;node_modules&#x2F;appium&#x2F;build&#x2F;lib&#x2F;node main.js</p>]]></content>
    
    
    <categories>
      
      <category>AutoTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMeter压测</title>
    <link href="/2022/08/17/PerformanceTesting/JMeter%E5%8E%8B%E6%B5%8B/"/>
    <url>/2022/08/17/PerformanceTesting/JMeter%E5%8E%8B%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h1><h2 id="JMeter单机压测"><a href="#JMeter单机压测" class="headerlink" title="JMeter单机压测"></a>JMeter单机压测</h2><h2 id="JMeter线程组运行模式"><a href="#JMeter线程组运行模式" class="headerlink" title="JMeter线程组运行模式"></a>JMeter线程组运行模式</h2><ul><li>1.按照运行次数运行:线程组设置循环x次 </li><li>2.按照运行时间运行（用的比较多）<ul><li>1&gt; 线程组设置循环永远</li><li>2&gt; 勾选调度器，设置持续时间，单位秒</li></ul></li></ul><h2 id="线程组和请求的运行逻辑"><a href="#线程组和请求的运行逻辑" class="headerlink" title="线程组和请求的运行逻辑"></a>线程组和请求的运行逻辑</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_15-34-15.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_23-03-26.png"></p><h2 id="线程组和请求的设置逻辑"><a href="#线程组和请求的设置逻辑" class="headerlink" title="线程组和请求的设置逻辑"></a>线程组和请求的设置逻辑</h2><h5 id="关键逻辑"><a href="#关键逻辑" class="headerlink" title="关键逻辑"></a>关键逻辑</h5><ul><li>一个线程组内的多个请求是顺序执行的 </li><li>不同线程组内的请求是并行执行的</li></ul><h5 id="实际工作中如何设置线程组和请求的关系"><a href="#实际工作中如何设置线程组和请求的关系" class="headerlink" title="实际工作中如何设置线程组和请求的关系?"></a>实际工作中如何设置线程组和请求的关系?</h5><ul><li>如果多个接口之间没有强依赖关系，每个接口单独设置一个线程组</li><li>如果多个接口之间有依赖关系(数据关联),把有关联关系的接口按照顺放在同一个线程组内</li></ul><h2 id="JMeter基本元件-特殊的线程组"><a href="#JMeter基本元件-特殊的线程组" class="headerlink" title="JMeter基本元件-特殊的线程组"></a>JMeter基本元件-特殊的线程组</h2><h4 id="setup线程组"><a href="#setup线程组" class="headerlink" title="setup线程组"></a>setup线程组</h4><p>执行全局初始化操作的线程组，在所有线程组前执行</p><h4 id="tearDown线程组"><a href="#tearDown线程组" class="headerlink" title="tearDown线程组"></a>tearDown线程组</h4><p>执行全局结束操作的线程组，在所有线程组之后执行</p><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>1.JMeter打包压缩上传到linux服务器 </p><ul><li>解压 </li><li>在etc&#x2F;profile下配置JMeter环境变量</li><li>进入JMeter bin目录下配置脚本可执行权限 chmod +x .&#x2F;*</li></ul><h2 id="JMeter命令行模式-单机"><a href="#JMeter命令行模式-单机" class="headerlink" title="JMeter命令行模式-单机"></a>JMeter命令行模式-单机</h2><ul><li>1，压力机安装并配置好JDK </li><li>2，在windows下调试好JMeter脚本，并上传至Linux下 </li><li>3、进到JMeter 根目录下需要添加执行权限 chmod -R +x .&#x2F;* 单机器测试步骤:</li><li>4.执行压测命令jmeter -n -t pinter.jmx -l result.jtl<ul><li>-n: 命令行模式，no-gui 不加会报错</li><li>-t:jmx脚本路径+脚本名称;</li><li>-l:jtl结果文件存放路径</li></ul></li></ul><h2 id="JMeter命令行模式-概要日志"><a href="#JMeter命令行模式-概要日志" class="headerlink" title="JMeter命令行模式-概要日志"></a>JMeter命令行模式-概要日志</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_15-58-43.png"></p><h3 id="JMeter参数优化"><a href="#JMeter参数优化" class="headerlink" title="JMeter参数优化"></a>JMeter参数优化</h3><ul><li>1，控制台取样间隔的设置<br>summariser.interval&#x3D;10，默认为30s，最低可修改为6s 一般设置为10s 修改JMeter的bin目录下jmeter.properties文件</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_16-01-37.png"></p><ul><li>2，Jvm参数优化 不要超过物理内存的四分之一<br>jmeter&#x2F;bin目录下，vi jmeter，修改HEAP的size大小，默认1024M，可以设置成2048M<br>HEAP&#x3D;”-Xms2g -Xmx2g -XX:MaxMetaspaceSize&#x3D;256m”</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_23-30-06.png"></p><ul><li>3，默认编码修改 sampleresult.default.encoding</li></ul><h2 id="JMeter命令行模式-结果报表"><a href="#JMeter命令行模式-结果报表" class="headerlink" title="JMeter命令行模式-结果报表"></a>JMeter命令行模式-结果报表</h2><p>三种方式来获取Jmeter的结果报表</p><ul><li>一、在GUI模式下跑Jmeter的脚本，用tps插件实时展示图表 </li><li>二、在命令行模式下跑Jmeter的脚本，生成的jtl文件，在GUI界面的聚合报告里打开，可以展示tps 和 响应时间等数据 </li><li>三、在命令行模式下跑Jmeter的脚本，生成的jtl文件，通过Jmeter自带命令，生成html报表<br>注意:<br>在实际工作中，不推荐第一种执行方式，会影响Jmeter</li></ul><h2 id="JMeter命令行模式-html报表"><a href="#JMeter命令行模式-html报表" class="headerlink" title="JMeter命令行模式-html报表"></a>JMeter命令行模式-html报表</h2><p> Html报表生成步骤</p><ul><li>1，进入jmeter的bin目录下，修改reportgenerator.properties </li><li>2，修改jmeter.reportgenerator.overall_granularity&#x3D;1000(报表中数据展示间隔1秒) 单位为ms</li><li>3，创建一个存放数据报表的文件夹 mkdir reports</li><li>4，执行命令:jmeter –g result.jtl –o .&#x2F;reports</li><li>5.对整个reports文件夹进行压缩<br>其中:<br>-g 指定jtl文件的路径<br>-o 指定html报表生成到哪个文件夹下<br>注意:只有Jmeter3.0版本以上支持此功能</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_16-29-33.png"></p><h2 id="Controller和压力机"><a href="#Controller和压力机" class="headerlink" title="Controller和压力机"></a>Controller和压力机</h2><p>压力机：产生压力的机器 可以是windows系统或者linux系统。<br>压力机可以和服务器数量持平。可以先申请一半机器先尝试</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_17-51-48.png"></p><h4 id="如何判断压力机不够？"><a href="#如何判断压力机不够？" class="headerlink" title="如何判断压力机不够？"></a>如何判断压力机不够？</h4><p>压力机比较消耗CPU和内存，CPU使用率超过80%就需要增加机器</p><h2 id="JMeter命令行模式-分布式"><a href="#JMeter命令行模式-分布式" class="headerlink" title="JMeter命令行模式-分布式"></a>JMeter命令行模式-分布式</h2><ul><li>1.硬件环境准备</li><li>2.配置 vi&#x2F;etc&#x2F;hostname 修改hostname 每一台jmeter机器都要改 例如mycentos2 重启一下xshell</li><li>3.修改本机ip和本机hostname映射关系 vi&#x2F;etc&#x2F;hosts 查看ip命令ipaddr</li></ul><h4 id="分布式测试步骤"><a href="#分布式测试步骤" class="headerlink" title="分布式测试步骤:"></a>分布式测试步骤:</h4><p>系统HOSTS文件中进行类似 本机IP 主机名的配置，如10.0.0.23 zhoucentos，否则启动jmeter server会报错! </p><ul><li>1，在每台机器上都部署 jmeter</li><li>2，如果是java脚本，将java脚本和相关lib包都放在jmeter目录lib&#x2F;ext下(jar).如果有参数文件，参数文件也要上传到每一台压力机上</li><li>3，将jmeter的场景文件jmx上传到主jmeter的任意位置，参数文件放到每一台压力机上(存放目录要相同)</li><li>4，bin目录下修改jmeter.properties文件，ssl.disable&#x3D;true(去掉注释) </li><li>5，在每台机器上进入到jmeter的bin目录下，都启动nohup .&#x2F;jmeter-server &amp; (后台启动jmeter-server服务)  分布式之间的通信机制通过jmeter server</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_22-36-21.png"></p><ul><li>6，在主jmeter的bin目录下，修改jmeter.properties，将其中的remote_hosts修改为作为压力机的两台机器ip， remote_hosts&#x3D;127.0.0.1,192.168.0.102</li><li>7，在主jmeter的机器上，执行jmeter -n -t pinter.jmx -l result.jtl -r -r是单机压测和分布式压测的区别</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_22-57-24.png"></p><h5 id="分布式启动失败原因："><a href="#分布式启动失败原因：" class="headerlink" title="分布式启动失败原因："></a>分布式启动失败原因：</h5><ul><li>防火墙没关</li><li>上一次在主jmeter上做了CTRL+C的操作</li><li>某一台jmeter server没有启动成功</li></ul><h5 id="如果要停止压测-需要复制主压力机会话-在jmeter-bin目录下执行-shutdown-sh"><a href="#如果要停止压测-需要复制主压力机会话-在jmeter-bin目录下执行-shutdown-sh" class="headerlink" title="如果要停止压测 需要复制主压力机会话 在jmeter bin目录下执行.&#x2F;shutdown.sh"></a>如果要停止压测 需要复制主压力机会话 在jmeter bin目录下执行.&#x2F;shutdown.sh</h5><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>运行jmeter-server时，出现“Exception creating connection to:192.16.<em>.</em>;nested exception is:java.io.FileNotFoundException:rmi_keystore.jks(系统找不到指定的文件)”错误 将主从机器上的jmeter.properties文件 参数server.rmi.ssl.disable均改为true<br>其中linux上是用以下命令:vi jmeter.properties 使用&#x2F;server.rmi.ssl.disable&#x2F;进行查找  </p><ul><li>1、如果是http脚本，在controller的机器上有脚本文件即可; </li><li>2、如果是Java脚本，在每一台机器上都得有脚本文件和依赖的</li></ul><h3 id="命令行压测，排查报错"><a href="#命令行压测，排查报错" class="headerlink" title="### 命令行压测，排查报错"></a>### 命令行压测，排查报错</h3><p>压测过程中如果有报错的话，可以通过察看结果树来察看<br>配置好以后需要重新上传jmeter脚本</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_23-05-47.png"></p><h4 id="排查步骤"><a href="#排查步骤" class="headerlink" title="排查步骤"></a>排查步骤</h4><ul><li>1.脚本当前目录下会有jmeter.log 查看是否有错误日志</li><li>2.如果是分布式压测 在jmeter&#x2F;bin目录下检查jmeter-server.log 是否有报错信息 tail -100 erro.xml</li><li>3.如果配置了查看结果树保存报错信息，可以将报错xml在查看结果树中打开，进行分析</li><li>4.也可以去jtl文件中查看是否有错误提示信息</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-18_23-17-35.png"></p><h2 id="性能测试的目的"><a href="#性能测试的目的" class="headerlink" title="性能测试的目的"></a>性能测试的目的</h2><h4 id="测试系统最大处理能力"><a href="#测试系统最大处理能力" class="headerlink" title="测试系统最大处理能力"></a>测试系统最大处理能力</h4><p>寻找系统最大的TPS,判断TPS和对应响应时间是否满足预期</p><h4 id="测试系统支持最高并发"><a href="#测试系统支持最高并发" class="headerlink" title="测试系统支持最高并发"></a>测试系统支持最高并发</h4><p>寻找系统最高能支持多少并发，当系统出现宕机，进程崩溃，报错率持续上升，响应时间超过可忍受范围，程序无响应任意情况，即认可系统达到了可支持的最高并发</p><h2 id="性能测试场景"><a href="#性能测试场景" class="headerlink" title="性能测试场景"></a>性能测试场景</h2><h3 id="三个基本压测场景"><a href="#三个基本压测场景" class="headerlink" title="三个基本压测场景"></a>三个基本压测场景</h3><ul><li><h4 id="1-先进行单接口测试"><a href="#1-先进行单接口测试" class="headerlink" title="1.先进行单接口测试"></a>1.先进行单接口测试</h4><ul><li>用多少并发开始测没有具体的标准看个人习惯。一般10并发开始测 持续时间一般选择180秒或者300秒跑一轮</li><li>准备excel记录数据 可以通过修改jmeter脚本搜索&#x2F;num_thread修改并发数</li><li>并发数设置一定要灵活，如果tps增加很快说明性能很好，平均响应时间没什么变化，可以果断大幅度增加并发数</li><li>在拐点的前两个 拐点 拐点的后两个 重新跑一遍老老实实等到跑完。记录数据</li></ul></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_11-33-34.png"></p><ul><li><h4 id="2-再按照一定的并发比例，进行多接口混合测试"><a href="#2-再按照一定的并发比例，进行多接口混合测试" class="headerlink" title="2.再按照一定的并发比例，进行多接口混合测试"></a>2.再按照一定的并发比例，进行多接口混合测试</h4><ul><li>大部分公司按照用户比例进行混合 按照并发的比例去设置 </li><li>设定起始并发接口按照比例分配并发数</li><li>混合场景以总TPS为准来看拐点</li></ul></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_12-01-33.png"></p><ul><li><h4 id="3-最好按照混合场景比例，进行长时间稳定性测试"><a href="#3-最好按照混合场景比例，进行长时间稳定性测试" class="headerlink" title="3.最好按照混合场景比例，进行长时间稳定性测试"></a>3.最好按照混合场景比例，进行长时间稳定性测试</h4><ul><li>以混合场景为基础 以拐点并发数为准按比例划分</li><li>运行时间设置为12h</li><li>稳定性测试不会过度关注tps高和低 会更关注运行是否平稳</li></ul></li><li><h4 id="4-其他压测场景"><a href="#4-其他压测场景" class="headerlink" title="4.其他压测场景"></a>4.其他压测场景</h4></li></ul><p>根据自己的业务情况，选择不同业务场景的压测</p><h2 id="性能测试执行策略"><a href="#性能测试执行策略" class="headerlink" title="性能测试执行策略"></a>性能测试执行策略</h2><h3 id="加压策略"><a href="#加压策略" class="headerlink" title="加压策略"></a>加压策略</h3><p>从小并发开始，逐步增加并发，寻找性能拐点</p><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><p>试压阶段：寻找拐点，记录拐点数据<br>收集数据：选择拐点前后5组数据，按照固定时间（3-5分钟）重新跑一次，记录详细数据</p><h2 id="性能拐点"><a href="#性能拐点" class="headerlink" title="性能拐点"></a>性能拐点</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_11-13-37.png"></p><p>经过梯度压测，40并发时TPS达到拐点，所以40并发是本系统的最佳并发数。<br>最终在测试报告中，记录下20、30、40、50、60五组数据即</p><h2 id="再谈TPS、响应时间、并发"><a href="#再谈TPS、响应时间、并发" class="headerlink" title="再谈TPS、响应时间、并发"></a>再谈TPS、响应时间、并发</h2><ul><li>并发：真实并发用户和服务端并发用户  </li><li>服务端并发 &lt; 真实并发用户 因为请求会陆陆续续到达</li><li>支持600个服务端并发，到底多少个用户不知道。</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_12-09-20.png"></p><p>决定性能好坏的不是并发数 而是处理能力即TPS<br>系统性能受限于硬件配置:CPU、内存<br>当CPU使用率和内存使用率接近100%的时候，系统会达到极限</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_12-17-33.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>在压测工具中设置的并发数，其实就是服务端的并发数</li><li>不需要关注真实用户并发，关注服务端并发即可</li><li>一个系统的性能好坏，不能用支持的并发数来衡量，而是以TPS、响应时间来衡量 </li><li>性能测试没必要过分关注并发数，而是更应该关注业务性能指标TPS、响应时间</li><li>性能差的系统，比性能好的系统支持更高的并发数</li><li>如果想让一个系统支持更高的并发数，只需要将系统的响应时间变长即可</li></ul>]]></content>
    
    
    <categories>
      
      <category>PerformanceTesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PerformanceTesting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试基础知识</title>
    <link href="/2022/08/17/PerformanceTesting/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/08/17/PerformanceTesting/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="性能测试基础知识"><a href="#性能测试基础知识" class="headerlink" title="性能测试基础知识"></a>性能测试基础知识</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>通过一定的手段，在多并发情况下，获取被测系统的各项性能指标，验证被测系统在高并发下的处理能力、响应能力，稳定性等，能否满足预期。定位性能瓶颈，排查性能隐患，保障系统的质量，提升用户体验。</p><h3 id="什么样的系统需要做性能测试"><a href="#什么样的系统需要做性能测试" class="headerlink" title="什么样的系统需要做性能测试"></a>什么样的系统需要做性能测试</h3><ul><li>用户量大，PC比较高的系统</li><li>系统核心模块&#x2F;接口</li><li>业务逻辑&#x2F;算法比较复杂</li><li>促销&#x2F;活动推广</li></ul><h3 id="性能测试发生的场景"><a href="#性能测试发生的场景" class="headerlink" title="性能测试发生的场景"></a>性能测试发生的场景</h3><ul><li>新系统，新项目</li><li>线上性能问题验证和调优</li><li>新技术选型</li><li>性能容量评估和规划</li><li>日常系统性能[[[89ol;;l;.&#x2F;&#x2F;&#x2F;&#x2F;回归</li></ul><h3 id="性能测试指标-TPS"><a href="#性能测试指标-TPS" class="headerlink" title="性能测试指标-TPS"></a>性能测试指标-TPS</h3><h4 id="事务："><a href="#事务：" class="headerlink" title="事务："></a>事务：</h4><p>在性能测试领域里，衡量一个系统性能的好8pp0;-&#x3D;]坏，主要看的是单位时间内，系统可以处理多少业务量。 各个系统的业务各不相同，为了方便衡量业务的性能，需要在测试脚本中添加一对标签，测试工具统计单位时间内，标签的业务量，就可以统计出真实的业务量。脚本中的标签，就叫做事务。事务是用户定义的，事务是用户定义的，想测试什么业务的性能，就把该业务加到事务中。</p><h4 id="TPS-QPS"><a href="#TPS-QPS" class="headerlink" title="TPS&#x2F;QPS"></a>TPS&#x2F;QPS</h4><p>Transaction Per Second 每秒处理的事务数 </p><p>Request Per Second 每秒的请求数</p><p>测试“下单” 业务 将下单放到事务标签里</p><p>测试“添加购物车-下单” 整体业务 将两个接口加在一个事务标签里<br>;’[‘’[]]<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-02_14-10-08.png"></p><h3 id="性能测试指标-平均响应时间"><a href="#性能测试指标-平均响应时间" class="headerlink" title="性能测试指标-平均响应时间"></a>性能测试指标-平均响应时间</h3><p>一个请求的响应时间都包含哪些时间？<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_16-10-59.png"></p><p>响应时间&#x3D;网络传输的总时间+各组件业务处理时间&#x3D;RT(Response Time) </p><p>平均响应时间:在测试过程中，所有请求的平均耗时&#x3D;ART(Average Response Time)</p><h3 id="性能测试指标-TOP响应时间"><a href="#性能测试指标-TOP响应时间" class="headerlink" title="性能测试指标-TOP响应时间"></a>性能测试指标-TOP响应时间</h3><p>将所有请求的响应时间从大到小进行排序，计算指定比例的请求都是小于某个时间。<br>该指标统计的是大多数请求的耗时</p><ul><li>Tp90（90%响应时间）：90%的请求耗时都地狱某个响应时间</li><li>Tp95(95%响应时间):95%的请求耗时都低于某个响应时间 </li><li>Tp99(99%响应时间):99%的请求耗时都低于某个响应时间</li></ul><h3 id="其他性能测试指标"><a href="#其他性能测试指标" class="headerlink" title="其他性能测试指标"></a>其他性能测试指标</h3><h4 id="并发数-虚拟用户（Vuser）"><a href="#并发数-虚拟用户（Vuser）" class="headerlink" title="并发数&#x2F;虚拟用户（Vuser）"></a>并发数&#x2F;虚拟用户（Vuser）</h4><p>压测工具中设置的并发线程&#x2F;进程数量</p><h4 id="成功率"><a href="#成功率" class="headerlink" title="成功率"></a>成功率</h4><p>请求的成功率</p><h4 id="PV-Page-View"><a href="#PV-Page-View" class="headerlink" title="PV(Page View)"></a>PV(Page View)</h4><p>页面&#x2F;接口的访问量</p><h4 id="UV-Unique-Visitor"><a href="#UV-Unique-Visitor" class="headerlink" title="UV(Unique Visitor)"></a>UV(Unique Visitor)</h4><p>页面&#x2F;接口的每日唯一访客</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>网络中上行和下行的流量总和，吞吐量代表网络的流量，TPS越高，吞吐量越大</p><h3 id="TPS-响应时间和并发数的关系"><a href="#TPS-响应时间和并发数的关系" class="headerlink" title="TPS 响应时间和并发数的关系"></a>TPS 响应时间和并发数的关系</h3><p>响应时间单位为秒的情况下 </p><p>TPS &#x3D; 1 &#x2F; 响应时间 * 并发数</p><p>TPS &#x3D; 并发数 &#x2F; 响应时间</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-02_14-25-49.png"></p><h3 id="集合点"><a href="#集合点" class="headerlink" title="集合点"></a>集合点</h3><p>集合点是为了增加瞬间并发压力的一种机制，在脚本中增加一个标记，所有虚拟用户执行到标记处会进行等 待，等所有用户都到达后，再同时继续执行下一步操作。</p><p>优点:对服务器来说，会产生一种瞬间高并发</p><p>缺点:对服务器来说，平均压力会降低</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-02_14-30-00.png"></p><h4 id="什么时候需要加集合点呢？"><a href="#什么时候需要加集合点呢？" class="headerlink" title="什么时候需要加集合点呢？"></a>什么时候需要加集合点呢？</h4><p>根据业务来选择，如果业务场景是瞬间高并发类型的，如抢购、秒杀等，需要加集合点;<br>其他的场景都不需要加，一般加了集合点后，就不使用TPS来衡量系统性能 集合点功能要慎重选择，因为加了集合点后，系统的平均压力会降低</p><h3 id="性能监控指标"><a href="#性能监控指标" class="headerlink" title="性能监控指标"></a>性能监控指标</h3><h4 id="操作系统级别监控"><a href="#操作系统级别监控" class="headerlink" title="操作系统级别监控"></a>操作系统级别监控</h4><p>CPU使用率，内存使用率，网络IO(input&#x2F;output) 磁盘（read&#x2F;write&#x2F;util)</p><h4 id="中间件监控"><a href="#中间件监控" class="headerlink" title="中间件监控"></a>中间件监控</h4><p>连接数，长短连接，使用内存</p><h4 id="应用层监控"><a href="#应用层监控" class="headerlink" title="应用层监控"></a>应用层监控</h4><p>线程状态、JVM参数、GC频率、锁</p><h4 id="数据库监控"><a href="#数据库监控" class="headerlink" title="数据库监控"></a>数据库监控</h4><p>连接数、锁、缓存、内存、SQL效率</p><h3 id="性能测试流程"><a href="#性能测试流程" class="headerlink" title="性能测试流程"></a>性能测试流程</h3><ul><li>需求调研</li><li>测试计划</li><li>环境搭建</li><li>数据准备</li><li>测试脚本</li><li>压测执行</li><li>调优回归</li><li>测试报告</li></ul><h3 id="性能测试流程-需求调研"><a href="#性能测试流程-需求调研" class="headerlink" title="性能测试流程-需求调研"></a>性能测试流程-需求调研</h3><ul><li>项目背景</li><li>测试范围</li><li>业务逻辑&amp;数据流向</li><li>系统架构</li><li>配置信息</li><li>测试数据量（量级要一致）:实际生产环境中此业务在单个数据库的表中有多少数据量 –研发&#x2F;DBA</li><li>外部依赖 :依赖屏蔽掉&#x2F;mock</li><li>系统使用场景，业务比例</li><li>日常业务量</li><li>预期指标</li><li>上线时间</li></ul><h3 id="性能测试流程-测试计划"><a href="#性能测试流程-测试计划" class="headerlink" title="性能测试流程-测试计划"></a>性能测试流程-测试计划</h3><ul><li>项目描述</li><li>业务模型及性能指标</li><li>测试环境说明</li><li>测试资源</li><li>测试方法以及场景设计原则<ul><li>基准测试</li><li>单交易负载测试 </li><li>混合场景测试</li><li>高可用性测试</li><li>异常场景测试</li><li>稳定性测试</li><li>其他特殊场景 </li><li>测试进度安排及测试准则</li></ul></li></ul><h3 id="性能测试流程-环境搭建"><a href="#性能测试流程-环境搭建" class="headerlink" title="性能测试流程-环境搭建"></a>性能测试流程-环境搭建</h3><ul><li>测试机器硬件配置尽量和线上一致</li><li>系统版本与线上一致</li><li>测试环境部署线上最小单元模块</li><li>应用  中间件 数据库配置要与线上一致</li><li>其他特殊配置</li></ul><h3 id="性能测试流程-数据构造"><a href="#性能测试流程-数据构造" class="headerlink" title="性能测试流程-数据构造"></a>性能测试流程-数据构造</h3><p>业务接口</p><ul><li>适合数据表关系复杂</li><li>有点L数据完整性比较好</li></ul><p>存储过程</p><ul><li>适合表数量少，简单</li><li>优点L速度最快</li></ul><p>脚本导入</p><ul><li>适合数据逻辑复杂</li><li>自由度比较高</li></ul><p>数据量级</p><ul><li>测试数据</li><li>基础数据</li></ul><h3 id="性能测试流程-脚本编写"><a href="#性能测试流程-脚本编写" class="headerlink" title="性能测试流程-脚本编写"></a>性能测试流程-脚本编写</h3><ul><li>选择协议 </li><li>选择工具 </li><li>参数化</li><li>关联</li><li>检查点</li><li>事务判断</li></ul><h3 id="性能测试流程-压测执行"><a href="#性能测试流程-压测执行" class="headerlink" title="性能测试流程-压测执行"></a>性能测试流程-压测执行</h3><ul><li>分布式执行 </li><li>监控<ul><li>Linux </li><li>JVM </li><li>数据库</li></ul></li><li>收集测试结果 </li><li>数据分析</li><li>瓶颈定位</li></ul><h3 id="性能测试流程-调优回归"><a href="#性能测试流程-调优回归" class="headerlink" title="性能测试流程-调优回归"></a>性能测试流程-调优回归</h3><ul><li>性能调优需要整个团队完成 </li><li>反复尝试</li><li>回归验证</li><li>监控工具</li><li>全链路排查 </li><li>日志分析</li><li>模块隔离</li></ul><h3 id="性能测试工具"><a href="#性能测试工具" class="headerlink" title="性能测试工具"></a>性能测试工具</h3><ul><li>Loadrunner(功能强大、重量级、商业软件) </li><li>Jmeter(小巧灵活、轻量级、开源)</li><li>Ngrinder( 开源压测平台)</li><li>locust(Python开源框架)</li></ul><h3 id="现状和趋势"><a href="#现状和趋势" class="headerlink" title="现状和趋势"></a>现状和趋势</h3><ul><li>性能测试自动化、平台化</li><li>测试工具多样性、开源、二次开发</li><li>在高并发下验证功能正确性</li><li>线上线下相结合，线上发现问题，线下调优</li></ul><h2 id="APP客户端性能测试"><a href="#APP客户端性能测试" class="headerlink" title="APP客户端性能测试"></a>APP客户端性能测试</h2><ul><li>App客户端不存在并发用户的概念</li><li>APP客户端的性能测试，主要是在APP上进行业务操作，检测app占用手机的CPU、内存、流量、电量、<br>流畅度、稳定性等指标，从而判断app是否存在性能问题 n</li><li>业务操作可以通过手动执行，也可以通过工具，比如:<ul><li>Appium</li><li>fastmonkey(iOS) </li><li>monkey(Android)</li></ul></li></ul><h4 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h4><ul><li>App端的性能测试，更偏重于性能监控，常用的监控工具: </li><li>adb命令(Android)</li><li>xcode(ios)</li><li>腾讯GT工具(Android&#x2F; iOS )</li><li>滴滴DoraemonKit(<a href="https://github.com/didi/DoraemonKit">https://github.com/didi/DoraemonKit</a>) </li><li>腾讯perfdog( <a href="https://perfdog.qq.com/">https://perfdog.qq.com/</a> )</li></ul><h2 id="APP服务端性能测试"><a href="#APP服务端性能测试" class="headerlink" title="APP服务端性能测试"></a>APP服务端性能测试</h2><ul><li>APP服务端性能测试就是接口测试</li><li>通常按照接口文档写对应的接口测试脚本即可进行压测swagger </li><li>也可以通过抓包的方式抓取接口</li></ul><h4 id="常用APP抓包工具"><a href="#常用APP抓包工具" class="headerlink" title="常用APP抓包工具"></a>常用APP抓包工具</h4><p>• Fiddler (windows)<br>• Charles (mac&#x2F;windows&#x2F;linux)<br>• Wireshark (windows&#x2F;mac)</p><h2 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h2><ul><li>1、支持客户&#x2F;服务器模式。 </li><li>2、简单快速:客户向服务器请求服务时，只需传送请求方法和路径。<ul><li>请求方法常用的有GET、POST、PUT、 DELETE。每种方法规定了客户与服务器联系的类型不同。 </li><li>由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li></ul></li><li>3、灵活:HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 </li><li>4、无连接:无连接的含义是限制每次连接只处理一个请求。<ul><li>服务器处理完客户的请求，并收到客户的应答后， 即断开连接。</li><li>采用这种方式可以节省传输时间。数据量、Keep-Alive 避免了重新建立连接(超过 Keep-Alive 规定的时间，意外断电等情况除外)</li></ul></li><li>5、无状态:HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后 续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不 需要先前信息时它的应答就较快。</li></ul>]]></content>
    
    
    <categories>
      
      <category>PerformanceTesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PerformanceTesting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMeter常用操作</title>
    <link href="/2022/06/17/PerformanceTesting/JMeter%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/06/17/PerformanceTesting/JMeter%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="JMeter常用操作"><a href="#JMeter常用操作" class="headerlink" title="JMeter常用操作"></a>JMeter常用操作</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>JMeter，一个100%的纯Java桌面应用，由Apache组织的开放源代码项目，它是功能和性能测试的工具。具有高可扩展性、支持Web(HTTP&#x2F;HTTPS)、SOAP、FTP、JAVA 等多种协议的特点。</p><p>官方网站:<a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a> </p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><ul><li>1.下载好jdk,本机配置好环境变量</li><li>2.官网下载压缩包，在任意目录下解压</li><li>3.打开JMeter的bin目录下jmeter.properties,修改：<ul><li>language&#x3D;zh_CN</li><li>sampleresult.default.encoding&#x3D;utf-8</li></ul></li><li>4.进入到JMeter的bin目录下，双击jmeter.bat启动</li></ul><h2 id="JMeter主要元件"><a href="#JMeter主要元件" class="headerlink" title="JMeter主要元件"></a>JMeter主要元件</h2><ul><li>测试计划</li><li>线程组</li><li>采样器（sampler)</li><li>断言</li><li>监听器</li></ul><p>测试覆盖度<br>测试进度变更</p><h3 id="JMeter基本元件-线程组"><a href="#JMeter基本元件-线程组" class="headerlink" title="JMeter基本元件-线程组"></a>JMeter基本元件-线程组</h3><p>添加线程组并设置参数大小：测试计划 - 添加 - Threads - 线程组  </p><ul><li>循环次数：请求执行几次</li><li>线程组：一组用户</li><li>线程数：用户数</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-02-32.png">  </p><h3 id="JMeter基本元件-http请求"><a href="#JMeter基本元件-http请求" class="headerlink" title="JMeter基本元件-http请求"></a>JMeter基本元件-http请求</h3><p>添加http请求： 线程组下添加 - sample取样器 - http请求  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-05-56.png"></p><h3 id="JMeter超时处理"><a href="#JMeter超时处理" class="headerlink" title="JMeter超时处理"></a>JMeter超时处理</h3><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-08-29.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_17-10-40.png"></p><h3 id="查看结果树"><a href="#查看结果树" class="headerlink" title="查看结果树"></a>查看结果树</h3><p>添加查看结果树：监听器-查看结果树<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-10-01.png"></p><h3 id="响应断言-无论服务器返回的是什么都可以使用响应断言"><a href="#响应断言-无论服务器返回的是什么都可以使用响应断言" class="headerlink" title="响应断言 无论服务器返回的是什么都可以使用响应断言"></a>响应断言 无论服务器返回的是什么都可以使用响应断言</h3><p>添加-断言-响应断言<br>响应断言模式匹配规则</p><ul><li>包括（contains):如果响应中包含了指定的字符串，判断为成功，支持正则表达式</li><li>匹配（matches):如果响应完全匹配了指定的字符串，判断为成功，支持正则表达式</li><li>相等（equals):如果响应完全匹配指定的字符串，判断为成功，不支持正则表达式</li><li>子字符串（substring):如果响应中包含了指定的字符串，判断为成功，不支持正则表达式</li></ul><p>一般常用的测试字段是 响应文本 响应代码 响应头<br>注意：拷贝接口返回值到“测试模式”下进行断言时，要注意切换回text模式再复制，因为json有美化作用，可能有空格。导致断言失败</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-12-41.png"></p><h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><h3 id="json断言-针对返回数据是json的判断"><a href="#json断言-针对返回数据是json的判断" class="headerlink" title="json断言 针对返回数据是json的判断"></a>json断言 针对返回数据是json的判断</h3><p>添加断言-json断言</p><ul><li>Assert JSON Path exists : $.code  $ 被认为是接口返回的json字符串本身</li><li>Expected Value : 期望值 0 即代表 $.code &#x3D; 0</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_21-28-27.png"></p><h4 id="json路径表达式"><a href="#json路径表达式" class="headerlink" title="json路径表达式"></a>json路径表达式</h4><p>详细用法可参考 <a href="https://github.com/json-path/JsonPath">https://github.com/json-path/JsonPath</a></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_17-57-10.png"></p><h2 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h2><h3 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h3><p>测试计划-用户定义的变量  </p><p>调用参数的方法： ${参数名}  ${ip}</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-22-03.png"></p><h3 id="常用的参数化方式-随机数"><a href="#常用的参数化方式-随机数" class="headerlink" title="常用的参数化方式-随机数"></a>常用的参数化方式-随机数</h3><p>可以通过函数助手 生成各种函数  </p><p>生成随机数： _Random函数  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-27-02.png"></p><h3 id="常用的参数化方式-随机字符串"><a href="#常用的参数化方式-随机字符串" class="headerlink" title="常用的参数化方式-随机字符串"></a>常用的参数化方式-随机字符串</h3><p>生成随机字符串函数 _RandomString  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-29-50.png"></p><h3 id="常用的参数化方式-CSVRead-根据用户数来进行分配的"><a href="#常用的参数化方式-CSVRead-根据用户数来进行分配的" class="headerlink" title="常用的参数化方式-CSVRead 根据用户数来进行分配的"></a>常用的参数化方式-CSVRead 根据用户数来进行分配的</h3><p>从文本文件中读取数据 _CSVRead  </p><ul><li>绝对路径</li><li>相对路径 相对于当前脚本的路径 ${_CSVRead(a.text,0)} ${_CSVRead(test\a.text,0)}  </li><li>CSV取值机制：不论循环多少次，是根据用户数来进行分配的。 如果只有一个用户，那么循环四次也只会取文件里的第一行数据执行。如果有4个用户，循环四次，那么每个用户都会取一行数据，执行4次，总共执行16次。</li><li>使用场景:一个用户分一条数据 比如先注册 后登陆</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-35-01.png"></p><h3 id="参数化文件-CSVDataSetConfig-按照循环次数顺序分配，循环多少次分配多少条"><a href="#参数化文件-CSVDataSetConfig-按照循环次数顺序分配，循环多少次分配多少条" class="headerlink" title="参数化文件 CSVDataSetConfig 按照循环次数顺序分配，循环多少次分配多少条"></a>参数化文件 CSVDataSetConfig 按照循环次数顺序分配，循环多少次分配多少条</h3><p>添加CSVDataSetConfig: 线程组 -添加- 配置元件 - CSV Data Set Config  </p><ul><li>文件编码 有中文选择utf-8</li><li>变量名称 几列数据定义几个变量 username,password  引用${username} ${password}</li><li>忽略首行 数据从数据库导出来，首行为数据库字段，此时需要忽略首行</li><li>分隔符  文件参数之间用逗号分割就用逗号, 文件参数之间用tab键分割就用用\t分割</li><li>遇到文件结束是否再次循环  循环5次只有4条数据，true默认第5次重新从头读数据 那么遇到文件结束符停止线程 选择false</li><li>遇到文件结束符停止线程   如果遇到文件结束是否再次循环选择false 那么 遇到文件结束符停止线程 选择true 此时可以实现让所有的请求数据只跑一次，无论你设置了多少线程数多少循环次数</li></ul><table><thead><tr><th>Recycle on EOF</th><th>Stop thread on EOF</th><th>参数效果</th></tr></thead><tbody><tr><td>True</td><td>False</td><td>重复</td></tr><tr><td>False</td><td>True</td><td>唯一</td></tr></tbody></table><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_20-43-39.png"></p><h3 id="参数化函数"><a href="#参数化函数" class="headerlink" title="参数化函数"></a>参数化函数</h3><ul><li>CSV文件读取：${_CSVRead(D:\a.text,0,)}   </li><li>随机数：${_Random(1,100,)} </li><li>随机字符串：${_RandomString(8,adbcdefjjsjsjsjjsjsjs,)} </li><li>时间戳 ${_time(,)}  格式yyy-MM-dd HH:mm:ss</li><li>生成唯一UUID:${_UUID} 全局不重复的字符串</li></ul><p>上述函数都可以将结果保存到一个变量里，函数的最后一个参数为变量名称</p><h2 id="JMeter常用函数"><a href="#JMeter常用函数" class="headerlink" title="JMeter常用函数"></a>JMeter常用函数</h2><h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>关联是将服务器返回的数据通过一定的规则过滤出来，将其保存成参数，并且在后续脚本中使用这个参数进行逻辑处理</p><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>同时满足以下两个条件才需要关联</p><ul><li>服务器返回的数据是动态的</li><li>脚本中需要对这个动态数据做处理</li></ul><h4 id="关联场景"><a href="#关联场景" class="headerlink" title="关联场景"></a>关联场景</h4><p>1.选择商品品类 2.返回商品ID列表【100，101，102】 选择一个商品101 加购物车下单。 模拟真实用户，每次随机选择一个商品下单测试</p><h3 id="后置处理器-json提取器"><a href="#后置处理器-json提取器" class="headerlink" title="后置处理器-json提取器"></a>后置处理器-json提取器</h3><p>专门对json数据进行提取的后置处理器<br>一个提取器只能写一个路径，可以通过添加多个提取器来提取多个字段<br>添加 - 后置处理器- json提取器</p><ul><li>变量名称： 自定义的变量名称</li><li>json路径： jsonpath表达式</li><li>匹配数字：  0代表随机，n代表具体的数字，-1代表所有</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_10-36-01.png">  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_10-52-26.png">  </p><p>当 MathchNo为-1时。调试取样器里查看到返回数据组里的所有值</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_10-53-02.png"></p><p>返回数据：<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_12-15-07.png"></p><h3 id="添加调试取样器"><a href="#添加调试取样器" class="headerlink" title="添加调试取样器"></a>添加调试取样器</h3><p>线程组上添加 -  取样器 - debugsample<br>可以打印出来Jmeter运行过程中保存下来的参数，需要配合查看结果树使用</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_10-39-51.png"></p><h3 id="后置处理器-正则表达式提取器"><a href="#后置处理器-正则表达式提取器" class="headerlink" title="后置处理器-正则表达式提取器"></a>后置处理器-正则表达式提取器</h3><p>可以通过正则表达式来获取http请求返回的数据<br>引用名称：匹配后的结果，保存到一个参数中 如param</p><p>正则表达式三步走：</p><ul><li>1、拷贝目标数据和左右边界  保证能够精准识别到目标数据</li><li>2、把目标数据用括号括起来 </li><li>3、把目标数据用.+?代替 .匹配任何字符  + 匹配前面的正则表达式一次或多次 ？匹配前面出现的正则表达式零次或一次，第一次匹配到就停止</li></ul><h4 id="正则表达式在线测试小工具"><a href="#正则表达式在线测试小工具" class="headerlink" title="正则表达式在线测试小工具"></a>正则表达式在线测试小工具</h4><p><a href="https://c.runoob.com/front-end/854">https://c.runoob.com/front-end/854</a></p><ul><li>模板:$1$表示取匹配到的第一组数据，$2$为第二组 </li><li>匹配数字:当某组数据中包含多少个参数时，0代表随机，1代表该组的第一个参数，2表示第二 个。。。-1代表获取全部的参数，这个时候，引用名称就变成了参数数组，可以通过param_n来 获取指定的参数，当有多组数据时，第一组为param_1_g1，第二组为param_1_g2</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_12-08-25.png"></p><p>如果要匹配的数据没有右边界的话，可以用\n \r \n\r 试一试肯定有一个能取到</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_12-12-06.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_12-05-10.png"></p><p>常用正则表达式</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_11-10-52.png"></p><h2 id="JMeter结果统计"><a href="#JMeter结果统计" class="headerlink" title="JMeter结果统计"></a>JMeter结果统计</h2><h3 id="JMeter结果统计-聚合报告"><a href="#JMeter结果统计-聚合报告" class="headerlink" title="JMeter结果统计-聚合报告"></a>JMeter结果统计-聚合报告</h3><p>添加 -  监听器 - 聚合报告</p><ul><li>samples 样本 代表接口请求了多少次</li><li>Average 平均值 响应时间的平均值</li><li>Median  中位数  tp50响应时间</li><li>吞吐量  默认情况下表示每秒完成的请求</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_15-07-39.png"></p><h4 id="线程组设置"><a href="#线程组设置" class="headerlink" title="线程组设置"></a>线程组设置</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_15-32-35.png"></p><h2 id="JMeter图形化插件"><a href="#JMeter图形化插件" class="headerlink" title="JMeter图形化插件"></a>JMeter图形化插件</h2><p>插件官网地址：<a href="https://jmeter-plugins.org/install/Install/">https://jmeter-plugins.org/install/Install/</a>  </p><p>使用JMeter插件管理器，可以自动下载并安装插件，更加方便简单</p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><ul><li>1.下载插件管理器对应的jar包，然后放在JMeter的lib&#x2F;ext目录下，重启 </li><li>2，打开JMeter，选项Options-插件管理器Plugins Manager </li><li>3，勾选对应的插件，等待下载完成，点击apply，等待重启JMeter，即可使用</li></ul><h4 id="几个好用的插件"><a href="#几个好用的插件" class="headerlink" title="几个好用的插件:"></a>几个好用的插件:</h4><ul><li>1&gt; 3 Basic Graph:windows下可用的vu、实时tps和响应时间的插件 </li><li>2&gt; Custom JMeter Functions</li><li>3&gt; Random CSV Data Set Config</li><li>4&gt; PerfMon :服务端性能实时监控插件</li><li>5&gt; Custom Thread Groups </li><li>6&gt; Dummy Sampler</li></ul><h4 id="图形化插件的使用-TPS"><a href="#图形化插件的使用-TPS" class="headerlink" title="图形化插件的使用-TPS"></a>图形化插件的使用-TPS</h4><p>添加tps监听器:事务控制器 - 添加- 监听器 -  jp@gc – Transaction per Second</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_17-18-46.png"></p><h4 id="图形化插件的使用-平均响应时间"><a href="#图形化插件的使用-平均响应时间" class="headerlink" title="图形化插件的使用-平均响应时间"></a>图形化插件的使用-平均响应时间</h4><p>添加响应时间:事务控制器- 添加 - 监听器 - jp@gc – Response Times Over Time</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_17-19-21.png"></p><h4 id="图形化插件的使用-并发数"><a href="#图形化插件的使用-并发数" class="headerlink" title="图形化插件的使用-并发数"></a>图形化插件的使用-并发数</h4><p>添加响应时间:事务控制器- 添加 - 监听器 - jp@gc – Active Threads Over Time</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_17-03-27.png"></p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>JMeter中的定时器类似于LoadRunner中的pacing值和think_time </p><ul><li>1)定时器是在每个sampler(采样器)之前执行的，而不是之后 </li><li>2)定时器是有作用域的;当执行一个sampler之前时，所有当前作用域内的定时器都会被执行。 且所有的sampler执行前都会执行定时器 </li><li>3)如果希望定时器仅应用于其中一个sampler，则把该定时器作为子节点加入</li></ul><h3 id="常用的定时器"><a href="#常用的定时器" class="headerlink" title="常用的定时器"></a>常用的定时器</h3><ul><li>1，固定定时器:设置一个固定的延迟时间，单位ms 每隔1秒请求一次  <ul><li>步骤：添加 - 定时器 - 固定定时器</li></ul></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_17-42-43.png"></p><ul><li>2，同步定时器(synchronizing timer): 集合点  <ul><li>在该定时器处，使线程等待，一直到指定的线程个数达到 后，再一起释放。可以在瞬间制造出很大的压力。它和LoadRunner的集合点差不多的功能     </li><li>步骤：添加 - 定时器 - 同步定时器</li></ul></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_18-17-45.png"></p><ul><li>3、统一随机定时器<ul><li>使用场景：线上压测时，怕把系统压挂，所以上一个保险</li><li>步骤：添加 - 定时器 - 常量定时器  </li><li>目标吞吐量&#x2F;TPS ：可以跑一下看一下tps 然后再根据需求设置</li></ul></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_18-36-04.png"></p><h2 id="JMeter逻辑控制器"><a href="#JMeter逻辑控制器" class="headerlink" title="JMeter逻辑控制器"></a>JMeter逻辑控制器</h2><h3 id="常用的逻辑控制器"><a href="#常用的逻辑控制器" class="headerlink" title="常用的逻辑控制器"></a>常用的逻辑控制器</h3><h4 id="1、循环控制器"><a href="#1、循环控制器" class="headerlink" title="1、循环控制器:"></a>1、循环控制器:</h4><p>可以设置该控制器内的sampler执行的次数，循环次数与线程的循环次数各自独立。</p><ul><li>添加：线程组添加 - 控制器  - 循环控制器</li><li>应用场景：第一个接口执行一次，第二个接口执行三次，可以把第二个接口内添加到循环控制器</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_18-48-25.png"></p><h4 id="2、if控制器-根据判断条件决定是否执行该控制器内的请求，如果是字符串比较条件，参数和字符串都需要加引-号"><a href="#2、if控制器-根据判断条件决定是否执行该控制器内的请求，如果是字符串比较条件，参数和字符串都需要加引-号" class="headerlink" title="2、if控制器:根据判断条件决定是否执行该控制器内的请求，如果是字符串比较条件，参数和字符串都需要加引 号"></a>2、if控制器:根据判断条件决定是否执行该控制器内的请求，如果是字符串比较条件，参数和字符串都需要加引 号</h4><ul><li>条件格式:<br>${__jexl3(条件表达式)}<br>如:${__jexl3(${num} &gt; 10)}、 ${__jexl3(“${num}” &#x3D;&#x3D; “10”)}</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_18-59-43.png"></p><h4 id="3、仅一次控制器-该控制器内的请求只执行一次，无论线程循环多少次"><a href="#3、仅一次控制器-该控制器内的请求只执行一次，无论线程循环多少次" class="headerlink" title="3、仅一次控制器:该控制器内的请求只执行一次，无论线程循环多少次"></a>3、仅一次控制器:该控制器内的请求只执行一次，无论线程循环多少次</h4><p>使用场景： 登录</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_19-02-20.png"></p><h4 id="4、foreach控制器，可以遍历某个参数数组，循环获取数组中的参数。压测用的不多，接口测试时用。取出来多少数据，接下来调用的接口就会执行多少次"><a href="#4、foreach控制器，可以遍历某个参数数组，循环获取数组中的参数。压测用的不多，接口测试时用。取出来多少数据，接下来调用的接口就会执行多少次" class="headerlink" title="4、foreach控制器，可以遍历某个参数数组，循环获取数组中的参数。压测用的不多，接口测试时用。取出来多少数据，接下来调用的接口就会执行多少次"></a>4、foreach控制器，可以遍历某个参数数组，循环获取数组中的参数。压测用的不多，接口测试时用。取出来多少数据，接下来调用的接口就会执行多少次</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_19-32-43.png"></p><h2 id="配置元件-cookie管理器"><a href="#配置元件-cookie管理器" class="headerlink" title="配置元件 - cookie管理器"></a>配置元件 - cookie管理器</h2><p>JMeter自动处理cookie，只需要添加一个空的cookie处理器</p><h4 id="cookie-session-token"><a href="#cookie-session-token" class="headerlink" title="cookie session token"></a>cookie session token</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_14-15-01.png"></p><h4 id="cookie和session的关系"><a href="#cookie和session的关系" class="headerlink" title="cookie和session的关系"></a>cookie和session的关系</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-10_19-51-58.png"></p><h4 id="http-cookie管理器"><a href="#http-cookie管理器" class="headerlink" title="http cookie管理器"></a>http cookie管理器</h4><p>可以在浏览器中抓取到cookie信息，然后通过http cookie管理器为http请求添加cookie信息</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_14-41-10.png"></p><h4 id="JMeter中的cookie处理机制"><a href="#JMeter中的cookie处理机制" class="headerlink" title="JMeter中的cookie处理机制"></a>JMeter中的cookie处理机制</h4><p>和Loadrunner一样，Jmeter可以自动处理cookie,但是需要再线程组内添加一个空的cookie管理器</p><h2 id="配置元件-header管理器"><a href="#配置元件-header管理器" class="headerlink" title="配置元件 - header管理器"></a>配置元件 - header管理器</h2><p>添加 - 配置元件 - header管理器  JMeter需要手动处理token</p><ul><li>1.利用json提取器 提起登录接口的json值</li><li>2.利用HTTP信息头管理器 添加引用的token值</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_14-52-21.png"><br><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_14-53-04.png"></p><h2 id="JMeter上传和下载"><a href="#JMeter上传和下载" class="headerlink" title="JMeter上传和下载"></a>JMeter上传和下载</h2><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><ul><li>上传文件的本质是浏览器读取本地文件的内容，以二进制数据方式传输到服务端，服务端新建 一个文件，将获取到的数据复制到文件中。</li><li>POST请求</li><li>同请求一起发送文件里，填写文件名称，参数名称 </li><li>MIME类型: application&#x2F;octet-stream</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_15-54-49.png"></p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>下载文件的本质是服务端读取文件内容，传输到浏览器端，浏览器在本地新建一个 文件，将内容保存进去<br>不用真正的下载文件，只需要判断下载下来的文件size大于原来的文件size即可</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_16-14-57.png"></p><p>添加 - 断言 - 大小断言</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_16-11-29.png"></p><h2 id="JMeter请求webservice接口"><a href="#JMeter请求webservice接口" class="headerlink" title="JMeter请求webservice接口"></a>JMeter请求webservice接口</h2><p>关键点:</p><ul><li>1、添加http post请求 </li><li>2、添加header:Content-type:text&#x2F;xml</li><li>参考接口:<a href="http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx">http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx</a></li></ul><h4 id="1-添加http请求，请求方法为post-且xml格式的数据放在消息体数据中发起请求"><a href="#1-添加http请求，请求方法为post-且xml格式的数据放在消息体数据中发起请求" class="headerlink" title="1.添加http请求，请求方法为post,且xml格式的数据放在消息体数据中发起请求"></a>1.添加http请求，请求方法为post,且xml格式的数据放在消息体数据中发起请求</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_17-43-26.png"></p><h4 id="2-需要添加请求头"><a href="#2-需要添加请求头" class="headerlink" title="2.需要添加请求头"></a>2.需要添加请求头</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_17-47-47.png"></p><h4 id="3-接口返回数据会把入参返回，直接用入参做断言即可"><a href="#3-接口返回数据会把入参返回，直接用入参做断言即可" class="headerlink" title="3.接口返回数据会把入参返回，直接用入参做断言即可"></a>3.接口返回数据会把入参返回，直接用入参做断言即可</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_17-48-34.png"></p><h2 id="TCP取样器"><a href="#TCP取样器" class="headerlink" title="TCP取样器"></a>TCP取样器</h2><ul><li>服务器名称或IP:填写socket接口的ip</li><li>端口号:写socket接口的端口号</li><li>Re-use connection:是否重用链接，如果选择，同一个线程执行的所有请求都会使用一个tcp连接 </li><li>Re-use connection+close connection:每个请求结束后关闭连接</li><li>End of line byte value（行尾字节值）:socket接口返回的数据结尾标识符的ascii码</li></ul><p>添加 - 取样器 - TCP取样器</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_18-20-49.png"></p><p>断言</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-11_18-24-52.png"></p><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC(Java Data Base Connectivity,java数据库连接)是一种用于执行SQL语句的Java API， 可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了 一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_21-56-35.png"></p><h3 id="java代码连接数据库执行sql语句步骤"><a href="#java代码连接数据库执行sql语句步骤" class="headerlink" title="java代码连接数据库执行sql语句步骤"></a>java代码连接数据库执行sql语句步骤</h3><ul><li>注册驱动</li><li>通过用户名，密码，数据库url等信息，获取jdbc链接Connection </li><li>通过jdbc链接，对sql语句进行预编译，得到PreparedStatement </li><li>对sql语句进行传参数</li><li>执行sql语句</li><li>获取数据<ul><li>insert、update、delete返回的是操作的是数据行数</li><li>Select返回的ResultSet对象，可以获取对应的列值</li></ul></li><li>关闭链接<ul><li>关闭Connection</li><li>关闭PreparedStatement</li></ul></li></ul><h5 id="把mysql驱动包放到lib目录下后-还需要File-Project-Structure-Libraries-点击-选择java-把整个lib加入到工程依赖库里才能够识别驱动包"><a href="#把mysql驱动包放到lib目录下后-还需要File-Project-Structure-Libraries-点击-选择java-把整个lib加入到工程依赖库里才能够识别驱动包" class="headerlink" title="把mysql驱动包放到lib目录下后 还需要File - Project Structure - Libraries - 点击+ 选择java 把整个lib加入到工程依赖库里才能够识别驱动包"></a>把mysql驱动包放到lib目录下后 还需要File - Project Structure - Libraries - 点击+ 选择java 把整个lib加入到工程依赖库里才能够识别驱动包</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_22-52-59.png"></p><h2 id="JDBC请求"><a href="#JDBC请求" class="headerlink" title="JDBC请求"></a>JDBC请求</h2><h4 id="1-先添加数据库Jar包（2种方式）"><a href="#1-先添加数据库Jar包（2种方式）" class="headerlink" title="1.先添加数据库Jar包（2种方式）"></a>1.先添加数据库Jar包（2种方式）</h4><ul><li>拷贝mysql驱动包到jmeter&#x2F;lib目录下或者在测试计划处添加驱动包</li><li>驱动包和mysql版本匹配</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_14-17-36.png"></p><h4 id="2-配置数据库连接信息"><a href="#2-配置数据库连接信息" class="headerlink" title="2.配置数据库连接信息"></a>2.配置数据库连接信息</h4><p>添加 - 配置元件 - JDBC Connection Configuration<br>需要配置项</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_14-23-06.png"></p><p>URL:jdbc:mysql:&#x2F;&#x2F;{ip}:{port}&#x2F;{dbname}?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</p><h4 id="3-创建JDBC-sample发起JDBE-request请求"><a href="#3-创建JDBC-sample发起JDBE-request请求" class="headerlink" title="3.创建JDBC sample发起JDBE request请求"></a>3.创建JDBC sample发起JDBE request请求</h4><p>SQL语句类型</p><ul><li>select</li><li>update</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_14-26-20.png"></p><p>执行方式分类</p><ul><li>普通SQL</li><li>预编译SQL:sql语句中的数值用？代替<ul><li>Parameter values:代替sql语句中问号的数据</li><li>Parameter types:数据库字段数据类型，如VARCHAR INTEGER</li><li>Variable Names:变量名称，跟SQL语句中查询字段数量保持一致</li></ul></li></ul><h4 id="Prepared-Update-Statement-预编译-做压测时性能更好"><a href="#Prepared-Update-Statement-预编译-做压测时性能更好" class="headerlink" title="Prepared Update Statement 预编译 做压测时性能更好"></a>Prepared Update Statement 预编译 做压测时性能更好</h4><p>对于性能要求比较高的情况下，为了提高sql语句执行效率，需要做参数化的字段写成？</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_17-51-14.png"></p><h4 id="Prepared-Select-Statement"><a href="#Prepared-Select-Statement" class="headerlink" title="Prepared Select Statement"></a>Prepared Select Statement</h4><p>查询出来的字段可以保存在变量中<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_18-07-21.png"></p><p>字段已保存为变量<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_18-09-25.png"></p><h2 id="beanshell"><a href="#beanshell" class="headerlink" title="beanshell"></a>beanshell</h2><ul><li>BeanShell是一种完全符合Java语法规范的脚本语言,并且又拥有自己的一些语法和方法;</li><li>BeanShell是一种松散类型的脚本语言(这点和JS类似);</li><li>BeanShell是用Java写成的,一个小型的、免费的、可以下载的、嵌入式的Java源代码解释器,具</li><li>有对象脚本语言特性,非常精简的解释器jar文件大小为175k。</li><li>BeanShell执行标准Java语句和表达式,另外包括一些脚本命令和语法。</li></ul><h3 id="JMeter常用beanshell"><a href="#JMeter常用beanshell" class="headerlink" title="JMeter常用beanshell"></a>JMeter常用beanshell</h3><ul><li>前置处理器:BeanShell PreProcesser </li><li>采样器:BeanShell Sampler</li><li>后置处理器:BeanShell PostProcesser </li><li>断言:BeanShell断言</li></ul><h3 id="BeanShell内置变量"><a href="#BeanShell内置变量" class="headerlink" title="BeanShell内置变量"></a>BeanShell内置变量</h3><p>BeanShell脚本中不用定义，可以直接使用的变量，常用的内置变量和方法如下 </p><ul><li>log:写日志到控制台和jmeter.log，如log.info(“xxxxx”); </li><li>vars:操作jmeter变量</li><li>vars.get(“skuId”);从jmeter中获取${skuId}变量的值</li><li>vars.put(“name”,”test”);创建新变量name的值为test 或者修改name属性的值为test</li><li>prev:后置处理器里使用 获取前面sampler返回的信息 </li><li>getResponseDataAsString():获取响应信息 </li><li>getResponseCode():获取响应code</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_19-55-41.png"></p><p>更多内置变量参考 <a href="https://jmeter.apache.org/">https://jmeter.apache.org/</a></p><h4 id="BeanShell使用方式一-BeanShell面板上写脚本"><a href="#BeanShell使用方式一-BeanShell面板上写脚本" class="headerlink" title="BeanShell使用方式一 BeanShell面板上写脚本"></a>BeanShell使用方式一 BeanShell面板上写脚本</h4><p>需求:</p><ul><li>1、调用接口获取sku信息 </li><li>2、判断库存，如果库存大于500，调用buy接口购买10个商品，否则购买5个商品<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取接口返回的库存值</span><br><span class="hljs-built_in">String</span> myStock = vars.<span class="hljs-keyword">get</span>(“p_stock”); <span class="hljs-comment">// 转换为整数</span><br><span class="hljs-built_in">int</span> iStock = Integer.parseInt(myStock); <span class="hljs-comment">// 判断库存</span><br><span class="hljs-keyword">if</span> (iStock &gt; <span class="hljs-number">500</span>)&#123;<br><span class="hljs-comment">// 重新保存参数</span><br>vars.put(“buyNum”,<span class="hljs-string">&quot;10&quot;</span>); &#125;<span class="hljs-keyword">else</span>&#123;<br>vars.put(“buyNum”,”<span class="hljs-number">5</span>”)<br></code></pre></td></tr></table></figure></li></ul><h5 id="1-通过json提取器获取前一个接口的返回值"><a href="#1-通过json提取器获取前一个接口的返回值" class="headerlink" title="1.通过json提取器获取前一个接口的返回值"></a>1.通过json提取器获取前一个接口的返回值</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-24-19.png"></p><h5 id="2-在后一个接口的预处理程序中-获取返回值并进行相应逻辑处理"><a href="#2-在后一个接口的预处理程序中-获取返回值并进行相应逻辑处理" class="headerlink" title="2.在后一个接口的预处理程序中 获取返回值并进行相应逻辑处理"></a>2.在后一个接口的预处理程序中 获取返回值并进行相应逻辑处理</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-21-46.png"></p><h5 id="3-在后一个接口中引用处理后的值作为入参"><a href="#3-在后一个接口中引用处理后的值作为入参" class="headerlink" title="3.在后一个接口中引用处理后的值作为入参"></a>3.在后一个接口中引用处理后的值作为入参</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-18-03.png"></p><h3 id="BeanShell使用方式二-引用外部java源文件"><a href="#BeanShell使用方式二-引用外部java源文件" class="headerlink" title="BeanShell使用方式二 引用外部java源文件"></a>BeanShell使用方式二 引用外部java源文件</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 引入源代码</span><br>source(“D:/Md5Util.java”);<br><span class="hljs-comment">// 生成随机手机号,</span><br><span class="hljs-built_in">String</span> phone = <span class="hljs-string">&quot;135<span class="hljs-subst">$&#123;__Random(<span class="hljs-number">10000000</span>,<span class="hljs-number">99999999</span>,myPhone)&#125;</span>&quot;</span>;  # 可以直接调用JMeter内置函数<br><span class="hljs-built_in">String</span> code = <span class="hljs-string">&quot;testfan&quot;</span>;<br><span class="hljs-comment">// 生成时间戳</span><br><span class="hljs-built_in">String</span> time = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;__time(,myTime)&#125;</span>&quot;</span>;<br><span class="hljs-comment">// 调用外部函数进行加密</span><br><span class="hljs-built_in">String</span> md5 = Md5Util.getMd5Hex(phone+code+time); # 直接调用文件中的函数<br><span class="hljs-comment">// 将数据另存为新的变量</span><br>vars.put(<span class="hljs-string">&quot;phone&quot;</span>,phone);<br>vars.put(<span class="hljs-string">&quot;md5&quot;</span>,md5);<br>vars.put(<span class="hljs-string">&quot;time&quot;</span>,time);<br></code></pre></td></tr></table></figure><h5 id="1-添加前置beanshell处理器-处理入参"><a href="#1-添加前置beanshell处理器-处理入参" class="headerlink" title="1.添加前置beanshell处理器 处理入参"></a>1.添加前置beanshell处理器 处理入参</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-44-30.png"></p><h5 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2.发起请求"></a>2.发起请求</h5><h3 id="BeanShell使用方式三-调用jar包"><a href="#BeanShell使用方式三-调用jar包" class="headerlink" title="BeanShell使用方式三-调用jar包"></a>BeanShell使用方式三-调用jar包</h3><p>调用jar包</p><h5 id="1、测试计划，Add-directory-or-jar-to-classpath"><a href="#1、测试计划，Add-directory-or-jar-to-classpath" class="headerlink" title="1、测试计划，Add directory or jar to classpath"></a>1、测试计划，Add directory or jar to classpath</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-45-47.png"></p><h5 id="2、import-所需要的类名"><a href="#2、import-所需要的类名" class="headerlink" title="2、import 所需要的类名"></a>2、import 所需要的类名</h5><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span> com.lee.util.Md5Util  jar包需要导入<br><span class="hljs-comment">// 生成随机手机号,8</span><br><span class="hljs-built_in">String</span> phone = <span class="hljs-string">&quot;135<span class="hljs-subst">$&#123;__Random(<span class="hljs-number">10000000</span>,<span class="hljs-number">99999999</span>,myPhone)&#125;</span>&quot;</span>; <span class="hljs-built_in">String</span> code = <span class="hljs-string">&quot;testfan&quot;</span>;<br><span class="hljs-comment">// 生成时间戳</span><br><span class="hljs-built_in">String</span> time = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;__time(,myTime)&#125;</span>&quot;</span>;<br><span class="hljs-comment">// 调用外部函数进行加密</span><br><span class="hljs-built_in">String</span> md5 = Md5Util.getMd5Hex(phone+code+time);<br><span class="hljs-comment">// 将数据另存为新的变量</span><br>vars.put(<span class="hljs-string">&quot;phone&quot;</span>,phone);<br>vars.put(<span class="hljs-string">&quot;md5&quot;</span>,md5)<br></code></pre></td></tr></table></figure><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-58-54.png"></p><h3 id="beanshell断言"><a href="#beanshell断言" class="headerlink" title="beanshell断言"></a>beanshell断言</h3><p>内置变量</p><ul><li>Failure:是否失败，boolean类型 </li><li>FailureMessage:失败日志，在断言失败时显示<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> iStock = <span class="hljs-type">Integer</span>.parseInt(vars.<span class="hljs-keyword">get</span>(&quot;p_stock&quot;)); <span class="hljs-keyword">if</span> (iStock &gt; <span class="hljs-number">1500</span>)&#123;<br>Failure = <span class="hljs-keyword">true</span>;<br>FailureMessage = &quot;库存数量超过了1500&quot;;<br>// ResponseData是服务器返回的byte[]类型的数据<br>// 如果想打印接口返回值，必须转换为String类型的，用<span class="hljs-built_in">new</span> String(ResponseData) <br><span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(<span class="hljs-built_in">new</span> String(ResponseData));<br>//打印当前请求的url, SamplerData是String类型的数据 <br><span class="hljs-keyword">log</span>.<span class="hljs-keyword">info</span>(SamplerData);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="json提取器提取出返回值"><a href="#json提取器提取出返回值" class="headerlink" title="json提取器提取出返回值"></a>json提取器提取出返回值</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_20-24-19.png"></p><h5 id="断言-beanshell断言-对json提取器取出的值进行逻辑判断"><a href="#断言-beanshell断言-对json提取器取出的值进行逻辑判断" class="headerlink" title="断言-beanshell断言 对json提取器取出的值进行逻辑判断"></a>断言-beanshell断言 对json提取器取出的值进行逻辑判断</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_21-20-01.png"></p><h3 id="BeanShell写数据到文件"><a href="#BeanShell写数据到文件" class="headerlink" title="BeanShell写数据到文件"></a>BeanShell写数据到文件</h3><ul><li>1、调用登录接口，获取token值 </li><li>2、将token值保存到一个文件里<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">String</span> line = vars.<span class="hljs-keyword">get</span>(“userName<span class="hljs-string">&quot;)+&quot;</span>,<span class="hljs-string">&quot;+vars.get(“token&quot;</span>); <span class="hljs-meta"># 拼接需要写入的数据</span><br><span class="hljs-keyword">try</span> &#123;<br>    BufferedWriter writer = <span class="hljs-keyword">new</span><span class="hljs-type"></span> BufferedWriter(<span class="hljs-keyword">new</span><span class="hljs-type"></span> FileWriter(“C:<span class="hljs-type"></span>\\output.txt”,<span class="hljs-literal">true</span>));<span class="hljs-comment">//追加，否则覆盖 </span><br>    writer.write(line);<br>    writer.newLine();<span class="hljs-comment">//换行</span><br>    writer.close();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    e.printStackTrace(); <br>    &#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="仅红字标出部分需要替换"><a href="#仅红字标出部分需要替换" class="headerlink" title="仅红字标出部分需要替换"></a>仅红字标出部分需要替换</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_21-30-16.png"></p><h2 id="JMeter中的JAVA请求"><a href="#JMeter中的JAVA请求" class="headerlink" title="JMeter中的JAVA请求"></a>JMeter中的JAVA请求</h2><h3 id="1-使用JMeter运行java脚本，需要用到Jmeter提供的框架jar包（分别在jmeter目录下的lib和ext目录下）"><a href="#1-使用JMeter运行java脚本，需要用到Jmeter提供的框架jar包（分别在jmeter目录下的lib和ext目录下）" class="headerlink" title="1.使用JMeter运行java脚本，需要用到Jmeter提供的框架jar包（分别在jmeter目录下的lib和ext目录下）"></a>1.使用JMeter运行java脚本，需要用到Jmeter提供的框架jar包（分别在jmeter目录下的lib和ext目录下）</h3><ul><li>ApacheJMeter_core.jar</li><li>ApacheJMeter_java.jar</li><li>slf4j-api-1.7.25.jar </li><li>jorphan.jar </li><li>oro-2.0.8.jar (高版本JMeter需要额外加入)</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_13-11-57.png"></p><h3 id="2-Jmeter脚本要点"><a href="#2-Jmeter脚本要点" class="headerlink" title="2.Jmeter脚本要点"></a>2.Jmeter脚本要点</h3><h5 id="1，实现JavaSamplerClient接口-规范定义在java接口中，JMeter通过接口来执行脚本"><a href="#1，实现JavaSamplerClient接口-规范定义在java接口中，JMeter通过接口来执行脚本" class="headerlink" title="1，实现JavaSamplerClient接口 规范定义在java接口中，JMeter通过接口来执行脚本"></a>1，实现JavaSamplerClient接口 规范定义在java接口中，JMeter通过接口来执行脚本</h5><h5 id="2，四个方法"><a href="#2，四个方法" class="headerlink" title="2，四个方法:"></a>2，四个方法:</h5><ul><li>getDefaultParameters:获取参数，设置的参数会在Jmeter的参数面板上显示出来 </li><li>setupTest:初始化方法，每个并发用户只执行一次，跟LR里的init方法一样的，用于建立链接 </li><li>runTest:每个并发用户执行N次，处理业务 </li><li>teardownTest:结束方法，每个并发用户只执行一次，LR里的end方法是一样的，用于释放资源</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_13-43-19.png"></p><p>打成jar包</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_13-37-32.png"></p><h5 id="3，导出JMeter的java脚本"><a href="#3，导出JMeter的java脚本" class="headerlink" title="3，导出JMeter的java脚本"></a>3，导出JMeter的java脚本</h5><ul><li>1&gt; 将导出的xxx.jar 和xxx_lib文件夹放到JMeter的lib&#x2F;ext目录下  重启JMeter</li><li>2&gt; 添加JAVA请求，类名称选择jar包，运行</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_13-40-01.png"></p><h3 id="JAVA请求脚本参数化"><a href="#JAVA请求脚本参数化" class="headerlink" title="JAVA请求脚本参数化"></a>JAVA请求脚本参数化</h3><h5 id="1-需要现在代码里定义"><a href="#1-需要现在代码里定义" class="headerlink" title="1.需要现在代码里定义"></a>1.需要现在代码里定义</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_14-05-05.png"></p><h5 id="2-重新打成jar包放到JMeter的lib目录下重启JMeter后可以看到入参"><a href="#2-重新打成jar包放到JMeter的lib目录下重启JMeter后可以看到入参" class="headerlink" title="2.重新打成jar包放到JMeter的lib目录下重启JMeter后可以看到入参"></a>2.重新打成jar包放到JMeter的lib目录下重启JMeter后可以看到入参</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_14-03-06.png"></p><h5 id="3-对入参进行CSV参数化，从文件中读取数据"><a href="#3-对入参进行CSV参数化，从文件中读取数据" class="headerlink" title="3.对入参进行CSV参数化，从文件中读取数据"></a>3.对入参进行CSV参数化，从文件中读取数据</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_14-06-13.png"></p><h5 id="4-JMeter参数化获取的数据保存在JavaSamplerContext中，调用其方法获取即可"><a href="#4-JMeter参数化获取的数据保存在JavaSamplerContext中，调用其方法获取即可" class="headerlink" title="4.JMeter参数化获取的数据保存在JavaSamplerContext中，调用其方法获取即可"></a>4.JMeter参数化获取的数据保存在JavaSamplerContext中，调用其方法获取即可</h5><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_14-20-30.png"></p><p>Java编写sql查询脚本在JMeter运行</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_18-21-51.png"></p><h2 id="websocket请求"><a href="#websocket请求" class="headerlink" title="websocket请求"></a>websocket请求</h2><h3 id="websocket请求应用场景：客服客服消息发送"><a href="#websocket请求应用场景：客服客服消息发送" class="headerlink" title="websocket请求应用场景：客服客服消息发送"></a>websocket请求应用场景：客服客服消息发送</h3><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-05-10.png"></p><h4 id="插件库里下载-Websocket-samples-by-Peter-Doorm"><a href="#插件库里下载-Websocket-samples-by-Peter-Doorm" class="headerlink" title="插件库里下载 Websocket samples by Peter Doorm"></a>插件库里下载 Websocket samples by Peter Doorm</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-07-03.png"></p><h4 id="1-添加-取样器-websocket-open-connection"><a href="#1-添加-取样器-websocket-open-connection" class="headerlink" title="1.添加 - 取样器 - websocket open connection"></a>1.添加 - 取样器 - websocket open connection</h4><ul><li>内网选择ws</li><li>公网选择wss<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-09-15.png"></li></ul><h4 id="2-发送匹配请求-提取返回值里的msgId-给后续接口调用"><a href="#2-发送匹配请求-提取返回值里的msgId-给后续接口调用" class="headerlink" title="2.发送匹配请求 提取返回值里的msgId 给后续接口调用"></a>2.发送匹配请求 提取返回值里的msgId 给后续接口调用</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-10-23.png"></p><h4 id="3-循环发送消息和接收服务器回执消息5次-间隔300ms发送一次"><a href="#3-循环发送消息和接收服务器回执消息5次-间隔300ms发送一次" class="headerlink" title="3.循环发送消息和接收服务器回执消息5次 间隔300ms发送一次"></a>3.循环发送消息和接收服务器回执消息5次 间隔300ms发送一次</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-11-20.png"></p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-11-49.png"></p><h4 id="4-关闭连接"><a href="#4-关闭连接" class="headerlink" title="4.关闭连接"></a>4.关闭连接</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-17_21-12-07.png"></p>]]></content>
    
    
    <categories>
      
      <category>PerformanceTesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PerformanceTesting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>魔术方法</title>
    <link href="/2022/04/17/python/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <url>/2022/04/17/python/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h1><h2 id="new-方法"><a href="#new-方法" class="headerlink" title="__new__方法"></a>__new__方法</h2><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">__init__:</span>类创建对象的时候会触发<br><span class="hljs-symbol">__call__:</span>可以让对象像函数一样调用（对象加括号去调用的时候会出触发）<br><span class="hljs-symbol">__new__:</span>在通过类创建对象的时候调用！先调用<span class="hljs-built_in">new</span>方法再调用init方法<br></code></pre></td></tr></table></figure><h4 id="注意点：一般情况下不要去重写new方法，实现单例模式的时候可以重写new方法来实现"><a href="#注意点：一般情况下不要去重写new方法，实现单例模式的时候可以重写new方法来实现" class="headerlink" title="注意点：一般情况下不要去重写new方法，实现单例模式的时候可以重写new方法来实现"></a>注意点：一般情况下不要去重写new方法，实现单例模式的时候可以重写new方法来实现</h4><h4 id="如果重写了new方法，一定要调用父类的new方法，并将结果返回"><a href="#如果重写了new方法，一定要调用父类的new方法，并将结果返回" class="headerlink" title="如果重写了new方法，一定要调用父类的new方法，并将结果返回"></a>如果重写了new方法，一定要调用父类的new方法，并将结果返回</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">sel, name, age</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------init方法--------&quot;</span>)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls)<br><br>m = Mytest(<span class="hljs-number">111</span>, <span class="hljs-number">22</span>)<br><span class="hljs-built_in">print</span>(m)<br><br>==========运行结果=============<br>--------init方法--------<br>&lt;__main__.Mytest <span class="hljs-built_in">object</span> at <span class="hljs-number">0x103412850</span>&gt;<br></code></pre></td></tr></table></figure><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>无论创建几次对象只会创建一次对象</p><p>注意：父类是单例模式，子类继承了父类如果不重写__new__则子类也是单例模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 经典的单例模式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>:<br>    __obj = <span class="hljs-literal">None</span> <span class="hljs-comment"># 设置成私有属性无法修改</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.obj:<br>            <span class="hljs-comment"># 如果没有创建过对象，就调用父类的new方法创建一个</span><br>            cls.obj = <span class="hljs-built_in">super</span>().__new__(cls)<br>            <span class="hljs-keyword">return</span> cls.obj<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果创建了，则把第一次的对象返回</span><br>            <span class="hljs-keyword">return</span> cls.obj<br><br><br>m1 = MyClass()<br>m2 = MyClass()<br>m3 = MyClass()<br>m4 = MyClass()<br>m5 = MyClass()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(m1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(m2))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(m3))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(m4))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(m5))<br><br></code></pre></td></tr></table></figure><h3 id="单例模式应用场景"><a href="#单例模式应用场景" class="headerlink" title="单例模式应用场景"></a>单例模式应用场景</h3><p>应用的目的：减少程序的内存开销</p><p>web自动化框架，接口自动化框架：</p><p>日志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 会创建出多个日志对象 可以优化</span><br><span class="hljs-keyword">import</span> logging<br><br>res = logging.getLogger(<span class="hljs-string">&quot;musen&quot;</span>)<br>res2 = logging.getLogger(<span class="hljs-string">&quot;musen2&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(res2))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> requests.sessions <span class="hljs-keyword">import</span> Session<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySession</span>(<span class="hljs-title class_ inherited__">Session</span>):<br>    __obj = <span class="hljs-literal">None</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__obj:<br>            <span class="hljs-comment"># 如果没有创建对象，就调用父类的new方法创建一个</span><br>            cls.obj = <span class="hljs-built_in">super</span>().__new__(cls)<br>            <span class="hljs-keyword">return</span> cls.__obj<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果创建了，则把第一次的对象返回</span><br>            <span class="hljs-keyword">return</span> cls.__obj<br><br><br>s = MySession()<br>b = MySession()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(s))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(b)) <span class="hljs-comment"># 多次创建也只创建一个对象</span><br></code></pre></td></tr></table></figure><h2 id="上下文管理器"><a href="#上下文管理器" class="headerlink" title="上下文管理器"></a>上下文管理器</h2><p>上下文管理器的概念：</p><p>上下文管理器是一个python对象，为操作提供了额外的上下文信息。这种额外的信息，在使用with语句初始化上下文，以及完成with块中的所有代码。采用可调用的形式。<br>with后面跟的是一个上下文管理器对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">__enter__(<span class="hljs-variable language_">self</span>)<br>输入与此对象相关的运行时上下文，如果存在的话，<span class="hljs-keyword">with</span>语句将绑定该方法的返回值到该语句的<span class="hljs-keyword">as</span>子句中指定的目标<br>__exit__(<span class="hljs-variable language_">self</span>, exc_type, exc_val, exc_tb)<br>- exc_type:异常类型<br>- exc_val:异常值<br>- exc_tb：异常回溯追踪<br><br><span class="hljs-keyword">with</span>后面跟的是一个上下文管理器<br><br><span class="hljs-built_in">object</span>.__enter__(<span class="hljs-variable language_">self</span>)返回的对象返回给f<br><br><span class="hljs-keyword">with</span>代码执行完后会触发<span class="hljs-built_in">object</span>.__exit__(<span class="hljs-variable language_">self</span>,exc_type.exc_val,exc_tb)  发生异常自动捕获异常信息传给exit方法<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>是python内置实现的一个上下文管理器<br></code></pre></td></tr></table></figure><h4 id="上下文管理器协议"><a href="#上下文管理器协议" class="headerlink" title="上下文管理器协议"></a>上下文管理器协议</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myopen</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--enter----&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;python&quot;</span>  <span class="hljs-comment"># 返回的内容被f接收</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---exit----&quot;</span>)<br><br><br>o = Myopen()<br><br><span class="hljs-comment"># with python中的关键字 开启一个对象的上下文管理器协议</span><br><span class="hljs-keyword">with</span> o <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;with中的代码&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;f:&quot;</span>, f)<br><br>============执行结果===========<br>--enter----<br><span class="hljs-keyword">with</span>中的代码<br>f: python<br>---exit----<br></code></pre></td></tr></table></figure><h4 id="自己实现一个文件操作的上下文管理器类代替open"><a href="#自己实现一个文件操作的上下文管理器类代替open" class="headerlink" title="自己实现一个文件操作的上下文管理器类代替open"></a>自己实现一个文件操作的上下文管理器类代替open</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myopen</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,filename,mode,encoding = <span class="hljs-string">&#x27;utf8&#x27;</span></span>):<br>        <span class="hljs-variable language_">self</span>.filename = filename<br>        <span class="hljs-variable language_">self</span>.mode = mode<br>        <span class="hljs-variable language_">self</span>.encoding = encoding<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__enter__</span>(<span class="hljs-params">self</span>):<br>        <br>        <span class="hljs-variable language_">self</span>.f = <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.filename,<span class="hljs-variable language_">self</span>.mode,encoding=<span class="hljs-variable language_">self</span>.encoding)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.f   <span class="hljs-comment">#跟with open一样返回一个文件操作的句柄 返回的内容被f接收</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__exit__</span>(<span class="hljs-params">self, exc_type, exc_val, exc_tb</span>):<br>        <span class="hljs-variable language_">self</span>.f.close() <span class="hljs-comment">#实现文件关闭</span><br>        <span class="hljs-built_in">print</span>(exc_type)<br>        <span class="hljs-built_in">print</span>(exc_val)<br>        <span class="hljs-built_in">print</span>(exc_tb)<br><br><br><span class="hljs-keyword">with</span> Myopen(<span class="hljs-string">&quot;test.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>,) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f)<br>    content = f.read()<br>    <span class="hljs-built_in">print</span>(content)<br>    <span class="hljs-built_in">print</span>(name)  <span class="hljs-comment">#打印报错信息</span><br><br><span class="hljs-keyword">with</span> Myopen(<span class="hljs-string">&quot;test2.txt&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>,) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-built_in">print</span>(f)<br><br></code></pre></td></tr></table></figure><h2 id="str-方法"><a href="#str-方法" class="headerlink" title="__str__方法"></a>__str__方法</h2><h4 id="在打印类对象的时候会被调用-该方法必须有return，第二返回值必须为字符串"><a href="#在打印类对象的时候会被调用-该方法必须有return，第二返回值必须为字符串" class="headerlink" title="在打印类对象的时候会被调用,该方法必须有return，第二返回值必须为字符串"></a>在打印类对象的时候会被调用,该方法必须有return，第二返回值必须为字符串</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, gender</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.gender = gender<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在打印类对象的时候会被调用</span><br><span class="hljs-string">        :return: 1、该方法必须有return，第二返回值必须为字符串</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.name<br><br><br>m = Myclass(<span class="hljs-string">&quot;ZZ&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;NV&quot;</span>)<br>m1 = Myclass(<span class="hljs-string">&quot;ZC&quot;</span>, <span class="hljs-number">19</span>, <span class="hljs-string">&quot;NAN&quot;</span>)<br><span class="hljs-built_in">print</span>(m)<br><span class="hljs-built_in">print</span>(m1)<br><br>==============执行结果===============<br>ZZ<br>ZC<br></code></pre></td></tr></table></figure><h2 id="算术运算的魔术方法实现"><a href="#算术运算的魔术方法实现" class="headerlink" title="算术运算的魔术方法实现"></a>算术运算的魔术方法实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python中只能同类型的数据之间相加</span><br><span class="hljs-comment"># __add__ 可以对所在类创建的对象进行 + 操作</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mystr</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,data</span>):<br>        <span class="hljs-variable language_">self</span>.data = data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment">#打印类里属性具体的值</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.data<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__add__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相加时触发了这个__add__方法&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>.data)<br>        <span class="hljs-built_in">print</span>(other.data)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.data +other.data<br>        <span class="hljs-comment">#return self.data + other.data 两种写法都可以</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__sub__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;相减时触发了__sub__减法&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-built_in">print</span>(other)<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.data.replace(other.data,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">#把第二个数替换为空字符串</span><br><br>s1 = Mystr(<span class="hljs-string">&#x27;sss111&#x27;</span>)<br>s2 = Mystr(<span class="hljs-string">&#x27;33SSSS&#x27;</span>)<br>s3 = Mystr(s1 +s2)<br><span class="hljs-built_in">print</span>(s3)<br>s4 = Mystr(s1-s2)<br><span class="hljs-built_in">print</span>(s4)<br></code></pre></td></tr></table></figure><h2 id="构造器和析构器"><a href="#构造器和析构器" class="headerlink" title="构造器和析构器"></a>构造器和析构器</h2><ul><li>构造器：__new__方法 + __init__方法 组成构造器</li><li>析构器：__del__方法 删除数据引用 数据清理<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>:<br>  <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br>    print(<span class="hljs-string">&quot;----)</span><br><span class="hljs-string">  def __del__(self):</span><br><span class="hljs-string">    print(&quot;</span>----del<span class="hljs-string">&quot;)</span><br><span class="hljs-string">m = Myclass()</span><br><span class="hljs-string">del m</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>面向对象编程的三大特征：封装 继承  多态</p><p>&#x3D;&#x3D;封装&#x3D;&#x3D;：将数据和方法放在一个类中就构成了封装</p><p>&#x3D;&#x3D;继承&#x3D;&#x3D;：python中一个类可以继承于一个类也可以继承多个类，被继承的类叫父类，继承的类叫子类</p><p>&#x3D;&#x3D;多态&#x3D;&#x3D;：指的是一类事物有多种形态，一个抽象类有多个子类（因而多态的概念依赖于继承）不同的子类对象（调用相同的方法），产生不同的执行结果，多态可以增加代码的灵活度</p><h4 id="实现多态的步骤："><a href="#实现多态的步骤：" class="headerlink" title="实现多态的步骤："></a>实现多态的步骤：</h4><ul><li>1.定义一个父类Base,实现某个方法</li><li>2定义多个子类，在子类中重写父类的方法，实现不同的功能</li><li>3.假设我们定义了一个函数，需要传入Base类对象的参数。那么调用的时候，传入Base类不同子类的对象，那么就会执行不同的功能，这就是多态的提现</li></ul><h4 id="python中是否存在多态"><a href="#python中是否存在多态" class="headerlink" title="python中是否存在多态"></a>python中是否存在多态</h4><p>python中严格来说不存在多态，实现的多态是伪多态。因为python中函数的参数没有严格的类型限制。python崇尚鸭子类型，不要求严格的继承关系，关注的不是对象的类型本身，而是它是如何使用的，一个对象只要看起来像鸭子，走起路来像鸭子，那它就可以被看做是鸭子</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-meta">#伪多态的实现</span><br><span class="hljs-meta">#必须要继承Base才能调用对应的run方法</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Base</span>(<span class="hljs-title">object</span>):</span><br><span class="hljs-class">    def run(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        print(&#x27;<span class="hljs-title">___base___run___</span>:慢慢走路&#x27;)</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Cat</span>(<span class="hljs-type">Base</span>):</span><br><span class="hljs-class">    def run(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        print(&#x27;<span class="hljs-title">___base___run___</span>:会爬树&#x27;)</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Dog</span>(<span class="hljs-type">Base</span>):</span><br><span class="hljs-class">    def run(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        print(&#x27;<span class="hljs-title">___base___run___</span>:会跑步&#x27;)</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">Pig</span>(<span class="hljs-type">Base</span>):</span><br><span class="hljs-class">    pass</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class">m = <span class="hljs-type">Base</span>()</span><br><span class="hljs-class">c = <span class="hljs-type">Cat</span>()</span><br><span class="hljs-class">d = <span class="hljs-type">Dog</span>()</span><br><span class="hljs-class">p = <span class="hljs-type">Pig</span>()</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class">def func(<span class="hljs-title">base_obj</span>):</span><br><span class="hljs-class">    base_obj.run()</span><br><span class="hljs-class"></span><br><span class="hljs-class"></span><br><span class="hljs-class">func(<span class="hljs-title">p</span>)</span><br><span class="hljs-class">func(<span class="hljs-title">m</span>)</span><br><span class="hljs-class">func(<span class="hljs-title">c</span>)</span><br><span class="hljs-class">func(<span class="hljs-title">d</span>)</span><br></code></pre></td></tr></table></figure><h4 id="多态的意义：开放封闭原则"><a href="#多态的意义：开放封闭原则" class="headerlink" title="多态的意义：开放封闭原则"></a>多态的意义：开放封闭原则</h4><ul><li>对于一个变量，我们只需知道它是Base类型，无需确切的知道它的子类型，就可以放心的调用run方法（调用方只管调用不管细节）</li><li>当前需要新增功能，只需要新增一个Base类的子类实现run()方法，就可以在原来的基础上进行功能扩展。这就是著名的开放封闭原则。</li><li>对扩展开放允许新增Base子类</li><li>对修改封闭，不需要修改依赖Base类型的run()等函数</li></ul><h2 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h2><p>鸭子类型概念：它并不要求严格的继承关系，关注的不是对象的类型本身，而是它是如何使用的，一个对象只要看起来像鸭子，走起路来像鸭子，那它就可以被看做是鸭子</p><h4 id="鸭子类型的体现"><a href="#鸭子类型的体现" class="headerlink" title="鸭子类型的体现:"></a>鸭子类型的体现:</h4><h4 id="静态语言："><a href="#静态语言：" class="headerlink" title="静态语言："></a>静态语言：</h4><p>对于静态语言来讲上面传入的对象Base类型或者他的子类，否则将无法调用run()方法</p><h4 id="动态语言："><a href="#动态语言：" class="headerlink" title="动态语言："></a>动态语言：</h4><p>对于动态语言python来讲，上面传入的并不一定要是Base类型，也可以是其他类型，只要在内部实现一个run()方法就行了，这就是鸭子类型的提现</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># 子类不需要继承父类只要拥有和父类一样的方法即可<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>(<span class="hljs-keyword">object</span>):<br>    def run(self):<br>        print(<span class="hljs-string">&quot;base的run方法：吃饭&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">run</span>(self):<br>        print(<span class="hljs-string">&quot;A的run方法：喝咖啡&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<br>    <span class="hljs-type">def</span> <span class="hljs-title">run</span>(self):<br>        print(<span class="hljs-string">&quot;B的run方法：喝茶&quot;</span>)<br><br><br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(name: <span class="hljs-type">Base</span>)</span></span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    python函数的参数没有类型限制 所以不存在多态</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param name:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    name.run()<br><br><br>b = Base()<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(b)</span></span><br>a = A()<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(a)</span></span><br>b = B()<br><span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(b)</span></span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据和自省</title>
    <link href="/2022/03/17/python/%E6%95%B0%E6%8D%AE%E5%92%8C%E8%87%AA%E7%9C%81/"/>
    <url>/2022/03/17/python/%E6%95%B0%E6%8D%AE%E5%92%8C%E8%87%AA%E7%9C%81/</url>
    
    <content type="html"><![CDATA[<h1 id="数据和自省"><a href="#数据和自省" class="headerlink" title="数据和自省"></a>数据和自省</h1><h2 id="类的私有属性"><a href="#类的私有属性" class="headerlink" title="类的私有属性"></a>类的私有属性</h2><p>类里面的私有属性:声明这个属性仅限类内部使用，外部不要引用<br>(如有私有属性进行修改，恕不通知，引用者后果自负)<br>_开头 在类外面可以访问<br>__开头 在类外面可以间接访问，不能直接访问</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<br>    attr = <span class="hljs-number">100</span><br>    _attr = <span class="hljs-number">100</span><br>    __attr = <span class="hljs-number">100</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        实例方法内部：封装和实例对象相关的操作</span><br><span class="hljs-string">        方法内部通常会涉及到实例对象的属性或方法的应用</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;我的名字是&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.name))<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun2</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        类方法内部：需要应用到类属性或者是类方法 内部的逻辑</span><br><span class="hljs-string">        只和类有关，和具体的某一个对象是没有关联的</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;attr的属性为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(cls.attr))<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fun3</span>():<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        方法内部封装的代码：通常不会涉及到类也不会涉及到具体的对象</span><br><span class="hljs-string">        纯粹的功能代码，不会受到内部的任何影响</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-built_in">print</span>(Mytest.attr)<br><span class="hljs-built_in">print</span>(Mytest._attr)<br><span class="hljs-built_in">print</span>(Mytest._Mytest__attr)<br></code></pre></td></tr></table></figure><h2 id="dict"><a href="#dict" class="headerlink" title="dict"></a><strong>dict</strong></h2><p>类调用__dict__返回类属性和方法的字典<br>实例调用__dict__属性，返回的值是实例相关的实例属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<br>    name = <span class="hljs-string">&quot;ss&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>)<br><br><br>m = Mytest(<span class="hljs-number">18</span>)<br>m1 = Mytest(<span class="hljs-number">24</span>)<br>m3 = Mytest(<span class="hljs-number">19</span>)<br><span class="hljs-built_in">print</span>(m.__dict__)<br><span class="hljs-built_in">print</span>(m1.__dict__)<br><span class="hljs-built_in">print</span>(m3.__dict__)<br><span class="hljs-built_in">print</span>(Mytest.__dict__)<br><br>==================执行结果==================<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">18</span>&#125;<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">24</span>&#125;<br>&#123;<span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">19</span>&#125;<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;ss&#x27;</span>, <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Mytest.__init__ at <span class="hljs-number">0x1023ac5f0</span>&gt;, <span class="hljs-string">&#x27;func&#x27;</span>: &lt;function Mytest.func at <span class="hljs-number">0x1023fa290</span>&gt;, <span class="hljs-string">&#x27;__dict__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__dict__&#x27;</span> of <span class="hljs-string">&#x27;Mytest&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__weakref__&#x27;</span>: &lt;attribute <span class="hljs-string">&#x27;__weakref__&#x27;</span> of <span class="hljs-string">&#x27;Mytest&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-emphasis">__slots__</span>:<br><br><span class="hljs-bullet">- </span>1.可以覆盖<span class="hljs-emphasis">__dict__</span>属性 只要这个类定义了<span class="hljs-emphasis">__slots__</span>属性，会覆盖类对象的<span class="hljs-emphasis">__dict__</span>属性<br><span class="hljs-bullet">- </span>2.可以限制类对象的属性绑定<br><span class="hljs-bullet">- </span>3.<span class="hljs-emphasis">__solots__</span> = [] 什么属性都不能添加<br></code></pre></td></tr></table></figure><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><p>1.定义的类需要创建大量的对象可以通过__slots_来指定对象属性，覆盖__dict__减少内存开销</p><p>2.限定类对象绑定的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<br>    __slots__ = [<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;gender&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>]<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,age</span>):<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;func&quot;</span>)<br><br>m = Mytest(<span class="hljs-number">18</span>)<br>m1 = Mytest(<span class="hljs-number">20</span>)<br>m2 = Mytest(<span class="hljs-number">23</span>)<br>m.name1 = <span class="hljs-string">&quot;musen1&quot;</span>  <span class="hljs-comment"># 报错 m这个实例对象 只有三个属性 没有name1属性 不能添加</span><br><span class="hljs-built_in">print</span>(m.__dict__)   <span class="hljs-comment"># 不会给类对象添加__dict__属性</span><br><span class="hljs-built_in">print</span>(Mytest.__dict__) <span class="hljs-comment"># 类属性依然有</span><br><span class="hljs-built_in">print</span>(m2.__slots__)<br>================执行结果=====================<br>&#123;<span class="hljs-string">&#x27;__module__&#x27;</span>: <span class="hljs-string">&#x27;__main__&#x27;</span>, <span class="hljs-string">&#x27;__slots__&#x27;</span>: [<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>], <span class="hljs-string">&#x27;__init__&#x27;</span>: &lt;function Mytest.__init__ at <span class="hljs-number">0x102aac5f0</span>&gt;, <span class="hljs-string">&#x27;func&#x27;</span>: &lt;function Mytest.func at <span class="hljs-number">0x102c15290</span>&gt;, <span class="hljs-string">&#x27;age&#x27;</span>: &lt;member <span class="hljs-string">&#x27;age&#x27;</span> of <span class="hljs-string">&#x27;Mytest&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;gender&#x27;</span>: &lt;member <span class="hljs-string">&#x27;gender&#x27;</span> of <span class="hljs-string">&#x27;Mytest&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;name&#x27;</span>: &lt;member <span class="hljs-string">&#x27;name&#x27;</span> of <span class="hljs-string">&#x27;Mytest&#x27;</span> objects&gt;, <span class="hljs-string">&#x27;__doc__&#x27;</span>: <span class="hljs-literal">None</span>&#125;<br>[<span class="hljs-string">&#x27;age&#x27;</span>, <span class="hljs-string">&#x27;gender&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="自定义属性访问"><a href="#自定义属性访问" class="headerlink" title="自定义属性访问"></a>自定义属性访问</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">object.<span class="hljs-emphasis">__getattr__</span>  当我们访问属性的时候，如果属性不存在（出现AttrError）该方法会被触发。<br><span class="hljs-code">                    要么返回属性值值要么返回一个异常（调用父类即可实现）</span><br>object.<span class="hljs-emphasis">__getattribute__</span> 查找属性的时候第一时间触发该方法去找属性可以返回一个属性值<br><span class="hljs-code">                        也可以调用父类方法触发一个AttrError异常后</span><br>object.<span class="hljs-emphasis">__setattr__</span> 在给对象设置属性的时候触发这个方法<br>object.<span class="hljs-emphasis">__delattr__</span> 在删除属性的时候会被触发<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattribute__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;访问属性的时候 会调用这个方法，这个方法的返回值，就是查找的属性值&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattribute__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;该方法在属性查找不存在的情况下会报错：属性不存在。只要定义了该方法 会自动捕获异常，调用该方法&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;item:<span class="hljs-subst">&#123;item&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattr__(item)<br><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;属性设置的时候会触发&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;key:<span class="hljs-subst">&#123;key&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;value:<span class="hljs-subst">&#123;value&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">super</span>().__setattr__(key, value)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;删除属性的时候会触发&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>m = Mytest(<span class="hljs-string">&quot;musen&quot;</span>)<br><span class="hljs-comment"># print(m.name)</span><br><span class="hljs-comment">#print(m.age)</span><br><span class="hljs-keyword">del</span> m.name<br><span class="hljs-built_in">print</span>(m.name)<br><br></code></pre></td></tr></table></figure><h3 id="自定义属性访问机制的案例"><a href="#自定义属性访问机制的案例" class="headerlink" title="自定义属性访问机制的案例"></a>自定义属性访问机制的案例</h3><p>定义一个user类</p><p>属性：</p><ul><li>name:属性值只能是字符串</li><li>age:属性值只能是int</li><li>desc:属性值只能是字符串</li><li>skill:属性值只能是list类型</li><li>name属性不能被删除</li><li>skill属性如果没有添加 则返回NONE</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__setattr__</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key == <span class="hljs-string">&#x27;name&#x27;</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">str</span>):<br>                <span class="hljs-built_in">super</span>().__setattr__(key, value)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;name必须是str类型&quot;</span>)<br>        <span class="hljs-keyword">elif</span> key == <span class="hljs-string">&#x27;age&#x27;</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(key, <span class="hljs-built_in">int</span>):<br>                <span class="hljs-built_in">super</span>().__setattr__(key, value)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;age必须是int类型&quot;</span>)<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__delattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;name&quot;</span>:<br>            <span class="hljs-keyword">return</span> AttributeError(<span class="hljs-string">&quot;name属性不能被删除&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">super</span>().__delattr__(item)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getattr__</span>(<span class="hljs-params">self, item</span>):<br>        <span class="hljs-keyword">if</span> item == <span class="hljs-string">&quot;skill&quot;</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__getattr__(item)<br><br></code></pre></td></tr></table></figure><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><p>类创建对象<br>类是通过什么创建的？： 元类</p><p>通过type能够查看数据的类型，其实返回的类型就是创建对象的类</p><p>所有的类都是type类型的，type就是元类</p><p>元类的作用：创建类</p><p>type和object:</p><p>python中所有的类都是type创建出来的，包括object也是type创建出来的</p><p>python3中所有的类都继承object type这个类也是继承于object</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Myclass:</span><br><span class="hljs-symbol">    <span class="hljs-symbol">pass</span></span><br><span class="hljs-symbol">print</span>(<span class="hljs-symbol">type</span>(<span class="hljs-symbol">Myclass</span>))<br>==============返回结果==============<br>&lt;<span class="hljs-symbol">class</span> &#x27;<span class="hljs-symbol">type</span>&#x27;&gt;<br></code></pre></td></tr></table></figure><h4 id="如何通过type去创建类-需要传3个参数-1类名-2继承的父类（tuple-3-类的属性和方法（dict"><a href="#如何通过type去创建类-需要传3个参数-1类名-2继承的父类（tuple-3-类的属性和方法（dict" class="headerlink" title="如何通过type去创建类 需要传3个参数 1类名 2继承的父类（tuple) 3 类的属性和方法（dict)"></a>如何通过type去创建类 需要传3个参数 1类名 2继承的父类（tuple) 3 类的属性和方法（dict)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span>:<br>    name = <span class="hljs-string">&quot;base_name&quot;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是方法&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, age</span>):<br>    <span class="hljs-variable language_">self</span>.age = age<br><br><br>Myclass = <span class="hljs-built_in">type</span>(<span class="hljs-string">&quot;Myclass&quot;</span>,<br>               (Base,),<br>               &#123;<span class="hljs-string">&quot;NAME&quot;</span>: <span class="hljs-string">&quot;MY&quot;</span>, <span class="hljs-string">&quot;ATTR&quot;</span>: <span class="hljs-number">19</span>, <span class="hljs-string">&quot;func&quot;</span>: func, <span class="hljs-string">&quot;__init__&quot;</span>: __init__&#125;)<br>m = Myclass(<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(m.age)<br><span class="hljs-built_in">print</span>(m.ATTR)<br>m.func()<br><br><br><span class="hljs-comment"># 自定义元类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytype</span>(<span class="hljs-title class_ inherited__">type</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性能测试常见问题总结</title>
    <link href="/2022/02/18/PerformanceTesting/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/02/18/PerformanceTesting/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="性能测试常见问题总结"><a href="#性能测试常见问题总结" class="headerlink" title="性能测试常见问题总结"></a>性能测试常见问题总结</h1><h4 id="1、性能测试的流程是什么？"><a href="#1、性能测试的流程是什么？" class="headerlink" title="1、性能测试的流程是什么？"></a>1、性能测试的流程是什么？</h4><pre><code class="hljs">需求调研-环境搭建-脚本编写-准备数据-执行测试-回归调优-测试报告</code></pre><h4 id="2、什么是关联？在什么情况下需要做关联？"><a href="#2、什么是关联？在什么情况下需要做关联？" class="headerlink" title="2、什么是关联？在什么情况下需要做关联？"></a>2、什么是关联？在什么情况下需要做关联？</h4><pre><code class="hljs">- 关联是将服务器返回的数据通过一定的规则过滤出来，将其保存成参数，以供后续代码中使用  - 当服务器返回的数据是动态变化的，且后续脚本中需要使用这个变化的数据时，才需要做关联  </code></pre><h4 id="3、Jmeter中怎么写Java脚本，简要说下步骤"><a href="#3、Jmeter中怎么写Java脚本，简要说下步骤" class="headerlink" title="3、Jmeter中怎么写Java脚本，简要说下步骤"></a>3、Jmeter中怎么写Java脚本，简要说下步骤</h4><pre><code class="hljs">- a)通过eclipse等工具手动编写一个Java类，实现JavaSamplerClient接口- b)将要写的代码放到JavaSamplerClient接口对应的实现方法中，如果需要暴露出参数，将参数添加到getDefaultParameters方法中- c)脚本调试通过后，将写好的脚本达成runnable jar，将jar包和依赖的lib文件夹放到Jmeter的lib/ext下，重启Jmeter- d)在Jmeter中添加JavaSampler，选择jar包中的测试类</code></pre><h4 id="4、一般在什么情况下会在Jmeter中使用BeanShell"><a href="#4、一般在什么情况下会在Jmeter中使用BeanShell" class="headerlink" title="4、一般在什么情况下会在Jmeter中使用BeanShell"></a>4、一般在什么情况下会在Jmeter中使用BeanShell</h4><pre><code class="hljs">- a)被测接口调用前需要对参数做一些逻辑处理，可以使用BeanShell前置处理器- b)需要对接口的返回值做一些逻辑判断，可以使用BeanShell断言</code></pre><h4 id="5、怎么根据线下环境评估线上环境的性能"><a href="#5、怎么根据线下环境评估线上环境的性能" class="headerlink" title="5、怎么根据线下环境评估线上环境的性能"></a>5、怎么根据线下环境评估线上环境的性能</h4><pre><code class="hljs">- a)首先线下必须要有专门的性能测试环境- b)线下环境单台机器配置和线上不能相差很大，可以通过单台的机器性能推算出多台机器性能（需考虑一定的性能损耗）- c)如果线下机器配置很差，只能测试出程序有无性能问题，这样线下测试出来的数据对线上没有太大参考意义- d)如果想获取比较准确的线上性能情况，建议最好做线上的性能测试</code></pre><h4 id="6、对于Linux系统，主要的监控指标有哪些？他们的各自阈值是多少？"><a href="#6、对于Linux系统，主要的监控指标有哪些？他们的各自阈值是多少？" class="headerlink" title="6、对于Linux系统，主要的监控指标有哪些？他们的各自阈值是多少？"></a>6、对于Linux系统，主要的监控指标有哪些？他们的各自阈值是多少？</h4><pre><code class="hljs">- cpu使用率：&lt;80%- load值：&lt;cpu的核数- 系统内存：使用率&lt;80%- 磁盘IO：&lt;100%-90%- 网络IO：&lt;带宽上限</code></pre><h4 id="7、线程都有几种状态？哪些状态需要关注？"><a href="#7、线程都有几种状态？哪些状态需要关注？" class="headerlink" title="7、线程都有几种状态？哪些状态需要关注？"></a>7、线程都有几种状态？哪些状态需要关注？</h4><pre><code class="hljs">- 线程状态：runnable、waitting、timed-waitting、blocked、terminated- 最影响性能的是blocked状态（阻塞，锁）的线程，timed-waitting（限时等待）</code></pre><h4 id="8、Jvm中持久代（方法区）中主要存放什么数据？老年代主要存放什么数据？"><a href="#8、Jvm中持久代（方法区）中主要存放什么数据？老年代主要存放什么数据？" class="headerlink" title="8、Jvm中持久代（方法区）中主要存放什么数据？老年代主要存放什么数据？"></a>8、Jvm中持久代（方法区）中主要存放什么数据？老年代主要存放什么数据？</h4><pre><code class="hljs">持久代中主要存放静态数据、常量、类的基本信息等  老年代中主要存放对象的实例和数组等  </code></pre><h4 id="9、应用服务器cpu高和数据库服务器cpu高的分析思路是什么？"><a href="#9、应用服务器cpu高和数据库服务器cpu高的分析思路是什么？" class="headerlink" title="9、应用服务器cpu高和数据库服务器cpu高的分析思路是什么？"></a>9、应用服务器cpu高和数据库服务器cpu高的分析思路是什么？</h4><pre><code class="hljs">- 应用服务器的cpu高，先要看tps和响应时间，如果tps比较高，我们认为是正常的cpu消耗；如果tps比较低，那么往往某些代码过于消耗cpu，可以考虑使用jprofiler分析下  - 数据库服务器cpu高，往往是因为sql语句执行效率比较低，可以通过对数据库慢查询是监控，结合执行计划进行分析，是否是相关表没有索引或索引未生效  </code></pre><h4 id="10、出现内存泄露的根本原因是什么？你是怎么定位内存泄露原因的？"><a href="#10、出现内存泄露的根本原因是什么？你是怎么定位内存泄露原因的？" class="headerlink" title="10、出现内存泄露的根本原因是什么？你是怎么定位内存泄露原因的？"></a>10、出现内存泄露的根本原因是什么？你是怎么定位内存泄露原因的？</h4><pre><code class="hljs">- 内存泄露的根本原因是Jvm中老年代中存在着大量存活的对象，这些对象不能被GC回收掉，从而占满了整个老年代，造成Jvm一直处于FGC的状态，程序没有响应，服务器报OOM错误- 内存泄露主要通过分析老年代中占用空间最大的类都有哪些，然后去代码中找对应的类的创建。通常可以使用jdk提供的jvisualvm和jmap进行堆内存的分析</code></pre><h4 id="11、tps压不上去，可能有哪些方面的原因？"><a href="#11、tps压不上去，可能有哪些方面的原因？" class="headerlink" title="11、tps压不上去，可能有哪些方面的原因？"></a>11、tps压不上去，可能有哪些方面的原因？</h4><pre><code class="hljs">- a)压力机本身性能瓶颈- b)网络IO瓶颈- c)中间件（tomcat/nginx/mysql）连接数限制- b)Java线程的阻塞、等待- e)本系统资源的瓶颈（cpu、内存、磁盘、网络等）- f)其他外部系统响应时间过长，造成本系统的time-wait</code></pre><h4 id="12、性能场景怎么设计？一般都有哪些性能场景？"><a href="#12、性能场景怎么设计？一般都有哪些性能场景？" class="headerlink" title="12、性能场景怎么设计？一般都有哪些性能场景？"></a>12、性能场景怎么设计？一般都有哪些性能场景？</h4><pre><code class="hljs">- 一般基本的场景包括：基准测试、单交易测试、混合测试、稳定性测试- 其他场景的可选场景：高可用性测试、异常测试等，以及其他的结合各自项目业务的场景</code></pre><h4 id="13、测试数据怎么构造？你一般都是采用哪些方法来造数据？"><a href="#13、测试数据怎么构造？你一般都是采用哪些方法来造数据？" class="headerlink" title="13、测试数据怎么构造？你一般都是采用哪些方法来造数据？"></a>13、测试数据怎么构造？你一般都是采用哪些方法来造数据？</h4><pre><code class="hljs">- a)调用业务接口构造数据- b)直接写jdbc代码造数据- c)存储过程造数据</code></pre><h4 id="14、常见的性能指标有哪些？分别是什么含义？"><a href="#14、常见的性能指标有哪些？分别是什么含义？" class="headerlink" title="14、常见的性能指标有哪些？分别是什么含义？"></a>14、常见的性能指标有哪些？分别是什么含义？</h4><pre><code class="hljs">- tps：每秒事务量，代表了系统的处理能力，tps越高，性能越好- 响应时间：从发出请求到接受到系统响应数据所花费的时间，响应时间越短，性能越好- 吞吐量：网络上行和下行流量的总和，吞吐量是网络瓶颈定位的重要指标- 错误率：在压测过程中系统出现错误的比例</code></pre><h4 id="15、什么是集合点，什么场景下需要用集合点"><a href="#15、什么是集合点，什么场景下需要用集合点" class="headerlink" title="15、什么是集合点，什么场景下需要用集合点"></a>15、什么是集合点，什么场景下需要用集合点</h4><pre><code class="hljs">- 集合点是测试脚本中的一个标记，当每个虚拟用户执行到标记处时，会停留在标记处等待其他的虚拟用户，当达到预期设置的并发数时，标记处的所有用户同时启动执行后续的请求- 集合点会产生瞬间高并发，但是也会降低平均压力。所以在压测过程中，如果有要求瞬间高并发的业务，就需要使用集合点，比如抢购，秒杀之类的业务。- 没有类似业务则不需要加集合点</code></pre><h4 id="16、性能测试过程中，怎么判断网络瓶颈？"><a href="#16、性能测试过程中，怎么判断网络瓶颈？" class="headerlink" title="16、性能测试过程中，怎么判断网络瓶颈？"></a>16、性能测试过程中，怎么判断网络瓶颈？</h4><pre><code class="hljs">- 一般性能测试都是在局域网内进行，在压测过程中，可以监控到服务器上网卡的流量，判断此流量是否已经达到局域网内网络设备的上限，比如路由器、交换机、网卡等- 在这些设备中，一般是服务器网卡网络吞吐量最低。服务器的网卡大多是千兆网卡，换算成MB=1000/8=125MB</code></pre><h4 id="17、服务器的cpu使用率和load是什么关系？"><a href="#17、服务器的cpu使用率和load是什么关系？" class="headerlink" title="17、服务器的cpu使用率和load是什么关系？"></a>17、服务器的cpu使用率和load是什么关系？</h4><pre><code class="hljs">- 通常情况下，cpu使用率和load值是正比关系，即cpu使用率越高，load值越高。但是在一些特殊情况下，也会出现cpu使用率不高，但是load值较高的情况- 比如某系统只能使用CPU中的单核运行，它可以占用单核cpu100%，但从整体cpu使用率来看，只是使用了一小部分。而随着并发的增大，单核CPU的任务队列会越来越长，造成了load值较高</code></pre><h4 id="18、性能测试脚本中为什么要做参数化？"><a href="#18、性能测试脚本中为什么要做参数化？" class="headerlink" title="18、性能测试脚本中为什么要做参数化？"></a>18、性能测试脚本中为什么要做参数化？</h4><pre><code class="hljs">- 参数化把测试脚本中的请求数据动态化，避免使用单一固定参数进行压测。这也是为了更加真实的模拟用户的请求</code></pre><ul><li>常用的参数化方式有:随机数、随机字符串、时间戳、文件参数化、UUID等</li></ul><h4 id="19、Linux系统中的buffer和cache都起到什么作用。内存占用有大量的buffer和cache是异常情况吗？"><a href="#19、Linux系统中的buffer和cache都起到什么作用。内存占用有大量的buffer和cache是异常情况吗？" class="headerlink" title="19、Linux系统中的buffer和cache都起到什么作用。内存占用有大量的buffer和cache是异常情况吗？"></a>19、Linux系统中的buffer和cache都起到什么作用。内存占用有大量的buffer和cache是异常情况吗？</h4><pre><code class="hljs">buffer和cache都是Linux中的缓存机制，cache里一般会缓存一些文件的内容，buffer会缓存一些需要写入磁盘的数据。Linux会利用空闲的内存做一些缓存，加快文件的访问速度。如果系统可用内存不足时，Linux会释放掉buffer和cache所占用的内存。所以内存占用中有大量的buffer和cache也是正常现象</code></pre><h4 id="20、产品就只给一个需求，需求调研的内容都不知道，也没人告诉你，怎么开展性能测试？"><a href="#20、产品就只给一个需求，需求调研的内容都不知道，也没人告诉你，怎么开展性能测试？" class="headerlink" title="20、产品就只给一个需求，需求调研的内容都不知道，也没人告诉你，怎么开展性能测试？"></a>20、产品就只给一个需求，需求调研的内容都不知道，也没人告诉你，怎么开展性能测试？</h4><ul><li>a&gt; 没有任何途径进行需求调研的情况下，可以跳过需求调研，直接开始压测。</li><li>b&gt; 压测完成后，可以把本次压测数据开会讨论，共同决定是否满足性能需求；</li><li>c&gt; 或者根据行业内的通用指标规范，比如高频接口响应时间&lt;100ms，低频&lt;200ms的标准来判断</li></ul><h4 id="21、如何定位一个系统的性能瓶颈？"><a href="#21、如何定位一个系统的性能瓶颈？" class="headerlink" title="21、如何定位一个系统的性能瓶颈？"></a>21、如何定位一个系统的性能瓶颈？</h4><pre><code class="hljs">见《性能案例分析》PPT</code></pre><h4 id="22、怎么进行性能场景设计？"><a href="#22、怎么进行性能场景设计？" class="headerlink" title="22、怎么进行性能场景设计？"></a>22、怎么进行性能场景设计？</h4><pre><code class="hljs">通用类场景：- a&gt; 单接口测试场景- b&gt; 混合接口测试场景- c&gt; 高可用性场景（集群情况下）- d&gt; 网络异常场景（如有必要）- e&gt; 稳定性场景- f&gt; 其他业务相关场景</code></pre><h4 id="23、给你一种xx协议的系统，怎么测试"><a href="#23、给你一种xx协议的系统，怎么测试" class="headerlink" title="23、给你一种xx协议的系统，怎么测试"></a>23、给你一种xx协议的系统，怎么测试</h4><pre><code class="hljs">- a&gt; 先了解协议的格式，数据交互- b&gt; 查找压测工具是否支持本协议- c&gt; 如果不支持，通过自己写代码的方式发送协议包进行测试</code></pre><h4 id="24、云上部署的应用怎么压测？"><a href="#24、云上部署的应用怎么压测？" class="headerlink" title="24、云上部署的应用怎么压测？"></a>24、云上部署的应用怎么压测？</h4><pre><code class="hljs">- a&gt; 在云上申请一台机器当做压力机，与部署应用同区域机房，这样相当于在云上内网压测- b&gt; 与局域网压测一样，使用通用工具LR、Jmeter进行压测</code></pre><h4 id="25、jmeter常用函数有哪些"><a href="#25、jmeter常用函数有哪些" class="headerlink" title="25、jmeter常用函数有哪些?"></a>25、jmeter常用函数有哪些?</h4><ul><li>1，threadNum 获取线程号，一般用来定位参数化策略问题时使用。</li><li>2，machineIP 获取本地机器IP，一般定位负载机问题时使用。</li><li>3，time 获取当前时间，支持各种时间格式。</li><li>4，log 记录日志信息，一般用来定位接口请求应答问题。</li><li>5，Counter 生成递增数，迭代过程中使用。</li><li>6，digest 生成摘要，支持的加密算法有MD、SHA，例如模拟对接口参数进行md5加密。 </li><li>7，Random 指定范围内生成随机数。</li></ul><h4 id="26、如何准备性能测试数据"><a href="#26、如何准备性能测试数据" class="headerlink" title="26、如何准备性能测试数据"></a>26、如何准备性能测试数据</h4><ul><li>a)调用业务接口构造数据，一般适用于数据逻辑比较复杂的情况下。 </li><li>b)直接写jdbc代码造数据，一般适用于数据量较大且数据逻辑较简单的情况。 </li><li>c)存储过程造数据，一般适用于数据量巨大且数据逻辑较简单的情况。 </li><li>d)导入sql，一般适用于数据安全级别较低且数据量巨大的</li></ul><h4 id="27、http和https的区别"><a href="#27、http和https的区别" class="headerlink" title="27、http和https的区别"></a>27、http和https的区别</h4><ul><li>HTTP:超文本传输协议，是一个客户端和服务器端的请求和应答的标准。 </li><li>HTTPS:是以安全为目标的HTTP通道，HTTP的安全版本，HTTP下加入SSL层， HTTPS的安全基础是SSL,因此加密的详细内容就需要SSL. 它们的区别如下:</li><li><ol><li>HTTP 信息是明文传输的，而 HTTPS 是安全的 具有安全性的ssl加密传输</li></ol></li><li><ol start="2"><li>HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443</li></ol></li><li><ol start="3"><li>HTTP 无需证书，而 HTTPS 需要认证证书.需要到CA申请证书， 一般免费证书较少，因而需要一定费用</li></ol></li></ul><h4 id="28、做性能测试的原因是什么"><a href="#28、做性能测试的原因是什么" class="headerlink" title="28、做性能测试的原因是什么?"></a>28、做性能测试的原因是什么?</h4><p>首先互联网行业发展快，用户量大增， 有些用户反馈的问题是多用户并发操作导致的; 其次是业务和系统的架构越来越复杂， 简单架构没有的性能问题，往往在复杂架构中更容易出现; 然后就是用户量剧增的情况下，<br>导致数据库存的数据量也跟着陡增，<br>这种情况下也会更容易出现性能瓶颈; 最重要的是用户越来越不仅仅只满足于按钮能用，还关注点点点后的</p>]]></content>
    
    
    <categories>
      
      <category>PerformanceTesting</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PerformanceTesting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2022/02/17/python/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2022/02/17/python/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><h4 id="深浅复制（copy）"><a href="#深浅复制（copy）" class="headerlink" title="深浅复制（copy）"></a>深浅复制（copy）</h4><p>一般数在数据嵌套的情况讨论，以列表为例：</p><ul><li>如果是变量赋值，则会在内存中分配一片内存存放这个数据对象 a&#x3D;10</li><li>如果是变量引用，直接指向的引用的数据 b&#x3D;a</li><li>如果是列表的copy方法，会在内存中重新分配一片内存存放复制对象</li></ul><h4 id="浅复制"><a href="#浅复制" class="headerlink" title="浅复制"></a>浅复制</h4><p>浅复制：在复制对象的时候，会重新划分一块内存存储复制的对象，关于对应的数据的引用不会进行复制<br>      只会复制对象，不会复制对象中引用的数据（也是直接引用）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> copy <span class="hljs-keyword">import</span> deepcopy<br>li = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>li1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>li2 = li<br>li3 = li.copy()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(li))   <span class="hljs-comment"># 4341104064</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(li1))  <span class="hljs-comment"># 4341105200</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(li2))  <span class="hljs-comment"># 4341104064</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(li3))  <span class="hljs-comment"># 4341104624</span><br><br>问题：这三个是否是同一个对象？<br><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>li = [<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, a]<br>li2 = li  <span class="hljs-comment"># 变量引用</span><br><br>li3 = li.copy()  <span class="hljs-comment"># 浅复制</span><br>a.append(<span class="hljs-number">99</span>)<br><br><br><span class="hljs-comment"># 问题：li  li3中的值会不会变化？</span><br><span class="hljs-built_in">print</span>(li)   <span class="hljs-comment"># [11,22,[1,3,4,99]]</span><br><span class="hljs-built_in">print</span>(li3)  <span class="hljs-comment"># [11,22,[1,3,4,99]]</span><br><br>li.append(<span class="hljs-number">10000</span>)<br><span class="hljs-built_in">print</span>(li)   <span class="hljs-comment"># [11,22,[1,3,4,99],10000]</span><br><span class="hljs-built_in">print</span>(li3)  <span class="hljs-comment"># [11,22,[1,3,4,99]]</span><br></code></pre></td></tr></table></figure><h4 id="深复制（copy）"><a href="#深复制（copy）" class="headerlink" title="深复制（copy）"></a>深复制（copy）</h4><p>深拷贝:在进行复制的时候，不仅会复制对象，更会把对象中所有引用的数据复制一份</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">a = [1, 3, 4]<br>li = [11, 22, a]<br>li3 = deepcopy(li) <span class="hljs-comment"># 深拷贝</span><br><br><span class="hljs-built_in">print</span>(li,<span class="hljs-built_in">id</span>(li))  <span class="hljs-comment"># 4341104064 [11,22,[1,3,4]]</span><br><span class="hljs-built_in">print</span>(li3,<span class="hljs-built_in">id</span>(li)) <span class="hljs-comment"># 4341104064 [11,22,[1,3,4]]</span><br><br>a.append(99)<br>li.append(100)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------------a发生变化之后-------------------------&#x27;</span>)<br><span class="hljs-built_in">print</span>(li,<span class="hljs-built_in">id</span>(li))   <span class="hljs-comment"># [11,22,[1,3,4,99],100]</span><br><span class="hljs-built_in">print</span>(li3,<span class="hljs-built_in">id</span>(li3)) <span class="hljs-comment"># [11,22,[1,3,4]]</span><br></code></pre></td></tr></table></figure><p><img src="/the-nuo/picture/copy.png" alt="copy"></p><h4 id="内存池机制："><a href="#内存池机制：" class="headerlink" title="内存池机制："></a>内存池机制：</h4><ul><li><p>1、小整数池<br>  在python中 -5到256之间的数据 直接引用小整数池里的无需重新分配内存，内存id一致</p></li><li><p>2、大整数池（字符串驻留池）：intern机制<br>  在运行py程序的时候，解释器会专门分配一块空白的内存，用来存放纯单词字符组成的字符串（数字，字母，下划线）</p></li></ul><p><img src="/the-nuo/picture/neicunchi.png" alt="neicun"></p><h2 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h2><h3 id="python的垃圾回收机制用一句话来形容就是：引用计数为主，标记-清除和分代回收两种机制为辅的策略"><a href="#python的垃圾回收机制用一句话来形容就是：引用计数为主，标记-清除和分代回收两种机制为辅的策略" class="headerlink" title="python的垃圾回收机制用一句话来形容就是：引用计数为主，标记-清除和分代回收两种机制为辅的策略"></a>python的垃圾回收机制用一句话来形容就是：引用计数为主，标记-清除和分代回收两种机制为辅的策略</h3><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>当对象的引用计数为0的时候，python的垃圾回收机制会自动把它销毁，回收内存空间</p><h4 id="pytho中对象引用计数增加的情况"><a href="#pytho中对象引用计数增加的情况" class="headerlink" title="pytho中对象引用计数增加的情况"></a>pytho中对象引用计数增加的情况</h4><ul><li>1、变量赋值  a&#x3D; ‘abc’</li><li>2、变量引用  b &#x3D;a</li><li>3、被其他的对象引用  li &#x3D; [1,2,a]</li></ul><h4 id="python中对象引用计数减少的情况"><a href="#python中对象引用计数减少的情况" class="headerlink" title="python中对象引用计数减少的情况"></a>python中对象引用计数减少的情况</h4><ul><li>1、变量被删除 del a</li><li>2、变量引用了其他对象 a&#x3D;10 被改成a&#x3D;100 此时10的引用计数就减少了</li><li>3、变量离开了所在的作用域（函数调用结束）<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">var</span>)</span></span>:<br>  <span class="hljs-built_in">print</span>(<span class="hljs-keyword">var</span>) <span class="hljs-keyword">var</span>指向的是a的数值 函数调用结束 <span class="hljs-keyword">var</span>的引用计数为<span class="hljs-number">0</span> 则会被销毁<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a)</span></span><br></code></pre></td></tr></table></figure></li><li>4、在其他的引用对象中被删除（移除）<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = <span class="hljs-string">&quot;abc&quot;</span><br><span class="hljs-selector-tag">li</span> = <span class="hljs-selector-attr">[1,2,a]</span><br><span class="hljs-selector-tag">li</span>.remove<br></code></pre></td></tr></table></figure></li></ul><h4 id="引用计数的缺点"><a href="#引用计数的缺点" class="headerlink" title="引用计数的缺点"></a>引用计数的缺点</h4><p>那就是当两个对象出现循环引用的时候，那么两个变量始终不会被销毁，这样就会导致内存泄漏</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[11, 22]</span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-attr">[1, 2]</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.append</span>(b)<br><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.append</span>(a)<br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(a)</span></span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(b)</span></span><br><span class="hljs-selector-tag">del</span> <span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">del</span> b<br></code></pre></td></tr></table></figure><p>a b已经被删除，但是对象之间的循环引用还在，因为有引用计数，此时引用计数删除不了，需要用到标记清除<br><img src="/the-nuo/picture/xunhuanyinyong.png" alt="循环引用"></p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>标记清除机制，顾名思义首先标记对象（垃圾检测），然后清除垃圾（垃圾回收)。删除所有未被全局变量引用的对象,可以解决循环引用问题。   </p><ul><li>1.首先初始所有对象标记为白色，并确定全局变量，标记他们为黑色（表示对象有效）  </li><li>2.从全部变量开始往下找，将全局变量引用的对象进行标记，再继续往下找，把所有有效对象标记为黑色  </li><li>3.所有的全部变量全部查找完后，最后剩下的白色结点都是需要清除的对象</li></ul><p><img src="/the-nuo/picture/biaojiqingchu.png" alt="标记清除"></p><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>分代回收策略着眼于提升垃圾回收的效率。研究表明，任何语言，任何环节的编程中，对于变量在内存中的创建、销毁，总有频繁和不那么频繁。<br><img src="/the-nuo/picture/fendaihuishou.png" alt="分代回收"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>API自动化</title>
    <link href="/2022/02/17/AutoTest/API%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    <url>/2022/02/17/AutoTest/API%E8%87%AA%E5%8A%A8%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="接口自动化"><a href="#接口自动化" class="headerlink" title="接口自动化"></a>接口自动化</h1><h2 id="接口自动化测试介入项目管理流程"><a href="#接口自动化测试介入项目管理流程" class="headerlink" title="接口自动化测试介入项目管理流程"></a>接口自动化测试介入项目管理流程</h2><p><img src="/the-nuo/picture/Snipaste_2021-05-11_16-32-16.png" alt="接口自动化测试介入项目管理流程"></p><h2 id="接口自动化框架结构"><a href="#接口自动化框架结构" class="headerlink" title="接口自动化框架结构"></a>接口自动化框架结构</h2><p><img src="/the-nuo/picture/jiagou.png" alt="接口自动化框架结构"></p><h2 id="单元测试框架Unittest工作原理及使用"><a href="#单元测试框架Unittest工作原理及使用" class="headerlink" title="单元测试框架Unittest工作原理及使用"></a>单元测试框架Unittest工作原理及使用</h2><h4 id="1-什么是单元测试-单元测试的对象"><a href="#1-什么是单元测试-单元测试的对象" class="headerlink" title="1.什么是单元测试 单元测试的对象"></a>1.什么是单元测试 单元测试的对象</h4><p>单元测试就是对单个模块或者是单个类或者是单个函数进行测试，一般是开发做的，按照阶段来分，一般就是单元测试 集成测试 系统测试  验收测试</p><h4 id="2-为什么要做单元测试"><a href="#2-为什么要做单元测试" class="headerlink" title="2.为什么要做单元测试"></a>2.为什么要做单元测试</h4><ul><li>1）单元测试之后才是集成测试，单个单个的功能模块测试通过之后，才能把单个功能模块集成起来做集成测试，为了从底层发现bug,减少合成后出现的问题。</li><li>2）越早发现bug越好，这样可以早点发现问题，不然问题累积到后面，如果做错了就要推倒重来，对弈时间和经费来说，是非常浪费的</li></ul><h4 id="Python搭建自动化测试框架-Python的标准库——unittest。"><a href="#Python搭建自动化测试框架-Python的标准库——unittest。" class="headerlink" title="Python搭建自动化测试框架   Python的标准库——unittest。"></a>Python搭建自动化测试框架   Python的标准库——unittest。</h4><h3 id="unittest核心工作原理"><a href="#unittest核心工作原理" class="headerlink" title="unittest核心工作原理"></a>unittest核心工作原理</h3><p>unittest中最核心的四个概念是：test case, test suite, test runner, test fixture </p><ul><li>TestCase:一个testcase的实例就是一个测试用例</li><li>TestSUite:多个测试用例集合在一起</li><li>TestLoader:是用来加载Testcase到Testsuite中的</li><li>TextTestRunner:用来执行测试用例的，其中run(test)会执行testsuite&#x2F;testcase中的run(result)方法</li><li>TextTestResult:保存TextTestRunner执行的测试结果</li><li>fixture：测试用例环境的搭建和销毁</li></ul><p>写好TestCase，然后由TestLoader加载TestCase到TestSuite，然后由TextTestRunner来运行TestSuite，运行的结果保存在TextTestResult中，我们通过命令行或者unittest.main()执行时，main会调用TextTestRunner中的run来执行，或者我们可以直接通过TextTestRunner来执行用例。这里加个说明，在Runner执行时，默认将执行结果输出到控制台，我们可以设置其输出到文件，在文件中查看结果（你可能听说过HTMLTestRunner，是的，通过它可以将结果输出到HTML中，生成漂亮的报告，它跟TextTestRunner是一样的，从名字就能看出来，这个我们后面再说）。  </p><h3 id="unittest初级使用"><a href="#unittest初级使用" class="headerlink" title="unittest初级使用"></a>unittest初级使用</h3><p>1.导入unittest模块，被测文件或者其中的类<br>2.创建一个测试类，并继承unittest.Testcase 自己创建的单元测试类都要继承它，是所有单元测试类的基类<br>3.重写set up和tear down方法（如果有初始化条件和结束条件）<br>4.定义测试函数，函数名以test_开头,否则无法识别并执行。<br>5.在函数体中使用断言来判断测试结果是否符合预期结果<br>6.调用unittest.main()方法运行测试用例，执行顺序是按照case的命名，会搜索当前module下所有以test开发的测试用例并运行</p><h4 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h4><ul><li>用于每个测试用例执行前的初始化工作</li><li>所有类中方法的入参为self,定义实例变量也要self.变量</li></ul><h4 id="tear-down"><a href="#tear-down" class="headerlink" title="tear down"></a>tear down</h4><ul><li>每个测试用例执行后都会执行此方法</li></ul><h4 id="setupClass"><a href="#setupClass" class="headerlink" title="setupClass"></a>setupClass</h4><ul><li>每个单元测试类运行前都会调用该方法，只执行一次</li><li>属于类方法，需要加上装饰器@classmethod</li><li>默认入参是cls,指的就是‘类对象’本身，用法和self一致</li></ul><h4 id="teardownClass"><a href="#teardownClass" class="headerlink" title="teardownClass"></a>teardownClass</h4><ul><li>每个单元测试类运行后调用该方法，只会执行一次</li><li>属于类方法，需要加上装饰器@classmethod</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest  <span class="hljs-comment">#导入unittest模块</span><br><span class="hljs-keyword">from</span> Student <span class="hljs-keyword">import</span> student   <span class="hljs-comment">#导入被测文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testStudent</span>(unittest.TestCase):   <span class="hljs-comment">#创建一个测试类，并继承unittest.TestCase</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; =========开始测试========&quot;</span>)   <span class="hljs-comment">#重写setUp tearDown 方法（如果有初始化和结束条件）</span><br>        <span class="hljs-variable language_">self</span>.stu=student(<span class="hljs-string">&quot;周诺&quot;</span>,<span class="hljs-string">&quot;7年级&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>)        <span class="hljs-comment">#测试之前就必须实例化</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========结束测试========&quot;</span>)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_listen_class</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.stu.listen_class()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.stu.speak()<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add_newclass</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.stu.add_newclass(<span class="hljs-string">&quot;全程班&quot;</span>）<br>unittest.main()<br><br>执行结果<br>=========开始测试========<br>周诺新学了一门课程[<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;全程班&#x27;</span>]<br>==========结束测试========<br>=========开始测试========<br>周诺正在上课中<br>==========结束测试========<br>=========开始测试========<br>周诺说我在读<span class="hljs-number">7</span>年级年级<br>==========结束测试========<br></code></pre></td></tr></table></figure><h4 id="classmethod-类执行之前执行完毕后执行一次，只初始化一次"><a href="#classmethod-类执行之前执行完毕后执行一次，只初始化一次" class="headerlink" title="@classmethod 类执行之前执行完毕后执行一次，只初始化一次"></a>@classmethod 类执行之前执行完毕后执行一次，只初始化一次</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs less">简单方法<br>     <span class="hljs-variable">@classmethod</span>             #三个测试用例执行之前，只初始化一次<br>     def <span class="hljs-built_in">setUpClass</span>(self):  <br>          <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot; =========开始测试========&quot;</span>)   #重写setUp tearDown 方法（如果有初始化和结束条件）<br>          self.stu=<span class="hljs-built_in">student</span>(<span class="hljs-string">&quot;周诺&quot;</span>,<span class="hljs-string">&quot;7年级&quot;</span>,<span class="hljs-string">&quot;python&quot;</span>)        #测试之前就必须实例化<br>     <span class="hljs-variable">@classmethod</span><br>     def <span class="hljs-built_in">tearDownClass</span>(self):<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=================结束测试======&quot;</span>)<br>     def <span class="hljs-built_in">test_listen_class</span>(self):<br>        # <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        self.stu.<span class="hljs-built_in">listen_class</span>()<br>     def <span class="hljs-built_in">test_speak</span>(self):<br>        # <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        self.stu.<span class="hljs-built_in">speak</span>()<br>     def <span class="hljs-built_in">test_add_newclass</span>(self):<br>        # <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;====================&quot;</span>)<br>        self.stu.<span class="hljs-built_in">add_newclass</span>(<span class="hljs-string">&quot;全程班&quot;</span>)<br>             self.stu.<span class="hljs-built_in">speak</span>()               #断言，测试类继承了Testcase类，里面有很多断言方法可以使用<br>             self.<span class="hljs-built_in">assertEqual</span>(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>)<br>             self.<span class="hljs-built_in">assertIsInstance</span>(self.stu,student)<br>unittest.<span class="hljs-built_in">main</span>()<br><br>运行结果<br>=========开始测试========<br>周诺新学了一门课程[<span class="hljs-string">&#x27;python&#x27;</span>, <span class="hljs-string">&#x27;全程班&#x27;</span>]<br>周诺正在上课中<br>周诺说我在读<span class="hljs-number">7</span>年级年级<br>=================结束测试======<br> <br></code></pre></td></tr></table></figure><h3 id="unittest提供的各种断言方式"><a href="#unittest提供的各种断言方式" class="headerlink" title="unittest提供的各种断言方式"></a>unittest提供的各种断言方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testCase</span>(unittest.TestCase):<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_03</span>(<span class="hljs-params">self</span>):<br> <span class="hljs-number">4</span>         <span class="hljs-comment"># 断言 - 是否为True</span><br> <span class="hljs-number">5</span>         flag = <span class="hljs-literal">True</span><br> <span class="hljs-number">6</span>         <span class="hljs-variable language_">self</span>.assertTrue(flag, msg=<span class="hljs-string">&quot;测试失败的信息,可不填&quot;</span>)<br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_04</span>(<span class="hljs-params">self</span>):<br> <span class="hljs-number">9</span>         <span class="hljs-comment"># 断言 - 是否为False</span><br><span class="hljs-number">10</span>         flag = <span class="hljs-literal">False</span><br><span class="hljs-number">11</span>         <span class="hljs-variable language_">self</span>.assertFalse(flag)<br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_05</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">14</span>         <span class="hljs-comment"># 断言 - 提供的两个参数是否相同(任意类型)</span><br><span class="hljs-number">15</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)  <span class="hljs-comment"># 字符串</span><br><span class="hljs-number">16</span>         <span class="hljs-variable language_">self</span>.assertEqual(&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>&#125;)  <span class="hljs-comment"># 字典</span><br><span class="hljs-number">17</span>         <span class="hljs-variable language_">self</span>.assertEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 列表</span><br><span class="hljs-number">18</span>         <span class="hljs-variable language_">self</span>.assertEqual((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># 元组</span><br><span class="hljs-number">19</span>         <span class="hljs-variable language_">self</span>.assertEqual(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;)  <span class="hljs-comment"># 集合</span><br><span class="hljs-number">20</span> <br><span class="hljs-number">21</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_06</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">22</span>         <span class="hljs-comment"># 断言 - 列表是否相同</span><br><span class="hljs-number">23</span>         <span class="hljs-variable language_">self</span>.assertListtEqual([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-number">24</span> <br><span class="hljs-number">25</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_07</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">26</span>         <span class="hljs-comment"># 断言 - 字典是否相同</span><br><span class="hljs-number">27</span>         <span class="hljs-variable language_">self</span>.assertDictEqual(&#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-number">28</span> <br><span class="hljs-number">29</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_08</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">30</span>         <span class="hljs-comment"># 断言 - 元组是否相同</span><br><span class="hljs-number">31</span>         <span class="hljs-variable language_">self</span>.assertTupleEqual((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><span class="hljs-number">32</span> <br><span class="hljs-number">33</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_09</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">34</span>         <span class="hljs-comment"># 断言 - 集合是否相同</span><br><span class="hljs-number">35</span>         <span class="hljs-variable language_">self</span>.assertSetEqual(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="unittest测试用例跳过执行"><a href="#unittest测试用例跳过执行" class="headerlink" title="unittest测试用例跳过执行"></a>unittest测试用例跳过执行</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs ruby"> <span class="hljs-number">1</span> <span class="hljs-keyword">class</span> testCase(unittest.<span class="hljs-title class_">TestCase</span>):<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span>     <span class="hljs-comment"># 直接跳过</span><br> <span class="hljs-number">4</span>     <span class="hljs-variable">@unittest</span>.skip(<span class="hljs-string">&quot;直接跳过&quot;</span>)<br> <span class="hljs-number">5</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_skip</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br> <span class="hljs-number">6</span>         <span class="hljs-variable language_">self</span>.fail(<span class="hljs-string">&quot;shouldn&#x27;t happen&quot;</span>)<br> <span class="hljs-number">7</span> <br> <span class="hljs-number">8</span>     <span class="hljs-comment"># 满足condition则跳过</span><br> <span class="hljs-number">9</span>     <span class="hljs-variable">@unittest</span>.skipIf(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>, <span class="hljs-string">&quot;满足condition则跳过&quot;</span>)<br><span class="hljs-number">10</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_skipIf</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br><span class="hljs-number">11</span>         print(<span class="hljs-string">&quot;skip if&quot;</span>)<br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span>     <span class="hljs-comment"># 不满足condition则跳过</span><br><span class="hljs-number">14</span>     <span class="hljs-variable">@unittest</span>.skipUnless(sys.platform.startswith(<span class="hljs-string">&quot;win&quot;</span>), <span class="hljs-string">&quot;需要window平台才不会跳过&quot;</span>)<br><span class="hljs-number">15</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_skipUnless</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br><span class="hljs-number">16</span>         print(<span class="hljs-string">&quot;skip Unless&quot;</span>)<br><span class="hljs-number">17</span> <br><span class="hljs-number">18</span>     <span class="hljs-comment"># 预计该测试用例会测试失败</span><br><span class="hljs-number">19</span>     <span class="hljs-variable">@unittest</span>.expectedFailure<br><span class="hljs-number">20</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_fail</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br><span class="hljs-number">21</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;broken&quot;</span>)<br><span class="hljs-number">22</span> <br><span class="hljs-number">23</span>     <span class="hljs-comment"># 方法体内跳出不执行case</span><br><span class="hljs-number">24</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_maybe_skipped</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span></span>):<br><span class="hljs-number">25</span>         <span class="hljs-keyword">if</span> <span class="hljs-title class_">True</span>:<br><span class="hljs-number">26</span>             <span class="hljs-variable language_">self</span>.skipTest(<span class="hljs-string">&quot;调用unittest的skipTest,在方法体内满足某些条件则跳过该case&quot;</span>)<br><span class="hljs-number">27</span>         pass<br></code></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span>Skipped: 调用unittest的skipTest,在方法体内满足某些条件则跳过该case<br><span class="hljs-number"> 2 </span><br><span class="hljs-number"> 3 </span>Skipped: 直接跳过<br><span class="hljs-number"> 4 </span><br><span class="hljs-number"> 5 </span>Skipped: 满足condition则跳过<br><span class="hljs-number"> 6 </span>skip Unless<br><span class="hljs-number"> 7 </span><br><span class="hljs-number"> 8 </span><br><span class="hljs-number"> 9 </span>Ran<span class="hljs-number"> 5 </span>tests in 0.010s<br>10 <br>11 OK (skipped=3, expected failures=1)<br></code></pre></td></tr></table></figure><h4 id="跳过执行测试用例共有四种写法"><a href="#跳过执行测试用例共有四种写法" class="headerlink" title="跳过执行测试用例共有四种写法"></a>跳过执行测试用例共有四种写法</h4><ul><li>@unittest.skip(reason) ：跳过测试用例，reason  为测试被跳过的原因</li><li>@unittest.skipIf(condition, reason) ：当 condition 为真时，跳过测试用例。</li><li>@unittest.skipUnless(condition, reason) ：跳过测试用例，除非 condition 为真</li><li>@unittest.expectedFailure ：把测试用例标记为预计失败；如果测试不通过，会被认为测试成功；如果测试通过了，则被认为是测试失败</li><li>self.skipTest(reason) 在方法体内满足某些条件下才跳过执行该测试用例</li></ul><h4 id="跳过执行测试用例注意点"><a href="#跳过执行测试用例注意点" class="headerlink" title="跳过执行测试用例注意点"></a>跳过执行测试用例注意点</h4><ul><li>被跳过的测试的  setUp() 和  tearDown()  不会被运行</li><li>只输入 unittest.skip ，也可以正常跳过，不必写reason</li><li>若输入 unittest.skip() ，括号内必须写reason，不得为空</li><li>可以针对单元测试类级别设置跳过执行（在class声明上面直接加装饰器即可），该单元测试类所有测试用例不会被执行</li><li>被跳过的类的 setUpClass() 和 tearDownClass() 不会被运行</li><li>当方法体内调用了 self.skipTest(reason) 方法，该测试用例还是会调用 setUp() 和 tearDown()</li></ul><h3 id="unittest进阶使用"><a href="#unittest进阶使用" class="headerlink" title="unittest进阶使用"></a>unittest进阶使用</h3><p>testsuit<br>addTest()添加一个测试用例<br>addTests()添加多个测试用例  </p><p>addTests的参数：是一个测试用例的列表  </p><ul><li>方式一 类名（‘方法名’）的集合  </li><li>方式二 unittest.TestLoader.discover方法匹配   从一个目录下面搜索测试用例  </li><li>方式三  unittest.Testloader.loadTestsFromModule() 直接导入测试模块</li></ul><h4 id="第一种方法-类名（用例名）"><a href="#第一种方法-类名（用例名）" class="headerlink" title="第一种方法  类名（用例名）"></a>第一种方法  类名（用例名）</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import unittest<br><span class="hljs-keyword">from</span> test_Student import testStudent<br><span class="hljs-attribute">s</span>=unittest.TestSuite()    #没有init方法，所以不传参，用init初始化方法<br>s.addTests([testStudent(<span class="hljs-string">&quot;test_listen_class&quot;</span>),testStudent(<span class="hljs-string">&quot;test_speak&quot;</span>),testStudent(<span class="hljs-string">&quot;test_add_newclass&quot;</span>)])<br><span class="hljs-attribute">runner</span>=unittest.TextTestRunner()<br>runner.<span class="hljs-built_in">run</span>(s）<br></code></pre></td></tr></table></figure><h4 id="第二种方法-testloader-通过这个方法把这个模块里面所有的用例都添加进来，返回suite"><a href="#第二种方法-testloader-通过这个方法把这个模块里面所有的用例都添加进来，返回suite" class="headerlink" title="第二种方法 testloader 通过这个方法把这个模块里面所有的用例都添加进来，返回suite"></a>第二种方法 testloader 通过这个方法把这个模块里面所有的用例都添加进来，返回suite</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import unittest<br>import test_Student<br><span class="hljs-attribute">tl</span>=unittest.TestLoader()<br><span class="hljs-attribute">ss</span>=tl.loadTestsFromModule(test_Student)  #ss是一个套件<br><span class="hljs-attribute">runner</span>=unittest.TextTestRunner()<br>runner.<span class="hljs-built_in">run</span>(ss)<br></code></pre></td></tr></table></figure><h5 id="第三种方法-discovery-发现包下所有测试用例"><a href="#第三种方法-discovery-发现包下所有测试用例" class="headerlink" title="第三种方法 discovery 发现包下所有测试用例"></a>第三种方法 discovery 发现包下所有测试用例</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import unittest<br>import os<br><span class="hljs-attribute">s</span>=unittest.TestSuite()<br><span class="hljs-attribute">tl</span>=unittest.TestLoader()<br>s.addTests(tl.discover(os.getcwd()))<br><span class="hljs-keyword">from</span> HtmlTestRunner import HTMLTestRunner<br><span class="hljs-attribute">path</span>=<span class="hljs-string">&quot;D:\\&quot;</span><br><span class="hljs-attribute">ht</span>=HTMLTestRunner(output=&quot;path&quot;,report_title=&quot;报告名称&quot;)<br>ht.<span class="hljs-built_in">run</span>(s)<br></code></pre></td></tr></table></figure><h3 id="unittest工作原理图"><a href="#unittest工作原理图" class="headerlink" title="unittest工作原理图"></a>unittest工作原理图</h3><p><img src="/the-nuo/picture/Snipaste_20.png" alt="unittest工作原理"></p><h2 id="DDT框架读取excel测试数据"><a href="#DDT框架读取excel测试数据" class="headerlink" title="DDT框架读取excel测试数据"></a>DDT框架读取excel测试数据</h2><h4 id="名称：ddt-data-driven-test-数据驱动测试"><a href="#名称：ddt-data-driven-test-数据驱动测试" class="headerlink" title="名称：ddt(data.driven.test):数据驱动测试"></a>名称：ddt(data.driven.test):数据驱动测试</h4><h4 id="作用：由外部数据集合来驱动测试用例，结合单元测试一起用"><a href="#作用：由外部数据集合来驱动测试用例，结合单元测试一起用" class="headerlink" title="作用：由外部数据集合来驱动测试用例，结合单元测试一起用"></a>作用：由外部数据集合来驱动测试用例，结合单元测试一起用</h4><h4 id="核心的思想：数据和测试代码分离"><a href="#核心的思想：数据和测试代码分离" class="headerlink" title="核心的思想：数据和测试代码分离"></a>核心的思想：数据和测试代码分离</h4><h4 id="应用场景：一组数据来执行相同的操作"><a href="#应用场景：一组数据来执行相同的操作" class="headerlink" title="应用场景：一组数据来执行相同的操作"></a>应用场景：一组数据来执行相同的操作</h4><h4 id="优点：当测试数据发生大量变化的情况下测试代码，（或者说测试用例）可以保持不变"><a href="#优点：当测试数据发生大量变化的情况下测试代码，（或者说测试用例）可以保持不变" class="headerlink" title="优点：当测试数据发生大量变化的情况下测试代码，（或者说测试用例）可以保持不变"></a>优点：当测试数据发生大量变化的情况下测试代码，（或者说测试用例）可以保持不变</h4><h5 id="实际应用：excel存储测试数据，ddt读取测试数据到-单元测试框架（测试用例中）-输出到html报告"><a href="#实际应用：excel存储测试数据，ddt读取测试数据到-单元测试框架（测试用例中）-输出到html报告" class="headerlink" title="实际应用：excel存储测试数据，ddt读取测试数据到 单元测试框架（测试用例中）-输出到html报告"></a>实际应用：excel存储测试数据，ddt读取测试数据到 单元测试框架（测试用例中）-输出到html报告</h5><h3 id="什么是数据驱动"><a href="#什么是数据驱动" class="headerlink" title="什么是数据驱动"></a>什么是数据驱动</h3><p>就是数据的改变从而驱动自动化测试的执行，最终引起测试结果的改变，说的直白些，就是参数化的应用</p><p>安装：pip install ddt  </p><h3 id="ddt结合单元测试来使用"><a href="#ddt结合单元测试来使用" class="headerlink" title="ddt结合单元测试来使用"></a>ddt结合单元测试来使用</h3><ul><li>1.在测试类定义之前使用：@ddt.ddt</li><li>2.在测试用例定义之前使用，@ddt.data(测试数据) 测试数据之间用逗号隔开</li><li>3.在2的基础上定义测试用例时，参数接收2中的测试数据<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ruby">使用之前先导入ddt  <br>import ddt  <br>例:<br><span class="hljs-variable">@ddt</span>.ddt  <span class="hljs-comment"># 在测试类前必须先声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> <span class="hljs-title class_">Test</span>(unittest.<span class="hljs-title class_">TestCase</span>):<br>         <span class="hljs-variable">@ddt</span>.data(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>         <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_print</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>,a</span>)<br>              print(<span class="hljs-string">&quot;简单调用@data查看输出的是什么？&quot;</span>,a)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br><br>===========输出结果==============<br>简单调用<span class="hljs-variable">@data</span>查看输出的是什么？,<span class="hljs-number">2</span><br>简单调用<span class="hljs-variable">@data</span>查看输出的是什么？,<span class="hljs-number">3</span><br>简单调用<span class="hljs-variable">@data</span>查看输出的是什么？,<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ddt<br><span class="hljs-keyword">import</span> unittest<br><span class="hljs-meta">@ddt.ddt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_PersonInfo</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========开始测试==========&quot;</span>)<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========结束测试==========&quot;</span>)<br> <br><span class="hljs-meta">   @ddt.data(<span class="hljs-params"><span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_print</span>(<span class="hljs-params">self,a</span>):<br>        <span class="hljs-built_in">print</span>(a)<br>===============输出结果=================<br><br><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure></li></ul><p>ddt-data 数据<br>一组数据之间用逗号隔开<br>data的参数可以为如下几种  </p><ul><li>1.一组数据中，每个数据为单个值</li><li>2.一组数据中，每个数据为一个列表或者一个字典</li><li>3.文件对象：jason,yaml</li></ul><p>一组数据中的数据为列表或者字典：<br>@data([a,b],[c,d])  </p><p>如何从以上数据中获取到字典中每一项值<br>@unpack<br>若变量A&#x3D;[{a:b,a1:b1},{c:d,c1:d1}]<br>如何将变量A中的每一组元素作为测试数据<br>@ddt.data(*A) </p><h4 id="包含知识点"><a href="#包含知识点" class="headerlink" title="包含知识点"></a>包含知识点</h4><p>@unpack ：当传递的是复杂的数据结构时使用。比如使用元组或者列表，添加 @unpack 之后， ddt 会自动把元组或者列表对应到多个参数上。字典也可以这样处理  </p><ul><li>当没有加unpack时，test_case方法的参数只能填一个；</li><li>当你加了unpack时，传递的数据量需要一致；如列表例子中，每个列表我都固定传了2个数据，当你多传或少传时会报错，而test_case方法的参数也要写2个，需要匹配上  </li><li>当传的数据是字典类型时，要注意每个字典的key都要一致，test_case的参数的命名也要一致；如字典的例子，两个字典的key都是value1和value2，而方法的参数也是</li><li>当传的数据是通过变量的方式，变量前需要加上*</li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ddt<br><span class="hljs-keyword">import</span> unittest<br><br><span class="hljs-meta">@ddt.ddt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_PersonInfo</span>(unittest.TestCase):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">setUp</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========开始测试==========&quot;</span>)<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">tearDown</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;==========结束测试==========&quot;</span>)<br> <br><span class="hljs-meta">    @ddt.data(<span class="hljs-params">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_print</span>(<span class="hljs-params">self,a</span>):<br>        <span class="hljs-built_in">print</span>(a)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    unittest.main()<br>=====================输出结果====================<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br> <br><span class="hljs-built_in">print</span>(a[<span class="hljs-number">0</span>])<br><br><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="列表拆包"><a href="#列表拆包" class="headerlink" title="列表拆包"></a>列表拆包</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less">    <span class="hljs-variable">@ddt</span>.<span class="hljs-built_in">data</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])<br>    <span class="hljs-variable">@ddt</span>.unpack<br>    def <span class="hljs-built_in">test_print</span>(self,a,b):<br>        <span class="hljs-built_in">print</span>(a,b)<br> <br>==========开始测试==========<br><span class="hljs-number">1</span> <span class="hljs-number">2</span><br>==========结束测试==========<br>==========开始测试==========<br><span class="hljs-number">3</span> <span class="hljs-number">4</span><br>==========结束测试==========<br></code></pre></td></tr></table></figure><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@data</span>(&#123;<span class="hljs-string">&#x27;value1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;value2&#x27;</span>: <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-string">&#x27;value1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;value2&#x27;</span>: <span class="hljs-number">2</span>&#125;)<br>    <span class="hljs-variable">@unpack</span><br>    def <span class="hljs-built_in">test_dict</span>(self, value1, value2):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_dict&quot;</span>, value1, value2)<br><br>===============输出==============<br>test_dict <span class="hljs-number">1</span> <span class="hljs-number">2</span><br>test_dict <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="元祖"><a href="#元祖" class="headerlink" title="元祖"></a>元祖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">tuples = ((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>))<br><span class="hljs-meta"> @data(<span class="hljs-params">*tuples</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_tuples</span>(<span class="hljs-params">self, n</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;test_tuples&quot;</span>, n)<br>=============输出================<br>test_tuples (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>test_tuples (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h4 id="包含字典的列表"><a href="#包含字典的列表" class="headerlink" title="包含字典的列表"></a>包含字典的列表</h4><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs 1c">datas <span class="hljs-punctuation">=</span> [&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;xiaoshitou&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0001</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<span class="hljs-punctuation">,</span><br>         &#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;nuonuo&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0002</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;female&#x27;&#125;<span class="hljs-punctuation">,</span><br>         &#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;fly&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0003</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<span class="hljs-punctuation">,</span><br>         &#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;haiyang&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0004</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<span class="hljs-punctuation">,</span><br>         &#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;shuangshuang&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0005</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;female&#x27;&#125;<br>]<br>@ddt.data<span class="hljs-punctuation">(</span>*datas<span class="hljs-punctuation">)</span><br>    def test_print<span class="hljs-punctuation">(</span>self<span class="hljs-punctuation">,</span>datas<span class="hljs-punctuation">)</span><span class="hljs-punctuation">:</span><br>        print<span class="hljs-punctuation">(</span>datas<span class="hljs-punctuation">)</span><br><br>if __name__ <span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span> &#x27;__main__&#x27;<span class="hljs-punctuation">:</span><br>            unittest.main<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><br>            <br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>开始测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br>&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;xiaoshitou&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0001</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>结束测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>开始测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br>&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;nuonuo&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0002</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;female&#x27;&#125;<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>结束测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>开始测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br>&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;fly&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0003</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>结束测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>开始测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br>&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;haiyang&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0004</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;male&#x27;&#125;<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>结束测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>开始测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br>&#123;&#x27;class&#x27;<span class="hljs-punctuation">:</span> &#x27;python2&#x27;<span class="hljs-punctuation">,</span> &#x27;name&#x27;<span class="hljs-punctuation">:</span> &#x27;shuangshuang&#x27;<span class="hljs-punctuation">,</span> &#x27;id&#x27;<span class="hljs-punctuation">:</span> &#x27;<span class="hljs-number">0005</span>&#x27;<span class="hljs-punctuation">,</span> &#x27;sex&#x27;<span class="hljs-punctuation">:</span> &#x27;female&#x27;&#125;<br><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span>结束测试<span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><span class="hljs-punctuation">=</span><br></code></pre></td></tr></table></figure><h3 id="传递json文件"><a href="#传递json文件" class="headerlink" title="传递json文件"></a>传递json文件</h3><p>dat-data数据<br>数据为文件对象：Json yaml<br>@ddt.file_data(jason文件路径)<br>json格式里面必须为双引号“”，且必须为键值对，不存在纯列表格式，值作为测试数据<br>{“name”:”nick”,”gender”:”male”,”age”:29}  </p><h4 id="JSON文件"><a href="#JSON文件" class="headerlink" title="JSON文件"></a>JSON文件</h4><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scilab">&#123;<br>  <span class="hljs-string">&quot;first&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;isRememberMe&quot;</span>: <span class="hljs-string">&quot;True&quot;</span>,<br>      <span class="hljs-string">&quot;password&quot;</span>: <span class="hljs-string">&quot;111111&quot;</span>,<br>      <span class="hljs-string">&quot;username&quot;</span>: <span class="hljs-string">&quot;root&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;200&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;second&quot;</span>: [<br>    <span class="hljs-string">&quot;&#123;&#x27;</span>isRememberMe<span class="hljs-string">&#x27;: True, &#x27;</span>password<span class="hljs-string">&#x27;: &#x27;</span><span class="hljs-number">1111111</span><span class="hljs-string">&#x27;, &#x27;</span>username<span class="hljs-string">&#x27;: &#x27;</span>root<span class="hljs-string">&#x27;&#125;&quot;</span>,<br>    <span class="hljs-string">&quot;406&quot;</span><br>  ],<br>  <span class="hljs-string">&quot;third&quot;</span>: [<br>    <span class="hljs-number">1</span>,<br>    <span class="hljs-number">2</span><br>  ],<br>  <span class="hljs-string">&quot;four&quot;</span>: <span class="hljs-string">&quot;123123&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单元测试类"><a href="#单元测试类" class="headerlink" title="单元测试类"></a>单元测试类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ddt <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-comment"># 在测试类前必须首先声明使用 ddt</span><br><span class="hljs-meta">@ddt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">imoocTest</span>(unittest.TestCase):<br><br><span class="hljs-meta">    @file_data(<span class="hljs-params"><span class="hljs-string">&#x27;F:/test/config/testddt.json&#x27;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_json</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span>(data)<br> <br>==========输出结果==========<br>[&#123;<span class="hljs-string">&#x27;isRememberMe&#x27;</span>: <span class="hljs-string">&#x27;True&#x27;</span>, <span class="hljs-string">&#x27;password&#x27;</span>: <span class="hljs-string">&#x27;111111&#x27;</span>, <span class="hljs-string">&#x27;username&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>&#125;, <span class="hljs-string">&#x27;200&#x27;</span>]<br>[<span class="hljs-string">&quot;&#123;&#x27;isRememberMe&#x27;: True, &#x27;password&#x27;: &#x27;1111111&#x27;, &#x27;username&#x27;: &#x27;root&#x27;&#125;&quot;</span>, <span class="hljs-string">&#x27;406&#x27;</span>]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-number">123123</span><br>      <br></code></pre></td></tr></table></figure><h3 id="传递YAML文件"><a href="#传递YAML文件" class="headerlink" title="传递YAML文件"></a>传递YAML文件</h3><h4 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h4><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">unsorted_list</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">10</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">15</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">12</span><br><br><span class="hljs-attribute">sorted_list</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[ 15, 12, 50 ]</span><br><br></code></pre></td></tr></table></figure><h4 id="单元测试类-1"><a href="#单元测试类-1" class="headerlink" title="单元测试类"></a>单元测试类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> ddt <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-comment"># 在测试类前必须首先声明使用 ddt</span><br><span class="hljs-meta">@ddt</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">imoocTest</span>(unittest.TestCase):<br><br><span class="hljs-meta">    @file_data(<span class="hljs-params"><span class="hljs-string">&#x27;F:/test/config/testddt.yaml&#x27;</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test4</span>(<span class="hljs-params">self, data</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;yaml&quot;</span>, data)<br>===============输出结果==================<br>yaml [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">12</span>]<br>yaml [<span class="hljs-number">15</span>, <span class="hljs-number">12</span>, <span class="hljs-number">50</span>]<br></code></pre></td></tr></table></figure><h2 id="接口自动化框架代码"><a href="#接口自动化框架代码" class="headerlink" title="接口自动化框架代码"></a>接口自动化框架代码</h2><h3 id="handle-excel"><a href="#handle-excel" class="headerlink" title="handle_excel"></a>handle_excel</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> openpyxl<br><br><span class="hljs-keyword">from</span> common.handlepath <span class="hljs-keyword">import</span> DATADIR<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadExcel</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename, sheet_name</span>):<br>        <span class="hljs-variable language_">self</span>.filename = filename<br>        <span class="hljs-variable language_">self</span>.sheet_name = sheet_name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">open</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 获取工作簿对象</span><br>        <span class="hljs-variable language_">self</span>.wb = openpyxl.load_workbook(<span class="hljs-variable language_">self</span>.filename)<br>        <span class="hljs-comment"># 选择表单</span><br>        <span class="hljs-variable language_">self</span>.sh = <span class="hljs-variable language_">self</span>.wb[<span class="hljs-variable language_">self</span>.sheet_name]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;读取数据&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>()<br>        <span class="hljs-comment"># 按行获取表单所有格子中的数据，每一行的数据放在一个元组中</span><br>        datas = <span class="hljs-built_in">list</span>(<span class="hljs-variable language_">self</span>.sh.rows)<br>        <span class="hljs-comment"># 获取第一行的数据，作为字典的键</span><br>        title = [i.value <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> datas[<span class="hljs-number">0</span>]]<br>        <span class="hljs-comment"># 创建一个空列表，用例存放用例数据</span><br>        cases = []<br>        <span class="hljs-comment"># 遍历除第一行之外的数据</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> datas[<span class="hljs-number">1</span>:]:<br>            <span class="hljs-comment"># 获取该行数据的值</span><br>            values = [c.value <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> i]<br>            <span class="hljs-comment"># 将该行数据和title（第一行数据）打包转换为字典</span><br>            <span class="hljs-keyword">case</span> = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(title, values))<br>            <span class="hljs-comment"># 将转换的字典添加到前面创建的空列表cases中</span><br>            cases.append(<span class="hljs-keyword">case</span>)<br>        <span class="hljs-keyword">return</span> cases<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_data</span>(<span class="hljs-params">self, row, column, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;写入数据&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">open</span>()<br>        <span class="hljs-comment"># 写入数据</span><br>        <span class="hljs-variable language_">self</span>.sh.cell(row=row, column=column, value=value)<br>        <span class="hljs-comment"># 保存文件</span><br>        <span class="hljs-variable language_">self</span>.wb.save(<span class="hljs-variable language_">self</span>.filename)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    case_file = os.path.join(DATADIR, <span class="hljs-string">&quot;apicases.xlsx&quot;</span>)<br>    exce = ReadExcel(case_file,<span class="hljs-string">&quot;login&quot;</span>)<br>    ex = exce.read_data()<br>    <span class="hljs-built_in">print</span>(ex)<br></code></pre></td></tr></table></figure><h3 id="handle-requests"><a href="#handle-requests" class="headerlink" title="handle requests"></a>handle requests</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestsHandler</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.session = requests.Session()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">self, url, method, params=<span class="hljs-literal">None</span>, data=<span class="hljs-literal">None</span>, json=<span class="hljs-literal">None</span>, **kwargs </span>):<br>        <span class="hljs-string">&quot;&quot;&quot;访问一个接口，你可以使用 get 请求，也可以使用 post 请求， put, delete</span><br><span class="hljs-string">        请求方法：method:</span><br><span class="hljs-string">        请求地址： url</span><br><span class="hljs-string">        请求参数：params, data, json</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-variable language_">self</span>.session.request(method, url, params=params, data=data, json=json, **kwargs)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> res.json()<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not json&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_session</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.session.close()<br>        <br></code></pre></td></tr></table></figure><h3 id="handle-log"><a href="#handle-log" class="headerlink" title="handle log"></a>handle log</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging.handlers <span class="hljs-keyword">as</span> HD<br><span class="hljs-keyword">from</span> scripts.constants <span class="hljs-keyword">import</span> LOGS_DIR<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> logging<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLogger</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 实例化logging对象</span><br>        <span class="hljs-variable language_">self</span>.logger = logging.getLogger(<span class="hljs-string">&quot;api_autoTest&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.logger.setLevel(logging.INFO)<br>        <span class="hljs-comment"># 日志内容输出格式设置</span><br>        fmt = <span class="hljs-string">&#x27;%(asctime)s  %(filename)s  %(funcName)s [line:%(lineno)d] %(levelname)s %(message)s&#x27;</span><br>        datefmt = <span class="hljs-string">&#x27;%d %b %Y %H:%M&#x27;</span><br>        <span class="hljs-built_in">format</span> = logging.Formatter(fmt, datefmt)<br>        curTime = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H%M&quot;</span>, time.localtime())<br>        <span class="hljs-comment"># 输出日志到文件中</span><br>        file_handler = HD.TimedRotatingFileHandler(LOGS_DIR + <span class="hljs-string">&quot;/Api_Autotest_log_&#123;0&#125;.log&quot;</span>.<span class="hljs-built_in">format</span>(curTime),<br>                                                   backupCount=<span class="hljs-number">20</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>, maxBytes=<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">100</span>)<br>        file_handler.setFormatter(<span class="hljs-built_in">format</span>)<br>        file_handler.setLevel(logging.INFO)<br>        <span class="hljs-variable language_">self</span>.logger.addHandler(file_handler)<br>        <span class="hljs-comment"># 输出日志到控制台</span><br>        handle_1 = HD.TimedRotatingFileHandler(LOGS_DIR + <span class="hljs-string">&quot;/Api_Autotest_log_&#123;0&#125;.log&quot;</span>.<span class="hljs-built_in">format</span>(curTime),<br>                                               backupCount=<span class="hljs-number">20</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        handle_1.setFormatter(<span class="hljs-built_in">format</span>)<br>        handle_1.setLevel(logging.INFO)<br>        <span class="hljs-variable language_">self</span>.logger.addHandler(handle_1)<br>        hs = logging.StreamHandler()<br>        hs.setFormatter(<span class="hljs-built_in">format</span>)<br>        hs.setLevel(logging.INFO)<br>        <span class="hljs-variable language_">self</span>.logger.addHandler(hs)<br><br>    <span class="hljs-comment"># 配置日志收集器 - 存在放哪个文件，</span><br>    <span class="hljs-comment"># 定义各种日志级别的方法，方便在其它文件中调用</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">info</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.info(msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">debug</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.debug(msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.error(msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">warning</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.warning(msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">critical</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.critical(msg)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">exception</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-variable language_">self</span>.logger.exception(msg)<br><br></code></pre></td></tr></table></figure><h3 id="handle-config"><a href="#handle-config" class="headerlink" title="handle config"></a>handle config</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> configparser <span class="hljs-keyword">import</span> ConfigParser<br><span class="hljs-keyword">from</span> common.handlepath <span class="hljs-keyword">import</span> CONFDIR<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleConfig</span>(<span class="hljs-title class_ inherited__">ConfigParser</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename</span>):<br>        <span class="hljs-comment"># 调用父类的init方法</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.filename = filename<br>        <span class="hljs-variable language_">self</span>.read(filename,encoding=<span class="hljs-string">&quot;utf8&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">write_data</span>(<span class="hljs-params">self, section, options, value</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;写入数据的方法&quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.<span class="hljs-built_in">set</span>(section, options, value)<br>        <span class="hljs-variable language_">self</span>.write(fp=<span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.filename, <span class="hljs-string">&quot;w&quot;</span>))<br><br><br>conf = HandleConfig(os.path.join(CONFDIR,<span class="hljs-string">&quot;config.ini&quot;</span>))<br><span class="hljs-built_in">print</span>(conf.get(<span class="hljs-string">&quot;env&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="handle-mysql"><a href="#handle-mysql" class="headerlink" title="handle mysql"></a>handle mysql</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymysql<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> scripts.handle_config <span class="hljs-keyword">import</span> config, config1<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HandleMysql</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    处理mysql</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-variable language_">self</span>.conn = pymysql.connect(host=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;host&quot;</span>),<br>                                   user=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>),<br>                                   password=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>),<br>                                   db=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;db&quot;</span>),<br>                                   port=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>),<br>                                   charset=config(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;charset&quot;</span>),<br>                                   cursorclass=pymysql.cursors.DictCursor)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            logging.info(<span class="hljs-string">&quot;连接数据库失败，原因为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(e))<br>        <span class="hljs-keyword">else</span>:<br>            logging.info(<span class="hljs-string">&quot;数据库连接成功！&quot;</span>)<br>            <span class="hljs-variable language_">self</span>.cursor = <span class="hljs-variable language_">self</span>.conn.cursor()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params">self, sql, args=<span class="hljs-literal">None</span>, is_more=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        :param sql: sql语句，字符类型</span><br><span class="hljs-string">        :param arg: sql语句的参数，为序列类型</span><br><span class="hljs-string">        :param is_more: False or True</span><br><span class="hljs-string">        :return: 字典类型或者嵌套字典的列表</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-variable language_">self</span>.cursor.execute(sql, args=args)<br>        <span class="hljs-variable language_">self</span>.conn.commit()<br><br>        <span class="hljs-keyword">if</span> is_more:<br>            result = <span class="hljs-variable language_">self</span>.cursor.fetchall()<br><br>        <span class="hljs-keyword">else</span>:<br>            result = <span class="hljs-variable language_">self</span>.cursor.fetchone()<br><br>        <span class="hljs-keyword">return</span> result<br><br></code></pre></td></tr></table></figure><h3 id="handle-removeFile"><a href="#handle-removeFile" class="headerlink" title="handle removeFile"></a>handle removeFile</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> scripts.constants <span class="hljs-keyword">import</span> REPORTS_DIR, LOGS_DIR<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">delete_file</span>(<span class="hljs-params"><span class="hljs-built_in">dir</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    删除指定文件夹下的文件 主要用于删除测试报告和测试日志</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    filelist = os.listdir(<span class="hljs-built_in">dir</span>)<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> filelist:<br>        my_file = os.path.join(<span class="hljs-built_in">dir</span>, file)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(filelist) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">try</span>:<br>                os.remove(my_file)<br>                logging.info(<span class="hljs-string">&quot;删除历史测试报告/测试日志成功！&quot;</span>)<br>            <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>                logging.info(<span class="hljs-string">f&quot;删除失败原因为:<span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    delete_file(LOGS_DIR)<br>    delete_file(REPORTS_DIR)<br><br></code></pre></td></tr></table></figure><h3 id="handle-context"><a href="#handle-context" class="headerlink" title="handle context"></a>handle context</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> logging<br><span class="hljs-keyword">from</span> scripts.handle_config <span class="hljs-keyword">import</span> config1<br><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    实现参数化、反射功能</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 账号登录</span><br>    login_tel_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;\$\&#123;login_tel\&#125;&quot;</span>)<br>    default_pwd_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;\$\&#123;default_pwd\&#125;&quot;</span>)<br>    admin_pwd_pattern = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;\$\&#123;admin_pwd\&#125;&quot;</span>)<br><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">login_tel_replace</span>(<span class="hljs-params">cls, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        替换CC手机号</span><br><span class="hljs-string">        :param data:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> re.search(cls.login_tel_pattern, data):<br>            login_tel = config1(<span class="hljs-string">&quot;CC_Account&quot;</span>, <span class="hljs-string">&quot;dahuaCC_tel&quot;</span>)<br>            data = re.sub(cls.login_tel_pattern, <span class="hljs-built_in">str</span>(login_tel), data)<br><br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">default_pwd_replace</span>(<span class="hljs-params">cls, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        替换登录密码,存储MD5加密后值</span><br><span class="hljs-string">        :param data:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> re.search(cls.default_pwd_pattern, data):<br>            default_pwd = config1(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;default_pwd&quot;</span>)<br>            data = re.sub(cls.default_pwd_pattern, default_pwd, data)<br>        <span class="hljs-keyword">return</span> data<br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">admin_pwd_replace</span>(<span class="hljs-params">cls, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        替换admin账号登录密码,存储MD5加密后值</span><br><span class="hljs-string">        :param data:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> re.search(cls.admin_pwd_pattern, data):<br>            admin_pwd = config1(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;admin_pwd&quot;</span>)<br>            data = re.sub(cls.admin_pwd_pattern, admin_pwd, data)<br>        <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loginAccount_parameterization</span>(<span class="hljs-params">cls, data</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        实现账号登录 手机号 密码的参数化 主要是登录身份鉴权使用</span><br><span class="hljs-string">        :param data:</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        data = cls.login_tel_replace(data)<br>        data = cls.default_pwd_replace(data)<br>        data = cls.admin_pwd_replace(data)<br><br>        <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    target_str1 = <span class="hljs-string">&#x27;&#123;&quot;activityList&quot;: [],&quot;contractCategory&quot;: &quot;REGISTER&quot;,&quot;idCardNo&quot;: &quot;$&#123;customer_idCardNo&#125;&quot;,&quot;lessonPackageId&quot;: 1,&quot;mobile&quot;: &quot;$&#123;customer_tel&#125;&quot;,&quot;name&quot;: &quot;$&#123;customer_name&#125;&quot;,&quot;special&quot;: False,&quot;storeId&quot;: 31,&quot;studentNum&quot;: 3,&quot;subjectNum&quot;: 14&#125;&#x27;</span><br>    target_str2 = <span class="hljs-string">&#x27;&#123;&quot;mobile&quot;:&quot;$&#123;admin_login_tel&#125;&quot;, &quot;password&quot;:&quot;$&#123;default_pwd&#125;&quot;&#125;&#x27;</span><br>    one_context = Context()<br>    <span class="hljs-built_in">print</span>(one_context.loginAccount_parameterization(target_str2))<br><br></code></pre></td></tr></table></figure><h3 id="handle-path"><a href="#handle-path" class="headerlink" title="handle path"></a>handle path</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> os<br><br># __file__固定变量,os.path.abspath(__file__) 获取当前文件的路径<br># 获取项目根目录  使用大写比较规范<br># os.path.dirname（文件路径） 获取文件路径的目录路径<br>BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))<br><br><br># 获取测试数据datas所在目录的路径 os.path.<span class="hljs-keyword">join</span> 用于拼接路径<br>DATAS_DIR = os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;datas&#x27;</span>)<br><br># 获取配置文件configs所在的路径<br>CONFIGS_DIR = os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;configs&#x27;</span>)<br><br>LOGS_DIR = os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;logs&#x27;</span>)<br><br>CASES_DIR = os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;cases&#x27;</span>)<br><br>REPORTS_DIR = os.path.<span class="hljs-keyword">join</span>(BASE_DIR, <span class="hljs-string">&#x27;reports&#x27;</span>)<br><br><br># 获取文件所在路径<br><br>CONFIG_DIR_PATH = os.path.<span class="hljs-keyword">join</span>(CONFIGS_DIR,  <span class="hljs-string">&#x27;test.conf&#x27;</span>)<br><br>TEST_DATAS_FILE_PATH = os.path.<span class="hljs-keyword">join</span>(DATAS_DIR, <span class="hljs-string">&#x27;cases_test_prod.xlsx&#x27;</span>)<br><br>LOGS_FILE_PATH = os.path.<span class="hljs-keyword">join</span>(LOGS_DIR, <span class="hljs-string">&#x27;case.log&#x27;</span>)<br><br>ROTATING_LOGS_FILE_PATH = os.path.<span class="hljs-keyword">join</span>(LOGS_DIR, <span class="hljs-string">&#x27;case_log&#x27;</span>)<br><br>CONFIG_USE_ACCOUNTS_PATH = os.path.<span class="hljs-keyword">join</span>(CONFIGS_DIR, <span class="hljs-string">&#x27;user_accounts.conf&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="run-test执行入口"><a href="#run-test执行入口" class="headerlink" title="run_test执行入口"></a>run_test执行入口</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> unittest<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> libs <span class="hljs-keyword">import</span> HTMLTestRunnerNew<br><span class="hljs-keyword">from</span> scripts.constants <span class="hljs-keyword">import</span> REPORTS_DIR, CASES_DIR, LOGS_DIR<br><span class="hljs-keyword">from</span> scripts.handle_config <span class="hljs-keyword">import</span> config<br><span class="hljs-keyword">from</span> scripts.handle_removeFiles <span class="hljs-keyword">import</span> delete_file<br><br><span class="hljs-comment"># 测试结果写入测试报告前删除历史测试报告和测试日志</span><br>delete_file(REPORTS_DIR)<br>delete_file(LOGS_DIR)<br><br><span class="hljs-comment"># 拼接生成测试报告文件名</span><br>one_suite = unittest.defaultTestLoader.discover(CASES_DIR, <span class="hljs-string">&#x27;test*.py&#x27;</span>)<br>report_html_name = os.path.join(REPORTS_DIR, config(<span class="hljs-string">&#x27;report&#x27;</span>, <span class="hljs-string">&#x27;report_html_name&#x27;</span>))<br>curTime = time.strftime(<span class="hljs-string">&quot;%Y-%m-%d %H%M&quot;</span>, time.localtime())<br>report_name = report_html_name + <span class="hljs-string">&quot;_&quot;</span> + <span class="hljs-string">&#x27;&#123;0&#125;.html&#x27;</span>.<span class="hljs-built_in">format</span>(curTime)<br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # 把测试结果写入测试报告</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(report_name, mode=<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> save_file:<br>    runner = HTMLTestRunnerNew.HTMLTestRunner(stream=save_file,<br>                                              title=config(<span class="hljs-string">&quot;report&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>),<br>                                              description=config(<span class="hljs-string">&quot;report&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>),<br>                                              tester=config(<span class="hljs-string">&quot;report&quot;</span>, <span class="hljs-string">&quot;tester&quot;</span>),<br>                                              verbosity=config(<span class="hljs-string">&quot;report&quot;</span>, <span class="hljs-string">&quot;verbosity&quot;</span>), )<br>    runner.run(one_suite)<br></code></pre></td></tr></table></figure><h2 id="swagger部署和dubbo集成"><a href="#swagger部署和dubbo集成" class="headerlink" title="swagger部署和dubbo集成"></a>swagger部署和dubbo集成</h2><h3 id="dubbo-swagger接入"><a href="#dubbo-swagger接入" class="headerlink" title="dubbo swagger接入"></a>dubbo swagger接入</h3><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p>swagger ui 源码地址 <a href="https://github.com/swagger-api/swagger-ui">https://github.com/swagger-api/swagger-ui</a> ，swagger ui由nodejs开发，可以根据项目要求让前端人员进行二次开发  </p><p>swagger dubbo集成参考文档：<a href="https://github.com/Sayi/swagger-dubbo">https://github.com/Sayi/swagger-dubbo</a>  </p><p>swagger dubbo引入mock 参考文档：<a href="https://blog.csdn.net/gloomy_114/article/details/73500818">https://blog.csdn.net/gloomy_114/article/details/73500818</a>  </p><p>Swagger围绕着OpenAPI规范，提供了一套设计、构建、文档化rest api的开源工具。  </p><p>swagger-dubbo主要作用是swagger式的文档化+rest风格的HTTP模拟测试。  </p><p>通过swagger阅读接口文档<br>开发人员可以用它来自测服务接口，也可以用它来模拟别人的服务接口返回值<br>测试可以用它来验证接口的正确性，基于HTTP进行接口测试<br>swagger-dubbo从某些方面提高了内部开发测试的效率，注意的是，rest服务不适合对外(前端)提供，务必在服务端或者测试内部使用  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">Maven<br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.deepoove<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>swagger-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="swagger集成"><a href="#swagger集成" class="headerlink" title="swagger集成"></a>swagger集成</h4><ul><li><p>一. 使用注解 @EnableDubboSwagger开启dubbo的swagger文档。 </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.deepoove.swagger.dubbo.example;<br> <br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><span class="hljs-keyword">import</span> com.deepoove.swagger.dubbo.annotations.EnableDubboSwagger;<br> <br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableDubboSwagger</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerDubboConfig</span> &#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>二. 在spring的*-servlet.xml配置中，开启属性占位符的配置，开启Configuration注解，声明SwaggerDubboConfig。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">&lt;mvc:annotation-driven/&gt;<br>&lt;<span class="hljs-keyword">context</span>:annotation-<span class="hljs-keyword">config</span> /&gt;<br>&lt;bean <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;com.wt.swagger.dubbo.config.SwaggerDubboConfig&quot;</span> /&gt;<br>&lt;<span class="hljs-keyword">context</span>:<span class="hljs-keyword">property</span>-placeholder /&gt;<br></code></pre></td></tr></table></figure></li><li><p>三.配置跨域支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 跨域支持，Spring4.3.10+，低版本请设置拦截器开启跨域 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:cors</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/swagger-dubbo/**&quot;</span> <span class="hljs-attr">allowed-origins</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:cors</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>四.配置项修改</p></li></ul><p>swagger-dubbo默认无需任何配置，但是也提供了一些可选项。我们这里强制大家都需要把配置给添加进去。  </p><p>如果是没有接入apollo配置中心，则在新增文件swagger-dubbo.properties，加载配置文件，并且在antx配置文件中添加相应的配置项。  </p><p> &lt;context:property-placeholder location&#x3D;”classpath*:swagger-dubbo.properties” &#x2F;&gt;  </p><p>配置项说明：<br>#http请求地址，默认为<a href="http://ip:port/h/com.XXX.XxService/method">http://ip:port/h/com.XXX.XxService/method</a><br>swagger.dubbo.http&#x3D;h  </p><p>#dubbo 服务版本号<br>swagger.dubbo.application.version &#x3D; 1.0<br>#dubbo服务groupId<br>swagger.dubbo.application.groupId &#x3D; com.wt<br>#dubbo服务artifactId<br>swagger.dubbo.application.artifactId &#x3D; payment-service  </p><p>#rpc zk调用 or 本地调用<br>swagger.dubbo.cluster &#x3D; rpc  </p><p>#是否启用swagger-dubbo，默认为true,如果是生产环境就设置为false<br>swagger.dubbo.enable &#x3D; true  </p><ul><li>五.备注</li></ul><p>以上配置步骤，都是基于项目中已经引入了springmvc相关依赖为前提，如果项目中没有则需要自行加入。  </p><p>集成已经完毕，启动web容器，浏览器访问 <a href="http://ip:port/context/swagger-dubbo/api-docs查看文档。">http://ip:port/context/swagger-dubbo/api-docs查看文档。</a>  </p><p>这里已payment为例：<a href="http://120.26.205.32:9023/payment/swagger-dubbo/api-docs">http://120.26.205.32:9023/payment/swagger-dubbo/api-docs</a>  </p><p>swagger-ui查看文档<br>swagger-ui访问地址如下：<a href="http://101.37.117.177:8080/static/#/">http://101.37.117.177:8080/static/#/</a>  </p><h2 id="Swagger注解规则"><a href="#Swagger注解规则" class="headerlink" title="Swagger注解规则"></a>Swagger注解规则</h2><p>目标：通过swagger和dubbo集成在代码中添加注释自动在swagger ui中生成接口文档</p><p>常用注解：</p><ul><li>@Api()用于类，表示标识这个类是swagger的资源 </li><li>@ApiOperation()用于方法，表示一个http请求的操作，在我们这边表示一个rpc请求</li><li>@ApiParam()用于方法，参数，字段说明，表示对参数的添加元数据（说明或是否必填等） </li><li>@ApiModel()用于类，表示对类进行说明，用于参数用实体类接收 </li><li>@ApiModelProperty()用于方法，字段，表示对model属性的说明或者数据操作更改 </li><li>@ApiIgnore()用于类，方法，方法参数，表示这个方法或者类被忽略</li></ul><p>具体使用举例说明：<br>@Api()<br>用于类；表示标识这个类是swagger的资源<br>tags–表示说明<br>value–也是说明，可以使用tags替代<br>但是tags如果有多个值，会生成多个list</p><p>@Api(value&#x3D;”用户service”,tags&#x3D;{“用户操作接口”})</p><p>public interface UserService {</p><p>}<br>@ApiOperation() 用于方法；表示一个http请求的操作<br>value用于方法描述<br>notes用于提示内容<br>tags可以重新分组（视情况而用）<br>@ApiParam() 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等）<br>name–参数名<br>value–参数说明<br>required–是否必填</p><p>@Api(value&#x3D;”用户service”,tags&#x3D;{“用户操作接口”})<br>public interface UserService {<br>     @ApiOperation(value&#x3D;”获取用户信息”,tags&#x3D;{“获取用户信息copy”},notes&#x3D;”注意问题点”)<br>     public User getUserInfo(@ApiParam(name&#x3D;”id”,value&#x3D;”用户id”,required&#x3D;true) Long id,@ApiParam(name&#x3D;”username”,value&#x3D;”用户名”) String username) {<br>      &#x2F;&#x2F;业务逻辑<br>     }<br>}</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@ApiModel</span>()用于类 ；表示对类进行说明，用于参数用实体类接收 <br>value–表示对象名 <br>description–描述 <br>都可省略 <br><span class="hljs-meta">@ApiModelProperty</span>()用于方法，字段； 表示对model属性的说明或者数据操作更改 <br>value–字段说明 <br>name–重写属性名字 <br>dataType–重写属性类型 <br>required–是否必填 <br>example–举例说明 <br>hidden–隐藏<br><br><span class="hljs-meta">@ApiModel</span>(value=<span class="hljs-string">&quot;user对象&quot;</span>,description=<span class="hljs-string">&quot;用户对象user&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Serializable</span></span></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">1</span>L;<br>     <span class="hljs-meta">@ApiModelProperty</span>(value=<span class="hljs-string">&quot;用户名&quot;</span>,name=<span class="hljs-string">&quot;username&quot;</span>,example=<span class="hljs-string">&quot;xingguo&quot;</span>)<br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> username;<br>     <span class="hljs-meta">@ApiModelProperty</span>(value=<span class="hljs-string">&quot;状态&quot;</span>,name=<span class="hljs-string">&quot;state&quot;</span>,required=<span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">private</span> Integer state;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> password;<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> nickName;<br>      <span class="hljs-keyword">private</span> Integer isDeleted;<br> <br>      <span class="hljs-meta">@ApiModelProperty</span>(value=<span class="hljs-string">&quot;id数组&quot;</span>,hidden=<span class="hljs-literal">true</span>)<br>      <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span>[] ids;<br>      <span class="hljs-keyword">private</span> List&lt;<span class="hljs-keyword">String</span>&gt; idList;<br>     <span class="hljs-comment">//省略get/set</span><br>&#125;<br> <br><span class="hljs-meta">@ApiOperation</span>(<span class="hljs-string">&quot;更改用户信息&quot;</span>)<br><span class="hljs-keyword">public</span> int updateUserInfo(<span class="hljs-meta">@ApiParam</span>(name=<span class="hljs-string">&quot;用户对象&quot;</span>,value=<span class="hljs-string">&quot;传入json格式&quot;</span>,required=<span class="hljs-literal">true</span>) User user)&#123;<br>     int num = userService.updateUserInfo(user);<br>     <span class="hljs-keyword">return</span> num;<br>  &#125; <br></code></pre></td></tr></table></figure><h2 id="Http接口接入swagger步骤"><a href="#Http接口接入swagger步骤" class="headerlink" title="Http接口接入swagger步骤"></a>Http接口接入swagger步骤</h2><p>实现自动生成接口文档<br>步骤如下：  </p><ul><li>1、将framework-server版本号由1.5.5升级至1.5.6：<br>&lt;framework-server.version&gt;1.5.6&lt;&#x2F;framework-server.version&gt;</li><li>2、在application.properties添加以下配置：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#是否开启swagger生产环境需要设置为false<br>swagger<span class="hljs-selector-class">.enable</span> = true<br><span class="hljs-selector-id">#swagger</span> api-docs版本号<br>swagger<span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.info</span><span class="hljs-selector-class">.version</span> = <span class="hljs-number">1.0</span>.<span class="hljs-number">0</span><br><span class="hljs-selector-id">#swagger</span> api-docs标题<br>swagger<span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.info</span><span class="hljs-selector-class">.title</span> = framework-example api文档<br>#swagger扫描annotation包路径，该路径要包含接口和实体类<br>swagger<span class="hljs-selector-class">.resource</span><span class="hljs-selector-class">.package</span> = com<span class="hljs-selector-class">.meitong</span><span class="hljs-selector-class">.framework</span><span class="hljs-selector-class">.server</span>.example<br></code></pre></td></tr></table></figure></li><li>3、将接口和实体类以及接口入参添加swagger相关注解，示例如下：<br>接口：<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/restResource&quot;</span>)<br><span class="hljs-variable">@Consumes</span>(MediaType.APPLICATION_JSON)<br><span class="hljs-variable">@Produces</span>(MediaType.APPLICATION_JSON)<br><span class="hljs-variable">@Api</span>(value = <span class="hljs-string">&quot;Rest resource operations&quot;</span>)<br>public interface RestResource &#123;<br>    <span class="hljs-variable">@GET</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/invokeGet/&#123;id&#125;/&#123;name&#125;&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;invokeGet示例&quot;</span>, notes = <span class="hljs-string">&quot;invokeGet说明&quot;</span>, response = List.class, httpMethod = <span class="hljs-string">&quot;GET&quot;</span>)<br>    List&lt;String&gt; <span class="hljs-built_in">invokeGet</span>(<span class="hljs-variable">@PathParam</span>(<span class="hljs-string">&quot;id&quot;</span>) Integer id, <span class="hljs-variable">@PathParam</span>(<span class="hljs-string">&quot;name&quot;</span>) String name);<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * invokePost method</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param ids</span><br><span class="hljs-comment">     * @return List&lt;String&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">@POST</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/invokePost&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;invokePost示例&quot;</span>, notes = <span class="hljs-string">&quot;invokePost说明&quot;</span>, response = List.class, httpMethod = <span class="hljs-string">&quot;POST&quot;</span>)<br>    List&lt;String&gt; <span class="hljs-built_in">invokePost</span>(List&lt;Integer&gt; ids);<br>    <span class="hljs-variable">@PUT</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/invokePut&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;invokePut示例&quot;</span>, notes = <span class="hljs-string">&quot;invokePut说明&quot;</span>, response = Void.class, httpMethod = <span class="hljs-string">&quot;PUT&quot;</span>)<br>    void <span class="hljs-built_in">invokePut</span>(List&lt;String&gt; names);<br>    <span class="hljs-variable">@DELETE</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/invokeDelete/&#123;id&#125;&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;invokeDelete示例&quot;</span>, notes = <span class="hljs-string">&quot;invokeDelete说明&quot;</span>, response = Void.class, httpMethod = <span class="hljs-string">&quot;DELETE&quot;</span>)<br>    void <span class="hljs-built_in">invokeDelete</span>(<span class="hljs-variable">@PathParam</span>(<span class="hljs-string">&quot;id&quot;</span>) Integer id);<br><br>    <span class="hljs-variable">@GET</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/getAllUser&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取所有的用户&quot;</span>,notes = <span class="hljs-string">&quot;使用说明&quot;</span>,response = User.class,responseContainer = <span class="hljs-string">&quot;List&quot;</span>,httpMethod = <span class="hljs-string">&quot;GET&quot;</span>)<br>    List&lt;User&gt; <span class="hljs-built_in">getAllUser</span>();<br>    <span class="hljs-variable">@POST</span><br>    <span class="hljs-variable">@Path</span>(<span class="hljs-string">&quot;/insert&quot;</span>)<br>    <span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;新增用户&quot;</span>,notes = <span class="hljs-string">&quot;使用说明&quot;</span>,response = Void.class,httpMethod = <span class="hljs-string">&quot;POST&quot;</span>)<br>    void <span class="hljs-built_in">insert</span>(<span class="hljs-variable">@ApiParam</span>(value = <span class="hljs-string">&quot;用户信息&quot;</span>,name = <span class="hljs-string">&quot;user&quot;</span>,required = true) User user);<br>&#125;<br>实体类：<br><span class="hljs-variable">@ApiModel</span>(description = <span class="hljs-string">&quot;用户信息&quot;</span>)<br>public class User &#123;<br>    <span class="hljs-variable">@ApiModelProperty</span>(value = <span class="hljs-string">&quot;用户名&quot;</span>,required = true)<br>    private String userName;<br>    <span class="hljs-variable">@ApiModelProperty</span>(value = <span class="hljs-string">&quot;用户ID&quot;</span>,required = true)<br>    private String userId;<br>    <span class="hljs-comment">//get and set</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>4.接口文档访问：<br><a href="http://ip:port/swagger.json">http://ip:port/swagger.json</a></li><li>5.完成系统接入以后，将步骤4生成的接口文档地址汇总发到我这边。我需要将这些接口集成到swagger-ui中</li><li>6.swagger-ui访问地址<br><a href="http://101.37.117.177:8080/static/#/">http://101.37.117.177:8080/static/#/</a></li></ul><p>如果集成到swagger-ui中会存在跨域请求问题，所以需要添加一个全局的过滤器:</p><p>com.meitong.framework.server.filters.CORSFilter</p><h2 id="swagger接口文档变更规则及邮件发送"><a href="#swagger接口文档变更规则及邮件发送" class="headerlink" title="swagger接口文档变更规则及邮件发送"></a>swagger接口文档变更规则及邮件发送</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>为了方便接口测试用例后期维护和对变更点及时测试，接口变更内容要及时通知到测试组，为了减少开发测试之间的沟通成本，开发swagger邮件通知功能，如果监控到swagger有内容变更，发送通知邮件到测试组。</p><h3 id="一：接口版本注释添加规则："><a href="#一：接口版本注释添加规则：" class="headerlink" title="一：接口版本注释添加规则："></a>一：接口版本注释添加规则：</h3><ul><li><p>无论修改接口任何东西 只要修改类或方法上的版本号 邮件即会通知到测试组</p></li><li><p>swagger上所有系统接口注释添加时初始版本号为1.0.0 标名在类上</p></li><li><p>此版本号只是为了接口变更时能及时通知到测试组，无实际意义和版本迭代的版本无关</p></li><li><p>1.首先类和方法上都可以添加版本号 在类上添加版本号1.0.0默认此类下的所有方法都是1.0.0</p></li><li><p>2.方法上版本号优先级大于类上版本号优先级，如果只有类上有版本号假设1.0.0，类下的一个方法发生变更比如变成1.0.1 则只有此方法版本为1.0.1<br>  其他未标明版本的方法仍和类的版本一致，不会邮件提醒 。只有发生变更的方法会发送接口变更邮件到测试组</p></li></ul><h3 id="二：版本变更规则：假设初始版本号为1-0-0"><a href="#二：版本变更规则：假设初始版本号为1-0-0" class="headerlink" title="二：版本变更规则：假设初始版本号为1.0.0"></a>二：版本变更规则：假设初始版本号为1.0.0</h3><ul><li>1.逻辑变更 只变更第一位 第一位+1      版本号变为2.0.0  </li><li>2.参数变更 只变更第二位 第二位+1     版本号变为1.1.0</li><li>3.返回值变更 只变更第三位 第三位+1  版本号变为1.0.1<br>以此类推<br>邮件功能已修改，大家需要重启一下应用<br>邮件展示如下：</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-22-37.png"> </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-22-44.png">  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-22-53.png"></p><h2 id="configparser配置文件解析"><a href="#configparser配置文件解析" class="headerlink" title="configparser配置文件解析"></a>configparser配置文件解析</h2><h3 id="为什么要做配置文件："><a href="#为什么要做配置文件：" class="headerlink" title="为什么要做配置文件："></a>为什么要做配置文件：</h3><p>将所有的代码和配置都变成模块化可配置化，这样就提高了代码的重用性，不用都去修改代码内部，这个就是我们逐步<br>要做的事情，可配置化</p><p>configparser模块定义了ConfigParser类。 ConfigParser类实现一种基本的配置文件解析器语言，该语言提供的结构类似于 .ini 文件中的结构</p><h4 id="configparser用法"><a href="#configparser用法" class="headerlink" title="configparser用法"></a>configparser用法</h4><ul><li>1）创建configparser对象，并调用read()函数打开配置文件，里面填的参数是地址</li><li>2）配置文件的格式是[]包含的是section,section下有option&#x3D;value这样的键值对</li><li>3.依据section来读取相应的配置数据 读 写</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.创建configparser对象<br>import configparser<br><span class="hljs-keyword">cf</span>=configparser.ConfigParser()<br><br><span class="hljs-number">2</span>.从配置文件中读取数据<br>import os<br><span class="hljs-keyword">cf</span>.<span class="hljs-keyword">read</span>(os.<span class="hljs-built_in">getcwd</span>()+<span class="hljs-string">&quot;/config.conf&quot;</span>)<br><br>#读取所有section<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">cf</span>.sections()) #返回列表形式[<span class="hljs-string">&#x27;mysql_info&#x27;</span>, <span class="hljs-string">&#x27;test_addSection&#x27;</span>]<br><br>#读取section下的option<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">cf</span>.<span class="hljs-keyword">options</span>(section=<span class="hljs-string">&quot;mysql_info&quot;</span>))#只有key值 <br>========输出=================<br>[<span class="hljs-string">&#x27;mysql_host&#x27;</span>, <span class="hljs-string">&#x27;mysql_port&#x27;</span>, <span class="hljs-string">&#x27;mysql_db&#x27;</span>, <span class="hljs-string">&#x27;mysql_user&#x27;</span>, <span class="hljs-string">&#x27;mysql_passwd&#x27;</span>]<br><br>#读取键值对<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">cf</span>.<span class="hljs-built_in">items</span>(section=<span class="hljs-string">&quot;mysql_info&quot;</span>)) <br>=================输出=====================  <br>#键值对 [(<span class="hljs-string">&#x27;mysql_host&#x27;</span>, <span class="hljs-string">&#x27;120.76.42.189&#x27;</span>), (<span class="hljs-string">&#x27;mysql_port&#x27;</span>, <span class="hljs-string">&#x27;3306&#x27;</span>), (<span class="hljs-string">&#x27;mysql_db&#x27;</span>, <span class="hljs-string">&#x27;future&#x27;</span>), (<span class="hljs-string">&#x27;mysql_user&#x27;</span>, <span class="hljs-string">&#x27;futurevistor&#x27;</span>), (<span class="hljs-string">&#x27;mysql_passwd&#x27;</span>, <span class="hljs-string">&#x27;123456&#x27;</span>)]<br><br>#读section里option<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">cf</span>.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;mysql_info&quot;</span>,<span class="hljs-string">&quot;mysql_db&quot;</span>))     #future<br><span class="hljs-keyword">print</span>(<span class="hljs-keyword">cf</span>.getint(<span class="hljs-string">&quot;mysql_info&quot;</span>,<span class="hljs-string">&quot;mysql_port&quot;</span>)) #<span class="hljs-number">3306</span><br><br>#写<br>#添加option，修改也用<span class="hljs-keyword">set</span><br><span class="hljs-keyword">cf</span>.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;mysql_info&quot;</span>,<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;mysql5.7&quot;</span>)<br><br>#添加section<br><span class="hljs-keyword">cf</span>.add_section(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">cf</span>.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;test&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>,<span class="hljs-string">&quot;female&quot;</span>)<br><br>#添加完option section后都要打开文件写入<br>with <span class="hljs-keyword">open</span>(os.<span class="hljs-built_in">getcwd</span>()+<span class="hljs-string">&quot;/config.conf&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">cfile</span>:<br>    <span class="hljs-keyword">cf</span>.<span class="hljs-keyword">write</span>(<span class="hljs-keyword">cfile</span>)  #文件流写到文件中去<br></code></pre></td></tr></table></figure><h2 id="openpyxl-excel文件解析"><a href="#openpyxl-excel文件解析" class="headerlink" title="openpyxl excel文件解析"></a>openpyxl excel文件解析</h2><p>前言</p><ul><li>当你做接口自动化测试时，测试用例逐渐变多情况下，如果所有测试用例都通过代码管理将会使得代码十分臃肿，而且维护成本会很高；</li><li>所以我们一般会通过Excel去管理所有的测试用例，而openpyxl库提供了访问Excel的方法</li></ul><p>openpyxl简单介绍<br>一个Python库，用于读取&#x2F;写入Excel 2010  xlsx 、xlsm 、xltx 、xltm 文件<br>不能操作 xls 文件</p><h4 id="openpyxl简单概念"><a href="#openpyxl简单概念" class="headerlink" title="openpyxl简单概念"></a>openpyxl简单概念</h4><ul><li>Workbook：excel工作表</li><li>Sheet：工作表中的一张表</li><li>Cell：其中的一个单元格<br>简单步骤：打开Workbook，选中Sheet，操作Cell</li></ul><h4 id="openpyxl简单使用"><a href="#openpyxl简单使用" class="headerlink" title="openpyxl简单使用"></a>openpyxl简单使用</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span>import openpyxl<br><span class="hljs-number"> 2 </span><br><span class="hljs-number"> 3 </span>if __name__ == &#x27;__main__&#x27;:<br><span class="hljs-number"> 4 </span>    path = &#x27;F:/imocInterface/case/imooc.xlsx&#x27;<br><span class="hljs-number"> 5 </span>    <span class="hljs-comment"># 读取excel文件</span><br><span class="hljs-number"> 6 </span>    workbook = openpyxl.load_workbook(path)<br><span class="hljs-number"> 7 </span>    <span class="hljs-comment"># 读取所有sheet</span><br><span class="hljs-number"> 8 </span>    sheet = workbook.get_sheet_names()<br><span class="hljs-number"> 9 </span>    <span class="hljs-comment"># 获取某个sheet</span><br>10     sheet = workbook[sheet[0]]<br>11     <span class="hljs-comment"># 获取某个cell的值</span><br>12     cell_val = sheet.cell(row=2, column=2).value<br>13     print(cell_val)<br></code></pre></td></tr></table></figure><h4 id="包含知识点-1"><a href="#包含知识点-1" class="headerlink" title="包含知识点"></a>包含知识点</h4><ul><li>调用 load_workbook() 等同于调用 open() </li><li>第8、10行代码可能浓缩成一行代码 workbook.get_sheet_by_name(“sheet的名字”) ，前提是你得知道sheet的命名<br> cell(row, column, value&#x3D;None) 三个参数分别是：行，列，值；若设置了value相当于赋值操作，会覆盖原本的值</li></ul><h3 id="openpyxl操作单元格"><a href="#openpyxl操作单元格" class="headerlink" title="openpyxl操作单元格"></a>openpyxl操作单元格</h3><h4 id="访问单个cell"><a href="#访问单个cell" class="headerlink" title="访问单个cell"></a>访问单个cell</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>    # 方式一：获取A4单元格的值<br><span class="hljs-symbol">2 </span>    cell_val = sheet[<span class="hljs-comment">&#x27;A4&#x27;].value</span><br><span class="hljs-symbol">3 </span>    # 方式二：获取第二行,第二列的单元格的值<br><span class="hljs-symbol">4 </span>    cell_val = sheet.cell(row=<span class="hljs-number">2</span>, column=<span class="hljs-number">2</span>).value<br></code></pre></td></tr></table></figure><h4 id="访问多个cell"><a href="#访问多个cell" class="headerlink" title="访问多个cell"></a>访问多个cell</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span>    <span class="hljs-comment"># A1-B3的单元格 共6个</span><br><span class="hljs-number"> 2 </span>    cell_range = sheet[&#x27;A1&#x27;:&#x27;B3&#x27;]<br><span class="hljs-number"> 3 </span><br><span class="hljs-number"> 4 </span>    <span class="hljs-comment"># A1-A3的单元格 共3个</span><br><span class="hljs-number"> 5 </span>    cell_range = sheet[&#x27;A1:A3&#x27;]<br><span class="hljs-number"> 6 </span><br><span class="hljs-number"> 7 </span>    <span class="hljs-comment"># 第十行的单元格</span><br><span class="hljs-number"> 8 </span>    cell_range = sheet[10]<br><span class="hljs-number"> 9 </span><br>10     <span class="hljs-comment"># 第1、2行的单元格</span><br>11     cell_range = sheet[1:2]<br></code></pre></td></tr></table></figure><p> 注意：以上方法返回的是都是cell对象组成tuple</p><h4 id="获取指定范围的cell"><a href="#获取指定范围的cell" class="headerlink" title="获取指定范围的cell"></a>获取指定范围的cell</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">1     # 返回行<br>2     <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> sheet.iter_rows(<span class="hljs-attribute">min_row</span>=1, <span class="hljs-attribute">min_col</span>=1, <span class="hljs-attribute">max_col</span>=3, <span class="hljs-attribute">max_row</span>=2):<br>3         <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> col:<br>4             <span class="hljs-built_in">print</span>(cell)<br>5 <br>6     # 返回列<br>7     <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> sheet.iter_cols(<span class="hljs-attribute">min_row</span>=1, <span class="hljs-attribute">min_col</span>=1, <span class="hljs-attribute">max_col</span>=3, <span class="hljs-attribute">max_row</span>=2):<br>8         <span class="hljs-keyword">for</span> cell <span class="hljs-keyword">in</span> col:<br>9             <span class="hljs-built_in">print</span>(cell)<br><br>获取指定范围cell的测试结果<br><span class="hljs-comment"># 返回行</span><br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.A1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.B1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.C1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.A2&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.B2&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.C2&gt;<br><br><span class="hljs-comment"># 返回列</span><br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.A1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.A2&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.B1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.B2&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.C1&gt;<br>&lt;Cell <span class="hljs-string">&#x27;Sheet1&#x27;</span>.C2&gt;<br></code></pre></td></tr></table></figure><p>官方提醒：出于性能考虑， sheet.iter_cols() 方法不支持在只读模式使用</p><h4 id="获取sheet内所有行和列的cell"><a href="#获取sheet内所有行和列的cell" class="headerlink" title="获取sheet内所有行和列的cell"></a>获取sheet内所有行和列的cell</h4><figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stan"> <span class="hljs-number">1</span>     <span class="hljs-comment"># 以列的形式,获取sheet的全部cell</span><br> <span class="hljs-number">2</span>     <span class="hljs-title">data</span> = <span class="hljs-type">tuple</span>(sheet.columns)<br> <span class="hljs-number">3</span> <br> <span class="hljs-number">4</span>     <span class="hljs-comment"># 以行的形式,获取sheet的全部cell</span><br> <span class="hljs-number">5</span>     <span class="hljs-title">data</span> = <span class="hljs-type">tuple</span>(sheet.<span class="hljs-built_in">rows</span>)<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span>     <span class="hljs-comment"># 获取所有数据</span><br> <span class="hljs-number">8</span>     <span class="hljs-title">data</span> = <span class="hljs-type">tuple</span>(sheet.values)<br> <span class="hljs-number">9</span>     <span class="hljs-comment"># 指定返回某一行数据</span><br><span class="hljs-number">10</span>     <span class="hljs-built_in">print</span>(<span class="hljs-title">data</span>[<span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>注意： sheet.rows 返回的是一个对象，需要用 tuple() 才能将对象转换成tuple</p><p>官方提醒：出于性能考虑， sheet.cloumns 方法不支持在只读模式使用</p><h4 id="获取sheet的行数、列数"><a href="#获取sheet的行数、列数" class="headerlink" title="获取sheet的行数、列数"></a>获取sheet的行数、列数</h4><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap"><span class="hljs-number"> 1 </span>    <span class="hljs-comment"># 获取sheet最大行</span><br><span class="hljs-number"> 2 </span>    data = sheet.max_row<br><span class="hljs-number"> 3 </span><br><span class="hljs-number"> 4 </span>    <span class="hljs-comment"># 获取sheet最多列</span><br><span class="hljs-number"> 5 </span>    data = sheet.max_column<br><span class="hljs-number"> 6 </span><br><span class="hljs-number"> 7 </span>    <span class="hljs-comment"># 获取sheet最小行</span><br><span class="hljs-number"> 8 </span>    data = sheet.min_row<br><span class="hljs-number"> 9 </span><br>10     <span class="hljs-comment"># 获取sheet最小列</span><br>11     data = sheet.min_column<br></code></pre></td></tr></table></figure><h4 id="openpyxl写入数据"><a href="#openpyxl写入数据" class="headerlink" title="openpyxl写入数据"></a>openpyxl写入数据</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>    workbook = openpyxl.load_workbook(path)<br><span class="hljs-symbol">2 </span>    sheet = workbook.active<br><span class="hljs-symbol">3 </span>    sheet.cell(row=<span class="hljs-number">2</span>, col=<span class="hljs-number">2</span>, value=<span class="hljs-string">&quot;213&quot;</span>)<br><span class="hljs-symbol">4 </span>    workbook.<span class="hljs-keyword">save</span>(filename=path)<br></code></pre></td></tr></table></figure><h4 id="包含知识点-2"><a href="#包含知识点-2" class="headerlink" title="包含知识点"></a>包含知识点</h4><ul><li>写入数据的文件需要是可写文件，需要已关闭；若打开着excel的话无法写入会报 PermissionError: [Errno 13] Permission denied: ‘XXXXX.xlsx’<br>其实就是四部曲：获取excel - 执行 workbook.active - 赋值操作 - 保存文件<br>赋值操作还可以是  sheet[“B2”] &#x3D; “213” ，等价于上面第三行代码<br>save() 会覆盖原有文件，不会有提醒</li></ul><h2 id="request-发送接口请求"><a href="#request-发送接口请求" class="headerlink" title="request 发送接口请求"></a>request 发送接口请求</h2><p>Python中常用的http请求模块<br>python中的http包有urllib,urllib2,httplib等但是都需要了解较多的http原理才能编码<br>借助requests包可以在较高的抽象层次上完成http交互过程的开发<br>比urllib好用  </p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>pip install requests命令</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><ul><li>1）requests包内嵌了urllib3,自动支持http长连接，连接池等功能</li><li>2）requests支持http的HEAD GET POST PUT OPTIONS DELETE PATCH等请求</li><li>3）import requests 导入模块</li></ul><h3 id="Requests常用的方法"><a href="#Requests常用的方法" class="headerlink" title="Requests常用的方法"></a>Requests常用的方法</h3><ul><li>1.发送请求 requests.get(URL)也支持post delete put head option方法，我们掌握get  post就好</li><li>2.传递URL&amp;参数 r&#x3D;requests.get(URL,params)通过打印r.url输出该URL,你能看到URL已被正确编码</li><li>3.查看返回的结果：r.text</li><li>4.查看返回结果的编码：r.encoding</li><li>5.转换结果成dict格式  r.json()</li></ul><h3 id="可以直接通过request-Session-来管理cookie"><a href="#可以直接通过request-Session-来管理cookie" class="headerlink" title="可以直接通过request.Session()来管理cookie"></a>可以直接通过request.Session()来管理cookie</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestsHandler</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.session = requests.Session()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">self, url, method, params=<span class="hljs-literal">None</span>, data=<span class="hljs-literal">None</span>, json=<span class="hljs-literal">None</span>, **kwargs </span>):<br>        <span class="hljs-string">&quot;&quot;&quot;访问一个接口，你可以使用 get 请求，也可以使用 post 请求， put, delete</span><br><span class="hljs-string">        请求方法：method:</span><br><span class="hljs-string">        请求地址： url</span><br><span class="hljs-string">        请求参数：params, data, json</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        res = <span class="hljs-variable language_">self</span>.session.request(method, url, params=params, data=data, json=json, **kwargs)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> res.json()<br>        <span class="hljs-keyword">except</span> ValueError:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;not json&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_session</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.session.close()<br></code></pre></td></tr></table></figure><p><img src="/the-nuo/picture/Snipaste_57.png" alt="cookie.session.token区别"></p><h2 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h2><ul><li>py3已将mock集成到unittest库中 </li><li>为的就是更好的进行单元测试  </li><li>简单理解，模拟接口返回参数</li><li>通俗易懂，直接修改接口返回参数的值</li><li>官方文档：<a href="https://docs.python.org/zh-cn/3/library/unittest.mock.html">https://docs.python.org/zh-cn/3/library/unittest.mock.html</a></li></ul><h3 id="mock作用"><a href="#mock作用" class="headerlink" title="mock作用"></a>mock作用</h3><h4 id="解决依赖问题，达到解耦作用"><a href="#解决依赖问题，达到解耦作用" class="headerlink" title="解决依赖问题，达到解耦作用"></a>解决依赖问题，达到解耦作用</h4><p>当我们测试某个目标接口（模块）时，该接口依赖其他接口，当被依赖的接口未开发完成时，可以用mock模拟被依赖接口，完成目标接口的测试</p><h4 id="模拟复杂业务的接口"><a href="#模拟复杂业务的接口" class="headerlink" title="模拟复杂业务的接口"></a>模拟复杂业务的接口</h4><p>当我们测试某个目标接口（模块），该接口依赖一个非常复杂的接口时，可以用mock来模拟这个复杂的业务接口；也解决接口依赖一样的原理</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>如果某个接口（模块）未开发完成时，又需要编写测试用例，则可以通过mock模拟该接口（模块）进行测试</p><h4 id="前后端联调"><a href="#前后端联调" class="headerlink" title="前后端联调"></a>前后端联调</h4><p>前端开发的页面需要根据后端返回的不同状态码展示不同的页面，当后端接口未开发完成时，也可通过mock来模拟后端接口返回自己想要的数据</p><h3 id="mock的“过”"><a href="#mock的“过”" class="headerlink" title="mock的“过”"></a>mock的“过”</h3><p>这里说mock的过，主要是让开发和测试不要过分的依赖&#x2F;相信mock接口。mock接口后，即便已经做了非常充分的测试，当把mock接口换成实际接口后，测试&#x2F;开发也必须把之前的测试重新做一遍，否则便可能出现“你以为对的接口，实际却错了”。    </p><p>使用mock时，切记的几点：</p><ul><li>1） 当把mock接口换成实际接口后，测试&#x2F;开发也必须把之前的测试重新做一遍。<br>ps:<br>当你使用mock接口来提高效率，请注意：你的工作量其实是比 直接只用实际接口 多了 一倍的。如果测试时，偷懒，替换成实际接口后，只是简单测试，那么 当实际接口和mock预期接口有差异时，故障便和你相遇了。<br>建议： mock接口只能主流程联调&#x2F; 异常返回测试，不要过分依赖mock接口进行测试。</li><li>2） 测试完毕，上线前，请一定确保 为了mock而做的相关代码&#x2F;配置文件的修改，已经完全恢复了。<br>建议：上线checklist中条条列出，并上线前review</li></ul><h3 id="mock类解读"><a href="#mock类解读" class="headerlink" title="mock类解读"></a>mock类解读</h3><p>安装： pip install mock<br>导入： from mock import Mock</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Mock</span>(<span class="hljs-symbol">spec</span>=<span class="hljs-symbol">None,<span class="hljs-symbol">side_effect</span></span>=<span class="hljs-symbol">None,<span class="hljs-symbol">return_value</span></span>=<span class="hljs-symbol">DEFFAULT,<span class="hljs-symbol">name</span></span>=<span class="hljs-symbol">None</span>) <br></code></pre></td></tr></table></figure><ul><li>secp：定义mock对象的属性值，可以是列表，字符串，甚至一个对象或者实例 </li><li>side_effect：可以用来抛出异常或者动态改变返回值，它必须是一个iterator（列表），它会覆盖return_value</li><li>return_value：定义mock方法的返回值，它可以是一个值，可以是一个对象（如果存在side_effect参数那这个就没有用，也就是不能同时用）</li><li>name：作为mock对象的一个标识，在print时可以看到</li></ul><h3 id="mock实际使用"><a href="#mock实际使用" class="headerlink" title="mock实际使用"></a>mock实际使用</h3><h4 id="一个未开发完成的功能如何测试？"><a href="#一个未开发完成的功能如何测试？" class="headerlink" title="一个未开发完成的功能如何测试？"></a>一个未开发完成的功能如何测试？</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-number">1</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, a, b</span>):<br> <span class="hljs-number">2</span>     <span class="hljs-string">&quot;&quot;&quot;两个数相加&quot;&quot;&quot;</span><br> <span class="hljs-number">3</span>     <span class="hljs-keyword">pass</span><br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span> <br> <span class="hljs-number">6</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSub</span>(unittest.TestCase):<br> <span class="hljs-number">7</span>     <span class="hljs-string">&quot;&quot;&quot;测试两个数相加用例&quot;&quot;&quot;</span><br> <span class="hljs-number">8</span> <br> <span class="hljs-number">9</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_sub</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">10</span>         <span class="hljs-comment"># 创建一个mock对象 return_value代表mock一个数据,将mock对象赋予给被测函数</span><br><span class="hljs-number">11</span>         add = mock.Mock(return_value=<span class="hljs-number">15</span>)<br><span class="hljs-number">16</span>         <span class="hljs-comment"># 断言实际结果和预期结果</span><br><span class="hljs-number">17</span>         <span class="hljs-variable language_">self</span>.assertEqual(add(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>), <span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><h4 id="一个完成开发的功能如何测试？"><a href="#一个完成开发的功能如何测试？" class="headerlink" title="一个完成开发的功能如何测试？"></a>一个完成开发的功能如何测试？</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubClass</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, a, b</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;两个数相加&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> a + b<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSub</span>(unittest.TestCase):-<br>    <span class="hljs-string">&quot;&quot;&quot;测试两个数相加用例&quot;&quot;&quot;</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_add2</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 初始化被测函数类实例</span><br>        sub = SubClass()<br>        <span class="hljs-comment"># 创建一个mock对象 return_value代表mock一个数据</span><br>        <span class="hljs-comment"># 传递side_effect关键字参数, 会覆盖return_value参数值, 使用真实的add方法测试</span><br>        sub.add = Mock(return_value=<span class="hljs-number">15</span>, side_effect=sub.add)<br>        <span class="hljs-comment"># 调用被测函数</span><br>        result = sub.add(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>)<br>        <span class="hljs-comment"># 断言实际结果和预期结果</span><br>        <span class="hljs-variable language_">self</span>.assertEqual(result, <span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><ul><li><p>side_effect：这里给的参数值是sub.add相当于add方法的地址，当我们调用add方法时就会调用真实的add方法</p></li><li><p>简单理解成：传递了side_effect参数且值为被测函数地址时，mock不会起作用；两者不可共存</p></li><li><p>另外，side_effect接受的是一个可迭代序列，当传递多个值时，每次调用mock时会返回不同的值；如下</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim"> <span class="hljs-number">1</span> mock_obj = mock.Mock(side_effect= [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])<br> <span class="hljs-number">2</span> <span class="hljs-keyword">print</span>(mock_obj())<br> <span class="hljs-number">3</span> <span class="hljs-keyword">print</span>(mock_obj())<br> <span class="hljs-number">4</span> <span class="hljs-keyword">print</span>(mock_obj())<br> <span class="hljs-number">5</span> <span class="hljs-keyword">print</span>(mock_obj())<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span> # 输出<br> <span class="hljs-number">8</span> Traceback (most recent <span class="hljs-keyword">call</span> <span class="hljs-keyword">last</span>):<br> <span class="hljs-number">9</span> <span class="hljs-number">1</span><br><span class="hljs-number">10</span>   File <span class="hljs-string">&quot;D:/MyThreading/mymock.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">37</span>, in <span class="hljs-symbol">&lt;module&gt;</span><br><span class="hljs-number">11</span> <span class="hljs-number">2</span><br><span class="hljs-number">12</span>     <span class="hljs-keyword">print</span>(mock_obj())<br><span class="hljs-number">13</span> <span class="hljs-number">3</span><br><span class="hljs-number">14</span>   File <span class="hljs-string">&quot;C:\Python36\lib\unittest\mock.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">939</span>, in __call__<br><span class="hljs-number">15</span>     <span class="hljs-keyword">return</span> _mock_self._mock_call(*<span class="hljs-keyword">args</span>, **kwargs)<br><span class="hljs-number">16</span>   File <span class="hljs-string">&quot;C:\Python36\lib\unittest\mock.py&quot;</span>, <span class="hljs-built_in">line</span> <span class="hljs-number">998</span>, in _mock_call<br><span class="hljs-number">17</span>     result = <span class="hljs-keyword">next</span>(effect)<br><span class="hljs-number">18</span> StopIteration<br></code></pre></td></tr></table></figure></li></ul><h3 id="存在依赖关系的功能如何测试？"><a href="#存在依赖关系的功能如何测试？" class="headerlink" title="存在依赖关系的功能如何测试？"></a>存在依赖关系的功能如何测试？</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-number">1</span> <span class="hljs-comment"># 支付类</span><br> <span class="hljs-number">2</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>:<br> <span class="hljs-number">3</span> <br> <span class="hljs-number">4</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">requestOutofSystem</span>(<span class="hljs-params">self, card_num, amount</span>):<br> <span class="hljs-number">5</span>         <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string"> 6         请求第三方外部支付接口，并返回响应码</span><br><span class="hljs-string"> 7         :param card_num: 卡号</span><br><span class="hljs-string"> 8         :param amount: 支付金额</span><br><span class="hljs-string"> 9         :return: 返回状态码，200 代表支付成功，500 代表支付异常失败</span><br><span class="hljs-string">10         &#x27;&#x27;&#x27;</span><br><span class="hljs-number">11</span>         <span class="hljs-comment"># 第三方支付接口请求地址(故意写错)</span><br><span class="hljs-number">12</span>         url = <span class="hljs-string">&quot;http://third.payment.pay/&quot;</span><br><span class="hljs-number">13</span>         <span class="hljs-comment"># 请求参数</span><br><span class="hljs-number">14</span>         data = &#123;<span class="hljs-string">&quot;card_num&quot;</span>: card_num, <span class="hljs-string">&quot;amount&quot;</span>: amount&#125;<br><span class="hljs-number">15</span>         response = requests.post(url, data=data)<br><span class="hljs-number">16</span>         <span class="hljs-comment"># 返回状态码</span><br><span class="hljs-number">17</span>         <span class="hljs-keyword">return</span> response.status_code<br><span class="hljs-number">18</span> <br><span class="hljs-number">19</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">doPay</span>(<span class="hljs-params">self, user_id, card_num, amount</span>):<br><span class="hljs-number">20</span>         <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">21         支付</span><br><span class="hljs-string">22         :param userId: 用户ID</span><br><span class="hljs-string">23         :param card_num: 卡号</span><br><span class="hljs-string">24         :param amount: 支付金额</span><br><span class="hljs-string">25         :return:</span><br><span class="hljs-string">26         &#x27;&#x27;&#x27;</span><br><span class="hljs-number">27</span>         <span class="hljs-keyword">try</span>:<br><span class="hljs-number">28</span>             <span class="hljs-comment"># 调用第三方支付接口请求进行真实扣款</span><br><span class="hljs-number">29</span>             resp = <span class="hljs-variable language_">self</span>.requestOutofSystem(card_num, amount)<br><span class="hljs-number">30</span>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;调用第三方支付接口返回结果：&#x27;</span>, resp)<br><span class="hljs-number">31</span>         <span class="hljs-keyword">except</span> TimeoutError:<br><span class="hljs-number">32</span>             <span class="hljs-comment"># 如果超时就重新调用一次</span><br><span class="hljs-number">33</span>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;重试一次&#x27;</span>)<br><span class="hljs-number">34</span>             resp = <span class="hljs-variable language_">self</span>.requestOutofSystem(card_num, amount)<br><span class="hljs-number">35</span> <br><span class="hljs-number">36</span>         <span class="hljs-keyword">if</span> resp == <span class="hljs-number">200</span>:<br><span class="hljs-number">37</span>             <span class="hljs-comment"># 返回第三方支付成功，则进行系统里面的扣款并记录支付记录等操作</span><br><span class="hljs-number">38</span>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0&#125;支付&#123;1&#125;成功！！！进行扣款并记录支付记录&quot;</span>.<span class="hljs-built_in">format</span>(user_id, amount))<br><span class="hljs-number">39</span>             <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;success&#x27;</span><br><span class="hljs-number">40</span> <br><span class="hljs-number">41</span>         <span class="hljs-keyword">elif</span> resp == <span class="hljs-number">500</span>:<br><span class="hljs-number">42</span>             <span class="hljs-comment"># 返回第三方支付失败，则不进行扣款</span><br><span class="hljs-number">43</span>             <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;0&#125;支付&#123;1&#125;失败！！不进行扣款！！！&quot;</span>.<span class="hljs-built_in">format</span>(user_id, amount))<br><span class="hljs-number">44</span>             <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;fail&#x27;</span><br><span class="hljs-number">45</span> <br><span class="hljs-number">46</span> <span class="hljs-comment"># 单元测试类</span><br><span class="hljs-number">47</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">payTest</span>(unittest.TestCase):<br><span class="hljs-number">48</span> <br><span class="hljs-number">49</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_pay_success</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">50</span>         pay = Payment()<br><span class="hljs-number">51</span>         <span class="hljs-comment"># 模拟第三方支付接口返回200</span><br><span class="hljs-number">52</span>         pay.requestOutofSystem = mock.Mock(return_value=<span class="hljs-number">200</span>)<br><span class="hljs-number">53</span>         resp = pay.doPay(user_id=<span class="hljs-number">1</span>, card_num=<span class="hljs-string">&#x27;12345678&#x27;</span>, amount=<span class="hljs-number">100</span>)<br><span class="hljs-number">54</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-string">&#x27;success&#x27;</span>, resp)<br><span class="hljs-number">55</span> <br><span class="hljs-number">56</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_pay_fail</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">57</span>         pay = Payment()<br><span class="hljs-number">58</span>         <span class="hljs-comment"># 模拟第三方支付接口返回500</span><br><span class="hljs-number">59</span>         pay.requestOutofSystem = mock.Mock(return_value=<span class="hljs-number">500</span>)<br><span class="hljs-number">60</span>         resp = pay.doPay(user_id=<span class="hljs-number">1</span>, card_num=<span class="hljs-string">&#x27;12345678&#x27;</span>, amount=<span class="hljs-number">100</span>)<br><span class="hljs-number">61</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-string">&#x27;fail&#x27;</span>, resp)<br><span class="hljs-number">62</span> <br><span class="hljs-number">63</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_pay_time_success</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">64</span>         pay = Payment()<br><span class="hljs-number">65</span>         <span class="hljs-comment"># 模拟第三方支付接口首次支付超时,重试第二次成功</span><br><span class="hljs-number">66</span>         pay.requestOutofSystem = mock.Mock(side_effect=[TimeoutError, <span class="hljs-number">200</span>])<br><span class="hljs-number">67</span>         resp = pay.doPay(user_id=<span class="hljs-number">1</span>, card_num=<span class="hljs-string">&#x27;12345678&#x27;</span>, amount=<span class="hljs-number">100</span>)<br><span class="hljs-number">68</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-string">&#x27;success&#x27;</span>, resp)<br><span class="hljs-number">69</span> <br><span class="hljs-number">70</span>     <span class="hljs-keyword">def</span> <span class="hljs-title function_">test_pay_time_fail</span>(<span class="hljs-params">self</span>):<br><span class="hljs-number">71</span>         pay = Payment()<br><span class="hljs-number">72</span>         <span class="hljs-comment"># 模拟第三方支付接口首次支付超时,重试第二次失败</span><br><span class="hljs-number">73</span>         pay.requestOutofSystem = mock.Mock(side_effect=[TimeoutError, <span class="hljs-number">500</span>])<br><span class="hljs-number">74</span>         resp = pay.doPay(user_id=<span class="hljs-number">1</span>, card_num=<span class="hljs-string">&#x27;12345678&#x27;</span>, amount=<span class="hljs-number">100</span>)<br><span class="hljs-number">75</span>         <span class="hljs-variable language_">self</span>.assertEqual(<span class="hljs-string">&#x27;fail&#x27;</span>, resp)<br></code></pre></td></tr></table></figure><p>也许有小伙伴会问，第三方支付都不能用，我们的测试结果是否是有效的呢？  </p><p>通常在测试一个模块的时候，是可以认为其他模块的功能是正常的，只针对目标模块进行测试是没有任何问题的，所以说测试结果也是正确的</p><h3 id="mock装饰器"><a href="#mock装饰器" class="headerlink" title="mock装饰器"></a>mock装饰器</h3><p>一共两种格式</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs less"> <span class="hljs-variable">@patch</span>(<span class="hljs-string">&#x27;module名字.方法名&#x27;</span>) <br> <span class="hljs-variable">@patch</span>.<span class="hljs-built_in">object</span>(类名, <span class="hljs-string">&#x27;方法名&#x27;</span>) <br> <span class="hljs-number">1</span> # 装饰类演示<br> <span class="hljs-number">2</span> from mock import Mock, patch<br> <span class="hljs-number">3</span> <br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span> # 单独的相乘函数<br> <span class="hljs-number">6</span> def <span class="hljs-built_in">multiple</span>(a, b):<br> <span class="hljs-number">7</span>     return a * b<br> <span class="hljs-number">8</span> <br> <span class="hljs-number">9</span> <br><span class="hljs-number">10</span> # 单独的捕获Exception函数<br><span class="hljs-number">11</span> def <span class="hljs-built_in">is_error</span>():<br><span class="hljs-number">12</span>     <span class="hljs-attribute">try</span>:<br><span class="hljs-number">13</span>         os.<span class="hljs-built_in">mkdir</span>(<span class="hljs-string">&quot;11&quot;</span>)<br><span class="hljs-number">14</span>         return False<br><span class="hljs-number">15</span>     except Exception as <span class="hljs-attribute">e</span>:<br><span class="hljs-number">16</span>         return True<br><span class="hljs-number">17</span> <br><span class="hljs-number">18</span> <br><span class="hljs-number">19</span> # 计算类,包含add方法<br><span class="hljs-number">20</span> class <span class="hljs-built_in">calculator</span>(object):<br><span class="hljs-number">21</span>     def <span class="hljs-built_in">add</span>(self, a, b):<br><span class="hljs-number">22</span>         return a + b<br><span class="hljs-number">23</span> <br><span class="hljs-number">24</span> <br><span class="hljs-number">25</span> # 装饰类演示 - 单元测试类<br><span class="hljs-number">26</span> class <span class="hljs-built_in">TestProducer</span>(unittest.TestCase):<br><span class="hljs-number">27</span> <br><span class="hljs-number">28</span>     # case执行前<br><span class="hljs-number">29</span>     def <span class="hljs-built_in">setUp</span>(self):<br><span class="hljs-number">30</span>         self.calculator = <span class="hljs-built_in">calculator</span>()<br><span class="hljs-number">31</span> <br><span class="hljs-number">32</span>     # mock一个函数,注意也要指定module<br><span class="hljs-number">33</span>     <span class="hljs-variable">@patch</span>(<span class="hljs-string">&#x27;mock_learn.multiple&#x27;</span>)<br><span class="hljs-number">34</span>     def <span class="hljs-built_in">test_multiple</span>(self, mock_multiple):<br><span class="hljs-number">35</span>         mock_multiple.return_value = <span class="hljs-number">3</span><br><span class="hljs-number">36</span>         self.<span class="hljs-built_in">assertEqual</span>(<span class="hljs-built_in">multiple</span>(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>), <span class="hljs-number">3</span>)<br><span class="hljs-number">37</span> <br><span class="hljs-number">38</span>     # mock一个类对象的方法<br><span class="hljs-number">39</span>     <span class="hljs-variable">@patch</span>.<span class="hljs-built_in">object</span>(calculator, <span class="hljs-string">&#x27;add&#x27;</span>)<br><span class="hljs-number">40</span>     def <span class="hljs-built_in">test_add</span>(self, mock_add):<br><span class="hljs-number">41</span>         mock_add.return_value = <span class="hljs-number">3</span><br><span class="hljs-number">42</span>         self.<span class="hljs-built_in">assertEqual</span>(self.calculator.<span class="hljs-built_in">add</span>(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>), <span class="hljs-number">3</span>)<br><span class="hljs-number">43</span> <br><span class="hljs-number">44</span>     # mock调用方法返回多个不同的值<br><span class="hljs-number">45</span>     <span class="hljs-variable">@patch</span>.<span class="hljs-built_in">object</span>(calculator, <span class="hljs-string">&#x27;add&#x27;</span>)<br><span class="hljs-number">46</span>     def <span class="hljs-built_in">test_effect</span>(self, mock_add):<br><span class="hljs-number">47</span>         mock_add.side_effect = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-number">48</span>         self.<span class="hljs-built_in">assertEqual</span>(self.calculator.<span class="hljs-built_in">add</span>(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>), <span class="hljs-number">1</span>)<br><span class="hljs-number">49</span>         self.<span class="hljs-built_in">assertEqual</span>(self.calculator.<span class="hljs-built_in">add</span>(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>), <span class="hljs-number">2</span>)<br><span class="hljs-number">50</span>         self.<span class="hljs-built_in">assertEqual</span>(self.calculator.<span class="hljs-built_in">add</span>(<span class="hljs-number">8</span>, <span class="hljs-number">14</span>), <span class="hljs-number">3</span>)<br><span class="hljs-number">51</span> <br><span class="hljs-number">52</span>     # mock的函数抛出Exception<br><span class="hljs-number">53</span>     <span class="hljs-variable">@patch</span>(<span class="hljs-string">&#x27;os.mkdir&#x27;</span>)<br><span class="hljs-number">54</span>     def <span class="hljs-built_in">test_exception</span>(self, mkdir):<br><span class="hljs-number">55</span>         mkdir.side_effect = Exception<br><span class="hljs-number">56</span>         self.<span class="hljs-built_in">assertEqual</span>(<span class="hljs-built_in">is_error</span>(), True)<br><span class="hljs-number">57</span> <br><span class="hljs-number">58</span>     # mock多个函数,注意函数调用顺序<br><span class="hljs-number">59</span>     <span class="hljs-variable">@patch</span>.<span class="hljs-built_in">object</span>(calculator, <span class="hljs-string">&#x27;add&#x27;</span>)<br><span class="hljs-number">60</span>     <span class="hljs-variable">@patch</span>(<span class="hljs-string">&#x27;mock_learn.multiple&#x27;</span>)<br><span class="hljs-number">61</span>     def <span class="hljs-built_in">test_more</span>(self, mock_multiple, mock_add):<br><span class="hljs-number">62</span>         mock_add.return_value = <span class="hljs-number">1</span><br><span class="hljs-number">63</span>         mock_multiple.return_value = <span class="hljs-number">4</span><br><span class="hljs-number">64</span>         self.<span class="hljs-built_in">assertEqual</span>(self.calculator.<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), <span class="hljs-number">1</span>)<br><span class="hljs-number">65</span>         self.<span class="hljs-built_in">assertEqual</span>(<span class="hljs-built_in">multiple</span>(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="unittestreport"><a href="#unittestreport" class="headerlink" title="unittestreport"></a>unittestreport</h2><h3 id="关于-unittestreport-是什么？"><a href="#关于-unittestreport-是什么？" class="headerlink" title="关于 unittestreport 是什么？"></a>关于 unittestreport 是什么？</h3><p>unittestreport是基于 unittest 开发的的一个功能扩展库，为 unittest 提供了一些常用的扩展功能</p><ul><li>HTML 测试报告生成</li><li>测试用例失败重运行</li><li>发送测试结果及报告到邮箱</li><li>unittest 数据驱动</li></ul><h4 id="安装命令："><a href="#安装命令：" class="headerlink" title="安装命令："></a>安装命令：</h4><p>pip install unittestreport</p><h3 id="一、HTML-测试报告生成"><a href="#一、HTML-测试报告生成" class="headerlink" title="一、HTML 测试报告生成"></a>一、HTML 测试报告生成</h3><p>unittestteport 中封装了一个 TestRunner 类，可以用来代替 unittest 中的 TextTestRunner 来执行测试用例，执行完测试用例之后会自动生成测试报告。并且有多种报告风格可选</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">模块导入<br>from unittestreport import TestRunner<br>使用案例<br>runner = TestRunner(test_suite)<br>runner.run()<br>关于 TestRunner 初始化参数<br><span class="hljs-section">suites: 测试套件（必传）</span><br><span class="hljs-section">filename: 指定报告文件名</span><br><span class="hljs-section">report_dir:指定存放报告路径</span><br><span class="hljs-section">title:指定测试报告的标题</span><br><span class="hljs-section">templates: 可以指定 1，2，3 三个风格的模板</span><br><span class="hljs-section">tester:测试人员名称</span><br></code></pre></td></tr></table></figure><p><img src="/the-nuo/picture/Snipaste59.png" alt="测试报告"></p><h3 id="二、测试用例失败重运行"><a href="#二、测试用例失败重运行" class="headerlink" title="二、测试用例失败重运行"></a>二、测试用例失败重运行</h3><p>关于unittest重运行机制，unittestreport中提供了两种方式  </p><ul><li>方式一： rerun 装饰器<br>使用案例：使用 rerun 装饰失败需要重运行的用例，该用例失败后会自动重运行  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> unittestreport <span class="hljs-keyword">import</span> rerun<br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">TestClass</span>(<span class="hljs-title">unittest</span>.<span class="hljs-type">TestCase</span>):</span><br><span class="hljs-class">    @rerun(<span class="hljs-title">count</span>=4, <span class="hljs-title">interval</span>=2)</span><br><span class="hljs-class">    def test_case_01(<span class="hljs-title">self</span>):</span><br><span class="hljs-class">        a = 100</span><br><span class="hljs-class">        b = 99</span><br><span class="hljs-class">        assert a == b</span><br><span class="hljs-class">用例运行</span><br><span class="hljs-class">runner = <span class="hljs-type">TestRunner</span>(<span class="hljs-title">test_suite</span>)</span><br><span class="hljs-class">runner.run()</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h4><p>count：用来指定用例失败重运行的次数<br>interval：指定每次重运行的时间间隔</p><ul><li>方式二：TestRunner.rerun 方法<br>使用案例：所有的用例失败，只要有失败的用例，会自动重运行该用例<br>用例正常编写即可</li></ul><p>运行是使用 TestRunner.rerun_run 方法运行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">runner = TestRunner(<span class="hljs-attribute">suite</span>=suite)<br>runner.rerun_run(<span class="hljs-attribute">count</span>=3, <span class="hljs-attribute">interval</span>=2)<br></code></pre></td></tr></table></figure><h4 id="参数说明：-1"><a href="#参数说明：-1" class="headerlink" title="参数说明："></a>参数说明：</h4><p>count：用来指定用例失败重运行的次数<br>interval：指定每次重运行的时间间隔</p><h3 id="三、邮件发送测试报告"><a href="#三、邮件发送测试报告" class="headerlink" title="三、邮件发送测试报告"></a>三、邮件发送测试报告</h3><p>unittestreport 内部实现了发生测试结果到邮箱的方法，执行完测试用例之后调用发送测试报告的方法即可。发邮件的方法介绍：TestRunner 类中实现了 send_email 方法，可以方便用户，快速发送邮件。</p><p>使用案例</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs routeros">runner = TestRunner(suite)<br>runner.<span class="hljs-built_in">run</span>()<br>runner.send_email(<span class="hljs-attribute">host</span>=<span class="hljs-string">&quot;smtp.qq.com&quot;</span>,<br>                  <span class="hljs-attribute">port</span>=465,<br>                  <span class="hljs-attribute">user</span>=<span class="hljs-string">&quot;musen_nmb@qq.com&quot;</span>,<br>                  <span class="hljs-attribute">password</span>=<span class="hljs-string">&quot;algmmzptupjccbab&quot;</span>,<br>                  <span class="hljs-attribute">to_addrs</span>=<span class="hljs-string">&quot;3247119728@qq.com&quot;</span>)<br>```                 <br>参数介绍<br>host： smtp 服务器地址<br>port：端口<br>user：邮箱账号<br>password：smtp 服务授权码<br>to_addrs：收件人邮箱地址（一个收件人传字符串，多个收件人传列表）<br><br><br><span class="hljs-comment">### 四、数据驱动的使用</span><br>关于数据驱动这边就不给大家做过多的介绍了，数据驱动的目的是将测试数据和用例逻辑进行分离，提高代码的重用率，以及用例的维护，关于数据驱动本，unittestreport.dataDriver 模块中实现了三个使用方法，支持使用列表(可迭代对象)、JSON 文件、YAML 文件来生成测试用例，接下来分别给大家介绍一下使用方法：<br><br>1、使用介绍<br><br><span class="hljs-keyword">from</span> unittestreport.dataDriver import ddt, list_data,json_data,yaml_data<br>第一步：使用 ddt 装饰测试用例类<br>第二步：根据使用的数据选择对应的方法进行驱动<br>2、使用案例<br><span class="hljs-comment">#### 一、用例保存在可迭代对象中（如列表）：使用 list_data</span><br></code></pre></td></tr></table></figure><p>from unittestreport import ddt, list_data<br>@ddt<br>class TestClass(unittest.TestCase):<br>    cases &#x3D; [{‘title’: ‘用例1’, ‘data’: ‘用例参数’, ‘expected’: ‘预期结果’},<br>             {‘title’: ‘用例2’, ‘data’: ‘用例参数’, ‘expected’: ‘预期结果’},<br>             {‘title’: ‘用例3’, ‘data’: ‘用例参数’, ‘expected’: ‘预期结果’}]<br>    @list_data(cases)<br>    def test_case(self, data):<br>        pass</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 二、用例保存在 JSON 文件中：使用 json_data<br></code></pre></td></tr></table></figure><p>from unittestreport import ddt,json_data</p><p>@ddt<br>class TestClass(unittest.TestCase):<br>    @json_data(“C:&#x2F;xxxx&#x2F;xxx&#x2F;cases.json”)<br>    def test_case(self, data):<br>        pass</p><p>JSON 文件中的数据格式</p><p>cases.json 文件</p><p>[<br>  {<br>    “title”: “用例1”,<br>    “data”: “用例参数”,<br>    “expected”: “预期结果”<br>  },<br>  {<br>    “title”: “用例2”,<br>    “data”: “用例参数”,<br>    “expected”: “预期结果”<br>  },<br>  {<br>    “title”: “用例3”,<br>    “data”: “用例参数”,<br>    “expected”: “预期结果”<br>  }<br>]</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 三、用例保存在 YAML 文件中：使用 yaml_data<br></code></pre></td></tr></table></figure><p>from unittestreport import ddt,yaml_data</p><p>@ddt<br>class TestClass(unittest.TestCase):<br>    @yaml_data(“C:&#x2F;xxxx&#x2F;xxx&#x2F;cases.yaml”)<br>    def test_case(self, data):<br>        pass<br>YAML 文件中的数据展示<br>cases.yaml 文件</p><ul><li><p>title: 用例1<br>data: 用例参数<br>expected: 预期结果</p></li><li><p>title: 用例2<br>data: 用例参数<br>expected: 预期结果</p></li><li><p>title: 用例4<br>data: 用例参数<br>expected: 预期结果</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">2</span><span class="hljs-string">、注意点：</span><br><span class="hljs-string">关于使用</span> <span class="hljs-string">ddt</span> <span class="hljs-string">的时候进行数据驱动，指定测试报告中的用例描述：</span><br><span class="hljs-string">测试报告中的用例描述默认使用的是用例方法的文档字符串注释，</span><br><span class="hljs-string">如果要给每一条用例添加用例描述，需要在用例数据中添加</span> <span class="hljs-string">title</span> <span class="hljs-string">或者</span> <span class="hljs-string">desc</span> <span class="hljs-string">字段，字段对应的数据会自动设置为测试报告中用例的描述</span><br><br><br><span class="hljs-comment">### 五、发送测试结果到钉钉</span><br><span class="hljs-string">关于把如果测试结果发送到钉钉群，unittestreport里面进行了封装。执行完用例之后，调用TestRunner对象的dingtalk_notice方法即可。</span><br><span class="hljs-string">参数介绍</span><br><span class="hljs-string">关于</span> <span class="hljs-string">dingtalk_notice</span> <span class="hljs-string">这个方法的参数如下，大家可以根据使用需求来进行选择。</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">钉钉机器人的</span> <span class="hljs-string">Webhook</span> <span class="hljs-string">地址</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">key:</span> <span class="hljs-string">（非必传：str</span> <span class="hljs-string">类型）如果钉钉机器人安全设置了关键字，则需要传入对应的关键字</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">secret:（非必传：str</span> <span class="hljs-string">类型）如果钉钉机器人安全设置了签名，则需要传入对应的密钥</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">atMobiles:</span> <span class="hljs-string">（非必传，list</span> <span class="hljs-string">类型）发送通知钉钉中要@人的手机号列表，如：[137xxx,188xxx]</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">isatall:</span> <span class="hljs-string">是否@所有人，默认为</span> <span class="hljs-literal">False</span><span class="hljs-string">，设为</span> <span class="hljs-literal">True</span> <span class="hljs-string">则会@所有人</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">except_info:是否发送未通过用例的详细信息，默认为</span> <span class="hljs-literal">False</span><span class="hljs-string">，设为</span> <span class="hljs-literal">True</span> <span class="hljs-string">则会发送失败用例的详细信息</span><br><span class="hljs-string">案例代码：</span><br><br></code></pre></td></tr></table></figure><p>import unittest<br>from unittestreport import TestRunner</p></li></ul><h4 id="收集用例到套件"><a href="#收集用例到套件" class="headerlink" title="收集用例到套件"></a>收集用例到套件</h4><p>suite &#x3D; unittest.defaultTestLoader.discover(CASE_DIR)<br>runner &#x3D; TestRunner(suite)</p><h1 id="执行用例"><a href="#执行用例" class="headerlink" title="执行用例"></a>执行用例</h1><p>runner.run()<br>#钉钉开放平台-第三方应用-群机器人-自定义机器人<br>url &#x3D; “<a href="https://oapi.dingtalk.com/robot/send?access_token=6e2a63c2b9d870ee878335b5ce6d5d10bb1218b8e64a4e2b55f96a6d116aaf50">https://oapi.dingtalk.com/robot/send?access_token=6e2a63c2b9d870ee878335b5ce6d5d10bb1218b8e64a4e2b55f96a6d116aaf50</a>“</p><h1 id="发送钉钉通知"><a href="#发送钉钉通知" class="headerlink" title="发送钉钉通知"></a>发送钉钉通知</h1><p>runner.dingtalk_notice(url&#x3D;url, key&#x3D;’钉钉安全设置的关键字’,secret&#x3D;’钉钉安全设置签名的秘钥’)</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">#### 备注：关于钉钉群机器人的创建大家可以去看钉钉开放平台上的教程，关键字和秘钥，根据创建钉钉机器人时设置的去添加，没有设置就不需要传这个参数。<br><br>### 多线程运行测试用例<br></code></pre></td></tr></table></figure><p>runner.run(thread_count&#x3D;3)</p><pre><code class="hljs">注意点：  - 确保每个线程在执行的时候不会出现资源竞争（对全局依赖的数据进行修改）- 用例类执行没有先后顺序的依赖关系</code></pre>]]></content>
    
    
    <categories>
      
      <category>AutoTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sonarQube</title>
    <link href="/2022/02/17/python/sonarQube/"/>
    <url>/2022/02/17/python/sonarQube/</url>
    
    <content type="html"><![CDATA[<h1 id="sonarQube"><a href="#sonarQube" class="headerlink" title="sonarQube"></a>sonarQube</h1><h2 id="sonarQube是什么"><a href="#sonarQube是什么" class="headerlink" title="sonarQube是什么"></a>sonarQube是什么</h2><ul><li>代码质量安全扫描和分析平台</li><li>多维度分析代码：代码量，安全隐患，编写规范隐患，重复度，复杂度，代码增量，测试覆盖率等</li><li>支持25+编程语言的代码扫描和分析，包含java python c# go c++等</li><li>涵盖了编程语言的静态扫描规则：代码编写规范+安全规范</li><li>能够与代码编辑器，CI&#x2F;CD平台完美集成</li><li>能够与SCM集成，可以直接在平台上看到代码问题是由哪位开发人员提交</li><li>帮助程序员写出更干净，更安全的代码</li></ul><h2 id="sonarQube能干什么"><a href="#sonarQube能干什么" class="headerlink" title="sonarQube能干什么"></a>sonarQube能干什么</h2><ul><li>能够静态扫描和分析20+语言的项目代码</li><li>有统一的管理平台，呈现项目代码的质量数据</li></ul><h2 id="sonarQube如何工作？"><a href="#sonarQube如何工作？" class="headerlink" title="sonarQube如何工作？"></a>sonarQube如何工作？</h2><p>sonar静态代码扫描由两部分组成：sonarQube平台，sonar-scanner扫描器</p><h4 id="sonarQube：web界面管理平台"><a href="#sonarQube：web界面管理平台" class="headerlink" title="sonarQube：web界面管理平台"></a>sonarQube：web界面管理平台</h4><ul><li>展示所有的项目代码的质量数据</li><li>配置质量规则、管理项目、配置通知。配置SCM等</li></ul><h4 id="sonar-scanner-代码扫描工具"><a href="#sonar-scanner-代码扫描工具" class="headerlink" title="sonar-scanner:代码扫描工具"></a>sonar-scanner:代码扫描工具</h4><ul><li>专门用来扫描和分析代码，支持20+语言</li><li>代码扫描和分析完成之后，会将扫描结果存储到数据库中，在sonarQube平台可以看到扫描数据<br><img src="/the-nuo/picture/Snipaste_32.png" alt="关系"><img src="/the-nuo/picture/Snipaste_34.png" alt="关系"></li></ul><h2 id="安装sonarQube"><a href="#安装sonarQube" class="headerlink" title="安装sonarQube"></a>安装sonarQube</h2><p>说明文档:<a href="https://docs.sonarqube.org/8.3/requirements/requirements/">https://docs.sonarqube.org/8.3/requirements/requirements/</a></p><ul><li>sonarQube平台  需要java11<ul><li>sonaQube官网下载-bin下选择对应平台-输入sh sonar.sh console 运行脚本看到sonarQube is up代表启动成功。<br>浏览器中输入localhost:9000能成功访问代表sonarQube平台已经搭建好</li><li>sonarQube汉化<br>localhost:9000点击login登录  账号和密码都是admin 选择Administration-Marketplace-Plugins 搜索Chinese Pack 下载-Restart Server</li></ul></li><li>数据库（oracle,postgresql,sqlserver)<ul><li><a href="https://www.cnblogs.com/Simple-Small/p/12882948.html">https://www.cnblogs.com/Simple-Small/p/12882948.html</a> mac postgre 安装</li></ul></li><li>sonar-scanner</li></ul><h3 id="安装sonarQube平台"><a href="#安装sonarQube平台" class="headerlink" title="安装sonarQube平台"></a>安装sonarQube平台</h3><h4 id="需要安装的内容"><a href="#需要安装的内容" class="headerlink" title="需要安装的内容"></a>需要安装的内容</h4><ul><li>jdk11或jdk11+</li><li>sonarQube平台</li></ul><h4 id="本文中所用到环境及安装包版本："><a href="#本文中所用到环境及安装包版本：" class="headerlink" title="本文中所用到环境及安装包版本："></a>本文中所用到环境及安装包版本：</h4><p>1、macOS Catalina 10.15.3<br>2、jdk11<br>3、sonarQube7.9.1</p><h4 id="mac下安装"><a href="#mac下安装" class="headerlink" title="mac下安装"></a>mac下安装</h4><ul><li><p>1.jdk11安装包下载：<br>百度网盘链接:<a href="https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw">https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw</a> 密码:9rwq  </p></li><li><p>2、jdk11安装<br>安装：一路next即可。<br>安装后在mac上的目录为：&#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk-11.0.5.jdk</p></li><li><p>3、jdk11环境变量配置</p></li><li><p>1）在终端中运行命令：vim ~&#x2F;.bash_profile</p></li><li><p>2）输入i进入编辑状态，并添加以下语句：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/Library/Java/JavaVirtualMachines/jdk-11.0.5.jdk/Contents/Home<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:$JAVA_HOME/bin<br></code></pre></td></tr></table></figure><p>(JAVA_HOME的路径自行更改为你本地jdk的路径)</p></li><li><p>3）保存修改。并让shell应用新配置</p></li></ul><p>保存修改：按ESC键，再按冒号，输入wq!保存并退出shell   </p><p>执行如下命令，让shell应用新配置。   </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><ul><li>4、sonarQube安装包下载<br>百度网盘链接:<a href="https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw">https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw</a> 密码:9rwq</li><li>5、sonarQube安装<br>将3中的安装包，解压到本地任意目录。</li></ul><h4 id="启动sonarQube平台"><a href="#启动sonarQube平台" class="headerlink" title="启动sonarQube平台"></a>启动sonarQube平台</h4><p>在sonarQube安装目录当中，在bin目录下，找到sonar.sh。<br>在脚本目录下执行.&#x2F;sonar.sh concole</p><h4 id="访问sonarQube平台"><a href="#访问sonarQube平台" class="headerlink" title="访问sonarQube平台"></a>访问sonarQube平台</h4><p>默认启动端口为9000  </p><p>在浏览器当中，访问：<a href="http://localhost:9000/">http://localhost:9000</a><br><img src="/the-nuo/picture/Snipaste_54.png" alt="sonarqube"></p><h2 id="sonarQube汉化"><a href="#sonarQube汉化" class="headerlink" title="sonarQube汉化"></a>sonarQube汉化</h2><p>1、以管理员身份登陆sonarQube平台   localhost:9000<br>默认的管理员用户帐号是：admin&#x2F;admin<br><img src="/the-nuo/picture/Snipaste_45.png"><br><img src="/the-nuo/picture/Snipaste_31.png"></p><h2 id="postgresql数据库安装"><a href="#postgresql数据库安装" class="headerlink" title="postgresql数据库安装"></a>postgresql数据库安装</h2><h4 id="mac安装环境"><a href="#mac安装环境" class="headerlink" title="mac安装环境"></a>mac安装环境</h4><p>mac环境：macOS Catalina 10.15.3</p><p>postgresql版本：postgresql-12.2-4-osx</p><p>jdk版本：jdk-11.0.5_osx-x64_bin</p><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h4><p>1、postsql版本获取<br>1.1 从官网下载postgresql12版本</p><p><a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a></p><p>1.2 从百度网盘当中，下载即可。</p><p>百度网盘链接:<a href="https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw">https://pan.baidu.com/s/1WYeHEAYClqIUFH12SP7zjw</a> 密码:9rwq<br><img src="/the-nuo/picture/Snipaste_14.png"><br><img src="/the-nuo/picture/Snipaste_05.png"><br><img src="/the-nuo/picture/Snipaste_29.png"><br><img src="/the-nuo/picture/Snipaste_10.png"></p><h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><ul><li>1、Uninstall PostgresSQL and then clean &#x2F;Library&#x2F;PostgreSQL&#x2F; Directory.</li></ul><p>选择上上图中的Cancel取消安装。 删除 &#x2F;Library&#x2F;PostgreSQL&#x2F;这个目录。</p><ul><li>2、Open teminal and run :</li></ul><p>打开终端界面，运行以下2条命令</p><p>sudo dscl . -create &#x2F;Users&#x2F;postgres UserShell &#x2F;bin&#x2F;sh</p><p>sudo dscl . -create &#x2F;Users&#x2F;postgres NFSHomeDirectory &#x2F;Library&#x2F;PostgreSQL</p><ul><li>3、Install PostgresSQL</li></ul><p>重新安装PostgresSQL<br>重新安装之后，不会再报这个错误，进入安装完成后的界面。<br><img src="/the-nuo/picture/Snipaste_2021-05-15_16-47-58.png"></p><h4 id="配置postgreSql数据库"><a href="#配置postgreSql数据库" class="headerlink" title="配置postgreSql数据库"></a>配置postgreSql数据库</h4><p><img src="/the-nuo/picture/Snipaste_2021-05-15_16-48-59.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-15_16-47-58.png"></p><h2 id="sonarQube配置数据库为postgresql"><a href="#sonarQube配置数据库为postgresql" class="headerlink" title="sonarQube配置数据库为postgresql"></a>sonarQube配置数据库为postgresql</h2><h3 id="1、在postgresql当中创建sonar数据库和用户"><a href="#1、在postgresql当中创建sonar数据库和用户" class="headerlink" title="1、在postgresql当中创建sonar数据库和用户"></a>1、在postgresql当中创建sonar数据库和用户</h3><h4 id="1-1-创建sonar用户"><a href="#1-1-创建sonar用户" class="headerlink" title="1.1 创建sonar用户"></a>1.1 创建sonar用户</h4><p>以postgres用户登陆成功后，创建为sonarQube专用的sonar用户。</p><p>如下图，在General中设置用户名为sonar，Privileges中控制权限。用户名为sonar,密码为sonar<br><img src="/the-nuo/picture/Snipaste_57-39.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_13-59-01.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_13-59-27.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_13-59-49.png"></p><p><img src="/the-nuo/picture/Snipaste_2021-05-18_14-01-06.png"></p><p><img src="/the-nuo/picture/Snipaste_2021-05-18_14-01-24.png"></p><h3 id="2、在sonarQube中配置postgresql连接信息"><a href="#2、在sonarQube中配置postgresql连接信息" class="headerlink" title="2、在sonarQube中配置postgresql连接信息"></a>2、在sonarQube中配置postgresql连接信息</h3><p>在sonarQube的安装目录的conf目录下，打开sonar.properties。</p><p>此文件当中，所有支持的数据类型的连接方式都已经放进来了。只需要开放注释，进行配置工作即可。</p><h4 id="2-1、配置数据库地址、用户名、密码："><a href="#2-1、配置数据库地址、用户名、密码：" class="headerlink" title="2.1、配置数据库地址、用户名、密码："></a>2.1、配置数据库地址、用户名、密码：</h4><p>需要配置的参数为：</p><p>sonar.jdbc.username</p><p>sonar.jdbc.password</p><p>sonar.jdbc.url</p><p>本身是注释的。开放注释，并配置在postgreSql当中，为sonar创建的用户名和密码：sonar&#x2F;sonar。</p><p>配置数据库地址、数据库名称。以及CurrentSchema(默认就是public)<br><img src="/the-nuo/picture/Snipaste_2021-05-18_14-01-40.png"></p><h4 id="2-2-重启sonarQube"><a href="#2-2-重启sonarQube" class="headerlink" title="2.2 重启sonarQube"></a>2.2 重启sonarQube</h4><p>重启过程中，sonar会使用配置的数据库，并在数据库中自动创建表格。需要一点时间。</p><p>重启完成之后，可以在数据库当中看到sonar创建的表：<br><img src="/the-nuo/picture/Snipaste_2021-05-18_14-01-55.png"></p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>再次访问sonar_quebe可能会出现无法登录，此时多点几遍修改sonarqube登录密码后重新登录即可  </p><p><img src="/the-nuo/picture/Snipaste_2021-05-18_14-08-50.png"></p><h2 id="sonar-scanner安装和配置"><a href="#sonar-scanner安装和配置" class="headerlink" title="sonar-scanner安装和配置"></a>sonar-scanner安装和配置</h2><h3 id="1、下载sonnarScanner-要能够匹配sonarQube"><a href="#1、下载sonnarScanner-要能够匹配sonarQube" class="headerlink" title="1、下载sonnarScanner (要能够匹配sonarQube)"></a>1、下载sonnarScanner (要能够匹配sonarQube)</h3><p><a href="https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/">https://docs.sonarqube.org/latest/analysis/scan/sonarscanner/</a></p><p>sonarScanner 4.2支持 sonarQube6.7+。</p><p>解压到本地目录即可。</p><h3 id="2、更新sonar-scanner的配置文件。配置连接SonarQube服务器。"><a href="#2、更新sonar-scanner的配置文件。配置连接SonarQube服务器。" class="headerlink" title="2、更新sonar-scanner的配置文件。配置连接SonarQube服务器。"></a>2、更新sonar-scanner的配置文件。配置连接SonarQube服务器。</h3><p>更新conf&#x2F;sonar-scanner.properties文件<br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-01-40.png"></p><h4 id="3、添加-bin目录到环境变量当中。"><a href="#3、添加-bin目录到环境变量当中。" class="headerlink" title="3、添加 bin目录到环境变量当中。"></a>3、添加 bin目录到环境变量当中。</h4><p>vim ~.&#x2F;source_profile<br>source ~.&#x2F;source_profile<br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-04-40.png"></p><h4 id="4-sourc检测环境变量是否配置成功"><a href="#4-sourc检测环境变量是否配置成功" class="headerlink" title="4. sourc检测环境变量是否配置成功"></a>4. sourc检测环境变量是否配置成功</h4><p>sonar-scanner-h</p><h2 id="扫描项目"><a href="#扫描项目" class="headerlink" title="扫描项目"></a>扫描项目</h2><h3 id="扫描JAVA项目"><a href="#扫描JAVA项目" class="headerlink" title="扫描JAVA项目"></a>扫描JAVA项目</h3><p><img src="/the-nuo/picture/Snipaste_2021-05-18_16-07-44.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-08-14.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-08-31.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-08-46.png"><br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-08-57.png"></p><h3 id="扫描python项目"><a href="#扫描python项目" class="headerlink" title="扫描python项目"></a>扫描python项目</h3><p>直接在项目目录下执行命令即可<br><img src="/the-nuo/picture/Snipaste_2021-05-18_16-18-09.png"></p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据类型扩展</title>
    <link href="/2022/02/17/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95/"/>
    <url>/2022/02/17/python/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%A9%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型扩展"><a href="#数据类型扩展" class="headerlink" title="数据类型扩展"></a>数据类型扩展</h1><h2 id="命名元祖"><a href="#命名元祖" class="headerlink" title="命名元祖"></a>命名元祖</h2><ul><li><p>1.元祖和列表的性能分析</p><p>计算创建元祖和列表所需的时间：ipython中使用timeit<br>计算时间模块</p></li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">import</span> timeit<br><span class="hljs-title">timeit</span>.timeit<br></code></pre></td></tr></table></figure><p>  创建一个元祖比创建一个列表快3倍多</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache">  <span class="hljs-attribute">In</span><span class="hljs-meta"> [1]: timeit list= [1,2,3]</span><br><span class="hljs-attribute">38</span>.<span class="hljs-number">4</span> ns ± <span class="hljs-number">0</span>.<span class="hljs-number">449</span> ns per loop (mean ± std. dev. of <span class="hljs-number">7</span> runs, <span class="hljs-number">10000000</span> loops each)<br><br><span class="hljs-attribute">In</span><span class="hljs-meta"> [2]: timeit tu1=(1,2,3)</span><br><span class="hljs-meta">12.5 ns ± 0.027 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)</span><br></code></pre></td></tr></table></figure><h4 id="timeit类"><a href="#timeit类" class="headerlink" title="timeit类"></a>timeit类</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">func</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        pass<br><br>res = timeit.<span class="hljs-built_in">Timer</span>(func).<span class="hljs-built_in">timeit</span>(<span class="hljs-number">100</span>)<br><span class="hljs-built_in">print</span>(res)<br><br>res2 = timeit.<span class="hljs-built_in">timeit</span>(<span class="hljs-string">&#x27;[1,2,3]&#x27;</span>)<br><span class="hljs-built_in">print</span>(res2)<br><br>res3 = timeit.<span class="hljs-built_in">timeit</span>(<span class="hljs-string">&#x27;(1,2,3)&#x27;</span>)<br><span class="hljs-built_in">print</span>(res3)<br><br></code></pre></td></tr></table></figure><p>命名元祖取值时可以像字典一样取值，通过对应的键找到对应的值</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">stu_info = namedtuple(<span class="hljs-string">&#x27;stu_info&#x27;</span>,[<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;sex&#x27;</span>]) #创建一个命名元祖类返回一个对象<br>tu = stu_info(<span class="hljs-string">&#x27;musen&#x27;</span>,18,<span class="hljs-string">&#x27;nan&#x27;</span>)<br><span class="hljs-built_in">print</span>(tu)    # stu_info(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;musen&#x27;</span>, <span class="hljs-attribute">age</span>=18, <span class="hljs-attribute">sex</span>=<span class="hljs-string">&#x27;nan&#x27;</span>)<br><span class="hljs-built_in">print</span>(tu.name)<br><span class="hljs-built_in">print</span>(type(tu))#一个类<br></code></pre></td></tr></table></figure><h4 id="字典和集合的原理和应用"><a href="#字典和集合的原理和应用" class="headerlink" title="字典和集合的原理和应用"></a>字典和集合的原理和应用</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">se</span> = set() #空集合<br><span class="hljs-attribute">dict</span> = &#123;&#125;  #空字典<br><br><span class="hljs-comment">#集合可以自动去重 不会存在重复的元素 用于列表去重</span><br><span class="hljs-attribute">set1</span>=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>&#125; <br><span class="hljs-attribute">print</span>(set1)<br><br><span class="hljs-comment">#利用集合对列表去重</span><br><br><span class="hljs-attribute">li</span>=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br><span class="hljs-attribute">print</span>(set(li)) # &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><span class="hljs-attribute">print</span>(list(set(li))) #<span class="hljs-meta"> [1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><h4 id="集合无序，可变-被称为散列类型"><a href="#集合无序，可变-被称为散列类型" class="headerlink" title="集合无序，可变 被称为散列类型"></a>集合无序，可变 被称为散列类型</h4><h4 id="add一次只能添加一个元素-可以添加元祖-字符串-数字-不可以添加list"><a href="#add一次只能添加一个元素-可以添加元祖-字符串-数字-不可以添加list" class="headerlink" title="add一次只能添加一个元素,可以添加元祖 字符串 数字,不可以添加list"></a>add一次只能添加一个元素,可以添加元祖 字符串 数字,不可以添加list</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">se</span> = &#123;<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>&#125;<br><span class="hljs-attribute">se</span>.add((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(se)  # &#123;<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;<br><span class="hljs-attribute">se</span>.remove((<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))<br><span class="hljs-attribute">print</span>(se)  # &#123;<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>&#125;<br><span class="hljs-attribute">se</span>.update(&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;musen&#x27;,(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;)<br><span class="hljs-attribute">print</span>(se) # &#123;<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;musen&#x27;,(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;<br><span class="hljs-attribute">se1</span>=se.copy()<br><span class="hljs-attribute">print</span>(se1)  # &#123;<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,&#x27;musen&#x27;,(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)&#125;<br><span class="hljs-attribute">se</span>.clear()<br><span class="hljs-attribute">print</span>(se) # set()<br></code></pre></td></tr></table></figure><h2 id="推导式"><a href="#推导式" class="headerlink" title="推导式"></a>推导式</h2><h5 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h5><p>1.数值 int float<br>2.序列  str list tuple</p><p>3.散列  dict set 特征：元素内部是无序的</p><ul><li><h4 id="列表推导式快速生成一个列表"><a href="#列表推导式快速生成一个列表" class="headerlink" title="列表推导式快速生成一个列表"></a>列表推导式快速生成一个列表</h4></li></ul><p>for循环把i放在前面列表里</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">listi = <span class="hljs-selector-attr">[i for i in range(1,100)]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(listi)</span></span><br>urls = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;page&#123;&#125;&#x27;</span>.format(i) for i in range(101)]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(urls)</span></span><br></code></pre></td></tr></table></figure><ul><li><h5 id="字典推导式"><a href="#字典推导式" class="headerlink" title="字典推导式"></a>字典推导式</h5></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">dict1 = &#123;<span class="hljs-selector-tag">i</span> <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">101</span>)&#125;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dict1)</span></span>  #是一个集合<br>dict2 = &#123;<span class="hljs-selector-tag">i</span>: i+<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)&#125;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dict2)</span></span><br></code></pre></td></tr></table></figure><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h4 id="1-可迭代对象：能够使用for遍历的数据都是可迭代对象。迭代对象内部实现了迭代协议（这个对象拥有-iter-方法）str-list-dict-range-tuple"><a href="#1-可迭代对象：能够使用for遍历的数据都是可迭代对象。迭代对象内部实现了迭代协议（这个对象拥有-iter-方法）str-list-dict-range-tuple" class="headerlink" title="1.可迭代对象：能够使用for遍历的数据都是可迭代对象。迭代对象内部实现了迭代协议（这个对象拥有__iter__方法）str list dict range tuple"></a>1.可迭代对象：能够使用for遍历的数据都是可迭代对象。迭代对象内部实现了迭代协议（这个对象拥有__iter__方法）str list dict range tuple</h4><h4 id="2-迭代器：迭代器也是可迭代对象的一种"><a href="#2-迭代器：迭代器也是可迭代对象的一种" class="headerlink" title="2.迭代器：迭代器也是可迭代对象的一种"></a>2.迭代器：迭代器也是可迭代对象的一种</h4><ul><li>1.迭代器不仅实现了__iter__这个方法，还实现了__next__方法</li><li>2.迭代对象转换为迭代器：迭代器&#x3D;iter(可迭代对象)</li><li>3.迭代器：可以使用内置函数next进行迭代</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">li = [<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">33</span>,<span class="hljs-number">44</span>]<br>li_tor = <span class="hljs-built_in">iter</span>(li)<br><br><span class="hljs-comment"># next函数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(li_tor))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(li_tor))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(li_tor))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(li_tor))<br><br><span class="hljs-comment"># 注意点</span><br>当使用<span class="hljs-built_in">next</span>获取完迭代器中所有的元素之后，再次使用<span class="hljs-built_in">next</span>进行迭代，会抛出迭代器停止的异常<br><br>li_tor = <span class="hljs-built_in">iter</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> li_tor:<br>    <span class="hljs-built_in">print</span>(i)<br></code></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><h4 id="一种特殊的迭代器，使用next进行迭代。用来存储数据，不会保存具体的数据，只会存储表达式。生成器只存储生成规则会节约内存提高性能，所有元素被取出来后会报一个错误-StopIteration"><a href="#一种特殊的迭代器，使用next进行迭代。用来存储数据，不会保存具体的数据，只会存储表达式。生成器只存储生成规则会节约内存提高性能，所有元素被取出来后会报一个错误-StopIteration" class="headerlink" title="一种特殊的迭代器，使用next进行迭代。用来存储数据，不会保存具体的数据，只会存储表达式。生成器只存储生成规则会节约内存提高性能，所有元素被取出来后会报一个错误 StopIteration"></a>一种特殊的迭代器，使用next进行迭代。用来存储数据，不会保存具体的数据，只会存储表达式。生成器只存储生成规则会节约内存提高性能，所有元素被取出来后会报一个错误 StopIteration</h4><h4 id="创建生成器的两种方式"><a href="#创建生成器的两种方式" class="headerlink" title="创建生成器的两种方式"></a>创建生成器的两种方式</h4><ul><li><p>1.生成器表达式 (i for i in range(10000))</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tu = (<span class="hljs-selector-tag">i</span> <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(tu)</span></span> #生成器对象&lt;generator <span class="hljs-selector-tag">object</span> &lt;genexpr&gt; at <span class="hljs-number">0</span>x00000113F10DAA20&gt;<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(next(tu)</span></span>)  <br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(next(tu)</span></span>)<br><br></code></pre></td></tr></table></figure></li><li><p>2.生成器函数 只要在函数中使用了yield这个关键字，那么这个函数就是一个生成器函数<br>yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;---------------&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>         <span class="hljs-keyword">yield</span> i<br>         <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------------2------------&quot;</span>)<br>g = gen() <span class="hljs-comment"># 调用时返回一个生成器对象</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br><span class="hljs-comment"># 注意：yield 后面没有值时 返回None</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="生成器的三种方法"><a href="#生成器的三种方法" class="headerlink" title="生成器的三种方法"></a>生成器的三种方法</h3><ul><li>1.next方法 必须先用next方法启动生成器</li><li>2.send方法 用于和生成器内部进行数据交互 send后可以传递函数名 变量等<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">gen</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        s = yield i*<span class="hljs-number">5</span> # 要使用send传进来的数据必须要接收<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send传递进来的数据为:&quot;</span>,s)<br><br>g = <span class="hljs-built_in">gen</span>() # 调用时返回一个生成器对象<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次生成数据&quot;</span>,<span class="hljs-built_in">next</span>(g)) # next函数启动生成器<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">100</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">200</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第三次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">300</span>))<br></code></pre></td></tr></table></figure><h4 id="send用法-可以用send控制生成的数据"><a href="#send用法-可以用send控制生成的数据" class="headerlink" title="send用法 可以用send控制生成的数据"></a>send用法 可以用send控制生成的数据</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scss">def <span class="hljs-built_in">gen</span>():<br>    s = <span class="hljs-number">0</span><br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        s = yield i* s<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send传递进来的数据为:&quot;</span>,s)<br>g = <span class="hljs-built_in">gen</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次生成数据&quot;</span>,<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">100</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第二次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">200</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第三次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>(<span class="hljs-number">300</span>))<br><br># 传递多个函数必须用元祖来传会进行拆包<br>def <span class="hljs-built_in">gen</span>():<br>    s = <span class="hljs-number">0</span><br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        y,s = yield i* s<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send传递进来的数据s为:&quot;</span>,s)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;send传递进来的数据y为:&quot;</span>,y)<br>g = <span class="hljs-built_in">gen</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次生成数据&quot;</span>,<span class="hljs-built_in">next</span>(g))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;第一次使用send方法生成的数据&quot;</span>,g.<span class="hljs-built_in">send</span>((<span class="hljs-number">100</span>,<span class="hljs-number">200</span>)))<br></code></pre></td></tr></table></figure></li><li>3.close:关闭生成器<br>g.close()</li><li>4.throw:往生成器内部发送一个异常 参数：异常类型、异常信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen2</span>():<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-keyword">yield</span> <span class="hljs-number">11</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>      <span class="hljs-built_in">print</span>(e)<br>g = gen2()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(g))<br>g.throw(<span class="hljs-string">&quot;ValueError&quot;</span>,<span class="hljs-string">&quot;主动抛出的异常&quot;</span>)<br></code></pre></td></tr></table></figure>可迭代对象》生成器》迭代器</li></ul><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><ul><li>对齐缩进(左边括号缩进)</li><li>层级缩进</li><li>悬挂缩进</li></ul><h4 id="行的最大限度"><a href="#行的最大限度" class="headerlink" title="行的最大限度"></a>行的最大限度</h4><p>单行代码字符数不要超过79个字符</p><p>用\ 反斜杠来进行隐式换行</p><h4 id="快捷键-control-alt-l格式化代码（根据pep8规范）"><a href="#快捷键-control-alt-l格式化代码（根据pep8规范）" class="headerlink" title="快捷键 control+alt+l格式化代码（根据pep8规范）"></a>快捷键 control+alt+l格式化代码（根据pep8规范）</h4><h4 id="函数、模块命名"><a href="#函数、模块命名" class="headerlink" title="函数、模块命名"></a>函数、模块命名</h4><p>函数名应该小写，如果想提高可读性可以用下划线分隔</p><p>模块名名称要短，使用小写，并且避免使用特殊符号,不要使用驼峰</p><h4 id="模块导入的顺序"><a href="#模块导入的顺序" class="headerlink" title="模块导入的顺序"></a>模块导入的顺序</h4><ul><li>先导python的官方库</li><li>在导入安装的第三方模块</li><li>最后导入自定义的模块和包</li></ul><h3 id="查看文档字符串"><a href="#查看文档字符串" class="headerlink" title="查看文档字符串"></a>查看文档字符串</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">requests.<span class="hljs-emphasis">__doc__</span><br>requests.get.<span class="hljs-emphasis">__doc__</span><br></code></pre></td></tr></table></figure><p>导入包的时候会自动执行__init__文件</p><h3 id="工程结构化之结构介绍："><a href="#工程结构化之结构介绍：" class="headerlink" title="工程结构化之结构介绍："></a>工程结构化之结构介绍：</h3><p> 结构化意味着通过编写简介的代码，并且正如文件系统中文件和目录的组织一样，代码应该使逻辑和依赖清晰，在一个健康的开发周期中，代码风格，api设计和自动化是非常关键的。同样对于工程的架构，仓库的结构也是关键的一部分。</p><ol><li>readme:对项目的整体介绍，同时也是一份使用手册，需要时常维护更新 通常为REDME.rst&#x2F;readme.md</li><li>LICENSE:阐述该项目的许可说明和授权</li><li>setup.py:通过setup把核心代码打包发布</li><li>sample:存放项目的核心代码</li><li>requirements.txt:存放该项目依赖的所有第三方库</li><li>docs:包的参考文档</li><li>tests:所有的代码测试都归存放于该目录下</li><li>makefile:用于项目的命令管理（开源项目广泛使用）<br>根据项目需求添加其他的文件和目录</li></ol>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python文件操作</title>
    <link href="/2022/02/17/python/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/17/python/python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h3><p>python提供了必要的函数和方法进行默认情况下的文件基本操作，你可以用file对象做大部分的文件操作<br>注意点：操作的对象是文件，这里讲解的实例是txt文本文件的操作  </p><p>文件读取都是字符串类型，写入也要以字符串格式<br>打开文件函数： open(他是一个内置函数，可以直接调用)<br>语法file object &#x3D;open(file_name [,access_mode]) —-这里我们会创建一个file对象<br>各个参数解释如下<br>file_name:fime_name变量是一个包含了你要访问的文件名称的字符串值<br>access_mode:acess_mode决定了打开文件的模式：只读 写入，追加等。这个参数是非强制的，默认文件访问模式为只读（r）</p><ul><li>r   以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</li><li>r+ 打开一个文件用于读写。文件指针将会放在文件的开头。</li><li>w     打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</li><li>w+   打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</li><li>a     打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</li><li>a+   打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hsp">例：f = open(<span class="hljs-string">&#x27;123&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>)  <br>例：<br>fs=open(<span class="hljs-string">&quot;C:\\Users\\Ivan\\Desktop\\file.txt&quot;</span>) <span class="hljs-meta">#在同一级目录下，可以直接写文件名，不在同一目录下，要写完整路径，必须用\\  。open是把文件内容以str文件流的方式读到fs这个池子里面</span><br><span class="hljs-keyword">print</span>(fs.read())     <span class="hljs-meta"># 读取所有内容</span><br>fs.readline() <span class="hljs-meta">#读取整行，默认起始位置在最开始 用的不多，主要是内存不够读取所有内容时才会用</span><br>fs.readlines<br>读取<br><span class="hljs-keyword">print</span>(fs.readlines())  <span class="hljs-meta"># <span class="hljs-comment">//遍历文件里所有内容 </span></span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">line</span> in fs.readlines():<br>     <span class="hljs-keyword">print</span>(<span class="hljs-keyword">line</span>)<br></code></pre></td></tr></table></figure>区别：</li><li>.read() 每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。然而 .read() 生成文件内容最直接的字符串表示，但对于连续的面向行的处理，它却是不必要的，并且如果文件大于可用内存，则不可能实现这种处理。</li><li>.readline() 和 .readlines() 之间的差异是后者一次读取整个文件，象 .read() 一样。.readlines() 自动将文件内容分析成一个行的列表，该列表可以由 Python 的 for … in … 结构进行处理。另一方面，.readline() 每次只读取一行，通常比 .readlines() 慢得多。仅当没有足够内存可以一次读取整个文件时，才应该使用 .readline()。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">fs = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;peseoo&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)<br>zn=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">a meilidezuoguo</span><br><span class="hljs-string">a meilidejiaxiang</span><br><span class="hljs-string">a meilidediqiu</span><br><span class="hljs-string">zaaaaaaaa</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>fs.write(zn)    写入<br>fs.write(<span class="hljs-string">&quot;helflo,hello&quot;</span>) 在没有close之前多次调用write都是在最后继续追加内容<br>fs.close()   一旦关闭之后，再次写入的话前面的内容就会被后面的内容冲掉<br>fss = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;peseoo&quot;</span>,<span class="hljs-string">&quot;w&quot;</span>)   <br>ab=<span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">adbd</span><br><span class="hljs-string">efsn</span><br><span class="hljs-string">sss</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>fss.write(ab)<br>fss.close()             <br> <br>fs.write(zn)          fs.write()将字符串写入文件，没有返回值。<br>fs.close()             fs.close()关闭文件。关闭后文件不能再进行读写操作。关闭时自动保存<br>追加<br>fsss=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;peseoo&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>)<br>fsss.write(<span class="hljs-string">&quot;\nmy name is zhounuo&quot;</span>) \n是换行符<br>fsss.close()<br></code></pre></td></tr></table></figure></li></ul><h3 id="文件的读写操作"><a href="#文件的读写操作" class="headerlink" title="文件的读写操作"></a>文件的读写操作</h3><p>file对象提供了一系列的方法，让我们实现对文件的读写<br>read()方法：  </p><ul><li>1）read(count)方法从一个打开的文件中读取一个字符串</li><li>2）里面传递你要读取的字节数</li><li>3）如果不传递，默认读取所有数据</li><li>4）读完了之后，指针会定位到读完之后的位置‘</li></ul><h4 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h4><p>write(）方法可将任何字符串写入一个打开的文件<br>注意write()方法不会再字符串的结尾添加换行符（’\n‘）,无法实现自动换行操作<br>.()writelines :里面传入你要的列表内容，就可以写入多行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql">fsss<span class="hljs-operator">=</span><span class="hljs-keyword">open</span>(&quot;peseoo&quot;,&quot;a&quot;)<br>fsss.writelines([&quot;\nwo are taliking&quot;,&quot;\nwo are taliking&quot;,&quot;\nwo are taliking&quot;])<br>fsss.close()<br><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>打印结果<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br>wo <span class="hljs-keyword">are</span> taliking<br>wo <span class="hljs-keyword">are</span> taliking<br>wo <span class="hljs-keyword">are</span> taliking<br></code></pre></td></tr></table></figure><h4 id="文件对象的属性"><a href="#文件对象的属性" class="headerlink" title="文件对象的属性"></a>文件对象的属性</h4><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息<br>一下是和file对象相关的常用属性列表<br>file.closed  如果文件已被关闭返回true，否则返回false<br>flie.mode 返回被打开的文件的访问模式<br>file.name 返回文件的名称  </p><h4 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h4><ul><li>1） tell（）方法告诉你文件内的当前位置，换句话说，文字会写在上次文字结尾后面<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fsss=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;peseoo&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>)<br>fsss<span class="hljs-selector-class">.writelines</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&quot;\nwo are taliking&quot;</span>,<span class="hljs-string">&quot;\nwo are taliking&quot;</span>,<span class="hljs-string">&quot;\nwo are taliking&quot;</span>]</span>)<br>fsss<span class="hljs-selector-class">.close</span>()<br>fsss=fsss=<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;peseoo&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-selector-tag">line</span> <span class="hljs-keyword">in</span> fsss<span class="hljs-selector-class">.readlines</span>():<br>    <span class="hljs-built_in">print</span>(fsss<span class="hljs-selector-class">.tell</span>())<br>    <span class="hljs-built_in">print</span>(line)<br>结果：<br><span class="hljs-number">476</span><br>my name is zhounuowo are talikingwo are talikingwo are taliking<br> <br><span class="hljs-number">476</span><br>my name is zhounuowo are talikingwo are talikingwo are taliking<br></code></pre></td></tr></table></figure></li><li>2）seek(offset[,from])方法改变当前文件位置，offset变量表示要移动的字节数，from变量指定开始移动字节的参考位置</li><li>0：参考位置为文件开头</li><li>1：参考位置设为当前所在位置</li><li>2：参考位置设为文件结尾</li></ul><h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>一 os模块概述<br>python os模块包含普遍的操作系统功能，如果你希望你的程序能够与平台无关的话，这个模块尤为重要</p><p>import os<br>二 常用方法  </p><ul><li>1.os.name<br>输出字符串指示正在使用的平台，如果是window则用’nt‘表示<br>对于linux&#x2F;unix用户，它是posix</li><li>2.os.getcwd()函数得到当前工作目录，及当前python脚本工作的目录路径   返回当前工作目录</li><li>3.os.listdir(path)返回path指定目录下的所有文件和目录名</li><li>4.os.mkdir(path)创建一个目录</li><li>5.os.remove()删除一个文件</li><li>6.os.rmdir()删除一个目录</li><li>7.os.makedirs(path)创建一系列目录</li><li>8.os.environ(“path”)获取环境变量值</li><li>9.os.system(command)运行系统命令<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import os<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.getcwd()</span></span>)               C:\Users\Ivan\PycharmProjects\gerenxinxi<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.name)</span></span>                    nt<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.listdir(os.getcwd()</span></span>))       <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;.idea&#x27;</span>, <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;ddd&#x27;</span>, <span class="hljs-string">&#x27;hanshu.py&#x27;</span>, <span class="hljs-string">&#x27;peseonaninfo&#x27;</span>, <span class="hljs-string">&#x27;peseoo&#x27;</span>, <span class="hljs-string">&#x27;个人信息&#x27;</span>, <span class="hljs-string">&#x27;作业&#x27;</span>]</span><br>os<span class="hljs-selector-class">.mkdir</span>(<span class="hljs-string">&quot;lianxi&quot;</span>)<br>os<span class="hljs-selector-class">.mkdir</span>(<span class="hljs-string">&quot;D:\\ALLY\\lianxixi&quot;</span>)   在指定目录创建文件<br>dirs=<span class="hljs-string">&quot;D:\\ALLY\\lianxixiI\\TT&quot;</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(os.path.exists(dirs)</span></span>)  <span class="hljs-comment">//判断此路径文件是否存在，创建文件时只能最后一个文件不存在</span><br>os<span class="hljs-selector-class">.makedirs</span>(dirs) 创建多个文件夹<br></code></pre></td></tr></table></figure></li></ul><h4 id="os模块path"><a href="#os模块path" class="headerlink" title="os模块path"></a>os模块path</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.join</span>(<span class="hljs-selector-tag">path</span>.name)连接目录与文件名或目录<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.isfile</span>()和os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.isdir</span>()函数分别检验给出的路径是一个文件还是目录<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.exists</span>()函数用来检验给出的路径是否真的存在<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.split</span>(路径)函数返回一个路径的目录名和文件名<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.splitxt</span>(路径)分离文件名与扩展名<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.dirname</span>(path)返回文件路径<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.basename</span>(path)返回文件名<br>os<span class="hljs-selector-class">.path</span><span class="hljs-selector-class">.getsize</span>(name)获得文件大小，如果name是目录返回OL<br></code></pre></td></tr></table></figure><h3 id="PIL模块应用"><a href="#PIL模块应用" class="headerlink" title="PIL模块应用"></a>PIL模块应用</h3><p>以前叫PIL现在叫pillow<br>安装：安装失败，可能需要翻墙，直接安装到lib下面的site-package里面去，执行在线安装命令是pip install pillow<br>语法：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> ImageGrab<br>im=ImageGrab.grab()<br>im.save(‘thumbnail’.<span class="hljs-string">&#x27;jpeg&#x27;</span>)<br>更详细强大的用法：http:<span class="hljs-comment">//pillow.readthedocs.io/en/4.2.x/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python高阶</title>
    <link href="/2022/02/01/python/python%E9%AB%98%E9%98%B6/"/>
    <url>/2022/02/01/python/python%E9%AB%98%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>字符串是不可变数据类型，所有操作不会修改原数据，生成新的数据</p><p>字符串是复合数据类型，引号里面每个字符都是字符串的元素 。</p><ul><li>每个元素都有自己的位置，叫做索引。索引从0开始的，依次+1</li></ul><p>1、字符串取值： 某个元素取出来，通过索引取值  变量名[索引]</p><ul><li>正向索引</li><li>索引可以是负数：从右到做，-1 开始索引编号，负数里面 -1用的最多</li><li>索引超过索引范围：报错，IndexError: string index out of range</li></ul><p>2、切片：取多个值，从哪里开始取  取到哪里结束  a[索引头:索引尾:步长]</p><ul><li>切片 左闭右开的规则 [索引头:索引尾)，取头不取尾  ，如果想要去到最后元素，索引尾+1</li><li>索引尾： 可以不写，默认就是取到末尾</li><li>索引头： 可以不写，默认为0</li><li>切片索引尾超过范围 不会报错，取到最后一个元素。</li><li>步长： 走几个步取一次数据 ，步长可以省略 默认就是1. “123456789”<ul><li>步长为负数的: 逆序输出 ，print(a[::-1]) –重要</li><li>-2 -3  用的比较少 不做重点掌握</li></ul></li></ul><p>“””<br>找字符串的某个元素的索引是多少</p><ul><li>index(“ “) : 找到元素 返回索引值; 如果没有找到这个子元素，报错： ValueError: substring not found<ul><li>找到的话返回找到的第一个元素下标</li></ul></li><li>find(“D”) :找到元素 返回索引值;如果没有找到这个子元素，不会报错，返回-1；<ul><li>不报错 所以后续的代码还会执行。找到的话返回找到的第一个元素下标<br>“””<br>“””<br>字符串的格式化输出<br>格式化输出： f”{}{}..{}”<br>print(f”{b}”)<br>“””<br>“””<br>join方法：把一些数据拼接 用特定的符号链接 ： 2024&#x2F;01&#x2F;03 2024-01-03</li></ul></li><li>功能: 可以把列表&#x2F;元组的元素用指定的符号链接成为换一个新的字符串 “-“.join([year,mouth,day])<br>year &#x3D; “2024”<br>mouth &#x3D; “01”<br>day &#x3D; “03”<br>ts &#x3D; “-“.join([year,mouth,day,”21”,”22”,”34”])<br>必须是字符串，必须是可迭代元素列表<br>“””</li></ul><p>“””<br>split方法：把字符串的内容按照指定的分隔符进行分割成为多个子字符串 组成列表保存【每个子字符串都是列表的元素】。</p><p>使用场景：<br>面试题： url &#x3D; “<a href="http://www.lemonban.com/api/login%22,%E8%AF%B7%E4%BD%A0%E5%8F%96%E5%87%BA%E6%9D%A5%E8%BF%99%E4%B8%AAurl%E5%9C%B0%E5%9D%80%E9%87%8C%E7%9A%84%E5%9F%9F%E5%90%8D">http://www.lemonban.com/api/login&quot;,请你取出来这个url地址里的域名</a> （<a href="http://www.lemonban.com)/">www.lemonban.com）</a><br>-思路： 先切割  然年再列表里取值<br>“””<br>“””<br>replace方法：替换字符串里的某个子字符串。</p><ul><li>注意： 字符串是一个不可变的数据类型，不能修改的里面的元素。所以这个replace方法不是对原字符串进行修改，<br>  而是修改后生成一个新的字符串,记得保存给一个新的变量存起来。</li><li>a.replace(老子字符串,新子字符串,替换次数count),count不写默认全部替换</li></ul><p>思考： 如果要删除字符串里的某个元素，可以replace方法么？</p><ul><li>可以  替换为空字符串。</li></ul><p>b&#x3D;aa.replace(“s”,”火神山”,1)<br>“””<br>“””<br>strip方法：去除字符串里的某个元素，只能是前后的元素,不能是中间的。[字符串本身是不能被修改 随意重新新字符串]</p><ul><li>问题： 如果要删除中间的符号怎么办？ &#x3D;&#x3D; replace 替换掉。</li></ul><p>项目使用场景： 用户输入数据前后有一些空格符号  想要自动过滤掉这些符号 增加用户好友体验。</p><ul><li>从excel&#x2F;txt读取数据：可能包含一些其他的符号 【空格 换行符&#x2F;n】<br>“””<br>“””<br>字符串本身是不能被修改 随意重新新字符串。<br>lower ：把字符串的内容全部转化为小写的<br>upper： 把字符串的内容全部转化为大写的</li></ul><p>“””<br>“””<br>判断字符串是以xxx开头 结尾，用来做判断条件：&#x3D;&#x3D;做断言</p><ul><li>endswith: 结果是一个布尔值  True  False</li><li>startswith: 结果是一个布尔值  True  False<br>uname &#x3D; (“asdakskhjd&#x2F;n”<br>   )</li></ul><p>print(uname.endswith(“n”))<br>print(uname.startswith(“s”))<br>“””</p><p>字符串综合演练 （字符串索引和切片。注意位置和索引的区别）<br>my_hobby &#x3D; “Never stop learning!”<br>说明：“位置”指的是字符所处的位置（比如位置1，指的是第一个字符“N”）；<br>“索引”指的是字符的索引值（比如索引0， 代表的是第一个字符“N”）；<br>开始位置 ，是指字符串起始，即下标为0开始；末尾，是指字符串最后。 my_hobby[1:7]<br>1）截取从 位置2 ~ 位置6 的字符串(含 位置2和6)  1 5<br>2）截取完整的字符串<br>3）从 索引3 开始，每2个字符中取一个字符(含索引3，步长为2)<br>4）截取字符串末尾两个字符<br>5）字符串的倒序</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">my_hobby = <span class="hljs-string">&quot;Never stop learning!&quot;</span><br>截取从位置<span class="hljs-number">2</span> ~ 位置<span class="hljs-number">6</span>的字符串(含位置<span class="hljs-number">2</span>和<span class="hljs-number">6</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(my_hobby[<span class="hljs-number">1</span>:<span class="hljs-number">6</span>])</span></span><br>截取完整的字符串<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(my_hobby[:])</span><span class="hljs-title">a</span></span><br>从索引<span class="hljs-number">3</span>开始，每<span class="hljs-number">2</span>个字符中取一个字符(含索引<span class="hljs-number">3</span>，步长为<span class="hljs-number">2</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(my_hobby[<span class="hljs-number">3</span>::<span class="hljs-number">2</span>])</span></span><br>截取字符串末尾两个字符 【<span class="hljs-selector-attr">[-2:-1]</span> 是否可以取到最后两位？-- -<span class="hljs-number">1</span>尾 取不到】<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(my_hobby[-<span class="hljs-number">2</span>:])</span></span><br>字符串的倒序<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(my_hobby[::-<span class="hljs-number">1</span>])</span></span><br></code></pre></td></tr></table></figure><p>“””<br>列表-list ： 是[]包裹的内容<br>1、可变的数据复合数据类型 ，可以有多个元素 逗号隔开，<br>2、元素是可为任何的数据类型 ： int float bool str list tuple dict set</p><ul><li>注意： 但是在工作场景里 大部分时候都是单一类型数据比较多。–字符串 + 数字<br>3、取值 切片 ： 跟字符串一样的。</li><li>取值： 索引取值, 取值数据定义在列表里 取出来就是什么数据类型<ul><li>超出索引范围会报错： IndexError: list index out of range</li></ul></li><li>切片：索引头：索引尾：步长<ul><li>列表切片结果是一个列表，就算是一个元素也是列表 空列表<br>4、列表的是可变的数据类型，所以可以增删改操作</li></ul></li><li>对列表的操作修改列表本身数据。确认结果查看原列表 【对比字符串操作生成新的字符串 不能对原字符串进行修改】</li><li>append： 直接追加到列表的末尾   </li><li>insert: 指定索引插入元素到指定位置</li><li>extend: 批量加多个元素，本质上 对两个列表合并。</li></ul><h1 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h1><ul><li>pop() : 默认删除最后一个元素，也可以指定索引删除元素。返回这个删除的元素 可以用变量接受这个删除元素</li><li>remove(): 指定元素本身进行删除,如果有多个 删除第一个。如果没有找到元素 报错。ValueError: list.remove(x): x not in list</li></ul><p>5、列表的元素是可以重复的： 统计一个重复元素个数:count(元素)<br>6、len(): 统计数据类型长度的  元素个数 &#x3D;&#x3D;通用<br>7、求和sum() max() min() : 求数字列表</p><ul><li>列表的排序</li></ul><h4 id="定义列表-："><a href="#定义列表-：" class="headerlink" title="定义列表 ："></a>定义列表 ：</h4><p>rich &#x3D; [“@_@”,”卷起来”,”花非花”,”芒果”,12,3.14,True,[1,2,3,4,5]]</p><h4 id="增加元素"><a href="#增加元素" class="headerlink" title="增加元素"></a>增加元素</h4><p>rich.append(“and so on”)  # 直接追加到列表的末尾<br>print(rich)<br>rich.insert(1,”耶耶耶耶”) # 指定索引插入元素到指定位置<br>print(rich)<br>rich.extend([“Cassie”,”幻影”,”play”])<br>print(rich)</p><h4 id="删除元素-1"><a href="#删除元素-1" class="headerlink" title="删除元素"></a>删除元素</h4><p>a &#x3D; rich.pop(6) # 默认删除最后一个元素，也可以指定索引删除元素。<br>print(rich)<br>print(a) # 返回这个删除的元素 可以用变量接受这个删除元素<br>rich.remove(True) # 指定元素本身进行删除,如果有多个 删除第一个。如果没有找到元素 报错。ValueError: list.remove(x): x not in list<br>print(rich)</p><h4 id="修改元素-：-先取值再赋新值"><a href="#修改元素-：-先取值再赋新值" class="headerlink" title="修改元素 ： 先取值再赋新值"></a>修改元素 ： 先取值再赋新值</h4><p>rich[5] &#x3D; “小孩”<br>print(rich)</p><h4 id="列表相同元素"><a href="#列表相同元素" class="headerlink" title="列表相同元素"></a>列表相同元素</h4><p>print(rich.count(“耶耶耶耶”))</p><h4 id="统计列表的元素个数"><a href="#统计列表的元素个数" class="headerlink" title="统计列表的元素个数"></a>统计列表的元素个数</h4><p>print(len(rich))</p><p>8、sort 和reverse ： 排序和逆序<br>sort：最好是最数字列表排序【如果是非数字 ASCII A-Za-z】</p><ul><li>注意：不能同时对数字和字母一起排序</li><li>默认按照升序排列</li><li>也可以指定参数 进行降序排列 ： a.sort(reverse&#x3D;True)</li></ul><p>reverse: 对原列表进行逆序排列 对原列表进行修改</p><ul><li>对比 切片的 步长-1 逆序 ： a[::-1]  # 不会对原列表进行修改 得到新的列表<br>“””</li></ul><p>“””<br>元组-tuple ： 是()包裹的内容<br>1、不可变的数据复合数据类型 ，可以有多个元素 逗号隔开，<br>2、元素是可为任何的数据类型 ： int float bool str list tuple dict set</p><ul><li>注意： 但是在工作场景里 大部分时候都是单一类型数据比较多。–字符串 + 数字<br>3、取值 切片 ： 跟字符串一样的。</li><li>取值： 索引取值, 取值数据定义在列表里 取出来就是什么数据类型<ul><li>超出索引范围会报错： IndexError: list index out of range</li></ul></li><li>切片：索引头：索引尾：步长<ul><li>切片结果是一个列表，就算是一个元素也是元组 空元组<br>4、元组是不可变的数据类型，所以不可以增删改操作  没有对应的方法。</li></ul></li></ul><p>5、元组的元素是可以重复的： 统计一个重复元素个数:count(元素)<br>6、len(): 统计数据类型长度的  元素个数 &#x3D;&#x3D;通用<br>7、求和sum() max() min() : 求数字元组  &#x3D;&#x3D;内置函数<br>8、元组定义： 如果只有一个元素的时候，定义要加逗号 ; 否则就是相当于没有括号。<br>9、元组的定义的括号可以省略： 我们自己写代码很少用 但是要能看懂别人代码。</p><ul><li>解包： 元组元素一一拆出来 复制给变量 【列表可以】<br>“””<br>rich &#x3D; (“@_@”,”卷起来”,”花非花”,”芒果”)</li></ul><h4 id="修改元素-–报错-：TypeError-‘tuple’-object-does-not-support-item-assignment"><a href="#修改元素-–报错-：TypeError-‘tuple’-object-does-not-support-item-assignment" class="headerlink" title="修改元素  –报错 ：TypeError: ‘tuple’ object does not support item assignment"></a>修改元素  –报错 ：TypeError: ‘tuple’ object does not support item assignment</h4><p>rich[3] &#x3D; “小孩”<br>print(rich)</p><p>“””<br>字典：dict，用花括号包裹的键值对 ，元素是键值对  &#x3D;&#x3D; 类比 json数据 {“name”:”Cassie”,”age”:18}<br>1、元素是键值对，key:value</p><ul><li>key: key不能修改的 【key不能是可变的数据类型：列表 字典 集合， 其他的类型都可以】但是一般都是字符串。<ul><li>key不能够重复。 如果重复了 会替换掉原来的值。</li></ul></li><li>value: 没有任何限制。 可以嵌套字典</li></ul><p>2、字典取值： 不同通过索引取值</p><ul><li>通过key取值value</li><li>字典嵌套取值: print(case[“data”][“pwd”])</li></ul><p>3、字典是无序的 【Python3.6版本之前是无序的，每次打印结果都是顺序变化】，依然没有索引的。</p><p>4、字典可变数据类型：可以做增加删除和修改操作的。&#x3D;&#x3D; key不可以变，修改针对的是value</p><h4 id="增加键值对：-key的赋值操作-如果不存在的时候，进行新增操作"><a href="#增加键值对：-key的赋值操作-如果不存在的时候，进行新增操作" class="headerlink" title="增加键值对： key的赋值操作 &#x3D;&#x3D; 如果不存在的时候，进行新增操作"></a>增加键值对： key的赋值操作 &#x3D;&#x3D; 如果不存在的时候，进行新增操作</h4><p>case[“case_id”] &#x3D; 1<br>print(case)</p><h4 id="增加多个键值对-–update-合并字典"><a href="#增加多个键值对-–update-合并字典" class="headerlink" title="增加多个键值对 –update 合并字典"></a>增加多个键值对 –update 合并字典</h4><p>case.update({“header”:”测试头部”,”url”:”<a href="https://www.lemon.com"}/">https://www.lemon.com&quot;}</a>)<br>print(case)</p><h4 id="修改键值对：-key的赋值操作-key存在的时候，进行修改value操作"><a href="#修改键值对：-key的赋值操作-key存在的时候，进行修改value操作" class="headerlink" title="修改键值对： key的赋值操作 &#x3D;&#x3D; key存在的时候，进行修改value操作"></a>修改键值对： key的赋值操作 &#x3D;&#x3D; key存在的时候，进行修改value操作</h4><p>case[“method”] &#x3D; “get”<br>print(case)</p><h4 id="删除：-没有默认删除最后的说法-因为字典是无序的。-只能指定key删除键值对。"><a href="#删除：-没有默认删除最后的说法-因为字典是无序的。-只能指定key删除键值对。" class="headerlink" title="删除： 没有默认删除最后的说法 因为字典是无序的。 只能指定key删除键值对。"></a>删除： 没有默认删除最后的说法 因为字典是无序的。 只能指定key删除键值对。</h4><p>case.pop(“title”)<br>print(case)<br>“””</p><p>“””<br>集合： set {}，元素是单个数据 不是键值对。<br>1、{} –  空字典；set()– 空集合<br>2、集合复合数据类型 可以有多个元素 逗号隔开<br>3、元素是不可以重复的。 如果重复了元素 自动去重。</p><ul><li>使用场景： 给列表去重。 【列表的元素可以重复 count方法统计重复元素个数】<br>4、集合是没有顺序的： 集合元素是没有索引的。 不能通过索引取值了。 –了解<br>5、可以变化的数据类型： 对元素进行增删改操作。 –了解</li></ul><p>“””</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span> = &#123;&#125;  # 空字典<br><span class="hljs-attribute">b</span> = set()   # 空集合<br><span class="hljs-attribute">print</span>(type(a),type(b))<br><br><span class="hljs-attribute">c</span> = &#123;<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">77</span>,<span class="hljs-number">11</span>,<span class="hljs-number">22</span>,<span class="hljs-number">3</span>&#125;  # 集合<br><span class="hljs-comment"># print(c,len(c))</span><br><br><span class="hljs-attribute">list1</span> =<span class="hljs-meta"> [11,22,3,4,6,77,11,22,3]</span><br><span class="hljs-attribute">print</span>(list1)<br></code></pre></td></tr></table></figure><h4 id="对这个列表的元素进行去重-【求不重复的元素个数】：-列表–-集合【自动去重】–-转化回列表"><a href="#对这个列表的元素进行去重-【求不重复的元素个数】：-列表–-集合【自动去重】–-转化回列表" class="headerlink" title="对这个列表的元素进行去重 【求不重复的元素个数】： 列表–&gt; 集合【自动去重】–&gt;转化回列表"></a>对这个列表的元素进行去重 【求不重复的元素个数】： 列表–&gt; 集合【自动去重】–&gt;转化回列表</h4><h4 id="集合【自动去重】"><a href="#集合【自动去重】" class="headerlink" title="集合【自动去重】"></a>集合【自动去重】</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">set1 = <span class="hljs-built_in">set</span>(list1)<br><span class="hljs-built_in">print</span>(set1)<br><br><span class="hljs-comment"># 转化回列表</span><br>list2 = list(set1)<br><span class="hljs-built_in">print</span>(list2)<br></code></pre></td></tr></table></figure><h4 id="注意-区分字典和集合。"><a href="#注意-区分字典和集合。" class="headerlink" title="注意 区分字典和集合。"></a>注意 区分字典和集合。</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">d = &#123;<span class="hljs-string">&#x27;&quot;name&quot;:&quot;sds&quot;&#x27;</span>&#125;  <span class="hljs-comment"># 集合</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(d))</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">d[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;花非花&quot;</span>  <span class="hljs-comment"># key取value 报错：TypeError: &#x27;set&#x27; object does not support item assignment</span></span><br></code></pre></td></tr></table></figure><h4 id="for循环字典：-取到的key-还是value"><a href="#for循环字典：-取到的key-还是value" class="headerlink" title="for循环字典： 取到的key 还是value"></a>for循环字典： 取到的key 还是value</h4><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">case</span> = &#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;login&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>:&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;ITOP&quot;</span>,<span class="hljs-string">&quot;pwd&quot;</span>:<span class="hljs-string">&quot;123456&quot;</span>&#125;,<br>        <span class="hljs-string">&quot;expected&quot;</span>:&#123;<span class="hljs-string">&quot;msg&quot;</span>:<span class="hljs-string">&quot;ok&quot;</span>,<span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;0&quot;</span>&#125;, <span class="hljs-string">&quot;method&quot;</span>:<span class="hljs-string">&quot;post&quot;</span>&#125;<br># for i <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>:<br>#     print(i)  # i默认取到的key<br>#     print(<span class="hljs-keyword">case</span>[i])  # 然后再通过key 取值value<br># - 如果要value怎么做呢？<br># 方法一：<br># for v <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>.values():<br>#     print(v)<br>#<br># # 方法二：<br># for i <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>:<br>#     print(i)  # i默认取到的key<br>#     print(<span class="hljs-keyword">case</span>[i])  # 然后再通过key 取值value<br><br># 方式三： 不仅仅需要value 可能需要value 和key<br># for j <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>.items():<br>#     print(j) # 键值对放在一个元组里 ：(<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;login&#x27;</span>) | k,v = (<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;login&#x27;</span>)<br>for k,v <span class="hljs-keyword">in</span> <span class="hljs-keyword">case</span>.items():  # 可以分别直接拿到key 和value<br>    print(f<span class="hljs-string">&quot;key是&#123;k&#125;,value是&#123;v&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>字符串的方法: str.find , .index .lower .upper .join .strip .replace .split .endswith .startswith 。。。<br>列表方法: .append .extexd .insert .pop .remove ,.count<br>字典方法: .update .get .keys .values .item() .pop</p><p>“””<br>5、函数的定义和调用都需要加一个括号，这个括号是干啥的？</p><ul><li>问题： 函数定义里面，有些东西会变化的 【比如薪资提成奖金等这数据 依据每个人不一样】，能写死在函数里面么？</li></ul><p>函数的参数：函数里面一些变化的 不能写死在函数里面，进行参数化。– 变量代替这个值。</p><ul><li>形参： 本质上就是变量，写在函数的括号里面，表示这些会变化的数据。&#x3D;&#x3D; 形式上的参数 没有具体值</li><li>实参： 实际的数据 真正参数的值。在调用函数的时候写在括号里，用来传入具体数据的值。</li></ul><p>定义函数的参数有几种类型：<br>1、必备参数： 定义了一定要传入，不然就会报错；<br>2、默认参数：如果有些参数在大部分的场景下都是同一个值，可以给这个参数在定义的时候设置一个默认值，简化传参。</p><ul><li>设置了默认值， 传参的时候可以不传,使用默认值作为数据</li><li>也可以传值的，传了值就用传进入的数据<br>注意：同时设置了必备参数和默认参数的时候，默认参数必须在必备参数的后面。<br>3、不定长参数：不确定长度的参数，这个参数可以没有值，也可以有一个值或者多个值。【可变化的长度的参数】</li><li>使用场景： 函数里面有一些数据不确定是否有 也不确定有几个的时候 定义为不定长参数接受。</li><li>比如offer函数： 全勤奖，加班，bug之星，项目奖金，过节费… &#x3D;&#x3D; 定义为不定长参数</li><li><ul><li>和**是不能变的，arges kwargs 就是变量名 可以改的 但是习惯上都用这个 最好不要改。<br>*args：等前面的必备和默认参数都接受完了，剩下的实参都会被这个不定长参数接受</li></ul><ul><li>用元组格式来保存。</li></ul></li><li>*args的位置不一定要在最后，但是在的位置前面的参数接受完，剩下都会被他接受。</li><li>是按照位置传参的方式来传递实参<br>**kwargs: keyword关键字 ，等前面的必备和默认参数都接受完了，剩下的实参都会被这个不定长参数接受</li><li>并用字典的格式来保存。</li><li>**kwargs的位置一定要在最后,否则会报语法错误</li><li>是按照关键字传参的方式来传递实参</li></ul><p>传递函数的参数有几种类型：<br>1、位置传参： 形参和实参的位置一一对应的，如果顺序错误了，参数传递就给错人了。&#x3D;&#x3D; 会出问题</p><ul><li>参数比较多 类型多的时候 容易出错。&#x3D;&#x3D;不推荐<br>2、关键字传参： 带上形参去传递实参 不会跟位置相关了。 顺序无关 &#x3D;&#x3D; 参数比较多时候更常用和灵活。<br>注意： 可以混合用，但是不推荐。因为语法要求：就是关键字传参必须在位置传参后面。</li></ul><p>“””</p><p>面试题: *args和**kwargs的参数区别有哪些?<br>*args:等前面的参数接受完，剩下的所有的参数都会被这个不定长参数接受 -并以元组格式保存。<br>– 不一定要放在最后，放的位置在哪里 前面的参数接受完 剩下的都归他。 – 位置传参的方式传递参数<br>**kwargs:等前面的参数接受完，剩下的所有的参数都会被这个不定长参数接 受<br>–并以字典格式保存。 –关键字的传参的方式传递参数<br>– 一定要放在最后的位置。否则会语法错误。</p><p>函数的参数传入<br>      位置传参<br>      关键字传参<br>      混合传参</p><p>“””<br>函数解包</p><h4 id="简化–-元组解包-效果是-依次取元组的值-按照顺序传递给函数的参数"><a href="#简化–-元组解包-效果是-依次取元组的值-按照顺序传递给函数的参数" class="headerlink" title="简化– 元组解包 :效果是 依次取元组的值 按照顺序传递给函数的参数"></a>简化– 元组解包 :效果是 依次取元组的值 按照顺序传递给函数的参数</h4><p>result &#x3D; send_offer(*pare)<br>print(*result)</p><h4 id="对于多个返回结果保存在元组里-也可以解包。"><a href="#对于多个返回结果保存在元组里-也可以解包。" class="headerlink" title="对于多个返回结果保存在元组里 也可以解包。"></a>对于多个返回结果保存在元组里 也可以解包。</h4><p>a,b &#x3D; result<br>print(a,b)</p><h4 id="列表的解包-–-类比元组解包"><a href="#列表的解包-–-类比元组解包" class="headerlink" title="列表的解包 – 类比元组解包"></a>列表的解包 – 类比元组解包</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">pare = [15000,2500,300]</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">result = send_offer(*pare)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">print</span>(result)</span><br></code></pre></td></tr></table></figure><h4 id="字典的解包–-没有顺序-效果-按照key作为关键字传参的key-，value作为参数值进行，跟顺序无关。"><a href="#字典的解包–-没有顺序-效果-按照key作为关键字传参的key-，value作为参数值进行，跟顺序无关。" class="headerlink" title="字典的解包– 没有顺序 : 效果  按照key作为关键字传参的key ，value作为参数值进行，跟顺序无关。"></a>字典的解包– 没有顺序 : 效果  按照key作为关键字传参的key ，value作为参数值进行，跟顺序无关。</h4><h4 id="注意：-字典的key-很形参的关键字保持一致。"><a href="#注意：-字典的key-很形参的关键字保持一致。" class="headerlink" title="注意： 字典的key 很形参的关键字保持一致。"></a>注意： 字典的key 很形参的关键字保持一致。</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># para = &#123;<span class="hljs-string">&quot;bonus&quot;</span>:2500,<span class="hljs-string">&quot;subsidy&quot;</span>:600,<span class="hljs-string">&quot;salary&quot;</span>:17000&#125;</span><br><span class="hljs-meta"># result = send_offer(**para)</span><br></code></pre></td></tr></table></figure><p>“””</p><p>“””<br>配置文件  日志记录等 存在文本里。代码需要操作文本【文字文本 图片】。</p><ul><li>打开文件</li><li>读取数据</li><li>写入数据</li><li>关闭文件 ： 打开了文件 避免同时操作引起冲突出错 所以一定要关闭文件。</li></ul><p>文件操作：open()</p><ul><li>文件里有中文 没有加编码  就会报错</li><li>所以，一般来说 处理文字文本 默认都会加上 utf8的编码。</li></ul><p>如果文件里有非英文：记得一定要机上编码格式为 utf8。</p><ul><li>原因： 语言都是美国人发明 只能处理英文【ASCII】，中文以及其他的语言都处理不了。需要用utf8编码处理更多的语言。</li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs clean"># <span class="hljs-number">1</span>、打开文件<br># f = open(<span class="hljs-string">&quot;demo&quot;</span>)<br># # print(f)  # 返回了对象<br># # <span class="hljs-number">2</span>、读取数据<br># data = f.read()  # 一次性读取所有的内容 返回读取到的值<br># print(data)<br># # <span class="hljs-number">3</span>、关闭文件<br># f.close()<br><br># 如果有中文 open加上encoding 参数<br>f = open(<span class="hljs-string">&quot;demo&quot;</span>,encoding=<span class="hljs-string">&quot;UTF8&quot;</span>)<br>data = f.read()<br>print(data)<br></code></pre></td></tr></table></figure><p>zip(): 结果是一个可迭代的对象，可以转化为列表 或者字典</p><ul><li>把两组数据做一一对应的打包,以长度短的为准</li></ul><p>“””</p><p>“””<br>文件操作因为涉及到多人操作的话容易冲突，所以打开一个文件一定要记得关闭这个文件。</p><p>with 方式打开这个文件 默认自带关闭文件操作。 &#x3D;&#x3D;&#x3D; 推荐</p><ul><li>如此打开一个文件后 不需要再手动写close方法关闭文件。</li></ul><p>“””<br>with open(“datas&#x2F;demo”, encoding&#x3D;”UTF8”) as f:<br>    data &#x3D; f.read()<br>    print(data)</p><p>路径处理工具： pathlib 功能库实。 – 内置库 【类比内置函数理解】</p><ul><li>功能库：包含了一组功能的  比内置函数强大和丰富。</li><li>导入进来<br>1、获取我当前的文件的路径<br>2、获取父级的目录–上级 或者上级的上级 – parent<br>3、获取下级的目录</li></ul><p>这种方式获取的路径会自动化系统的盘符的方式，兼容mac Linux。<br>如果代码路径整个换了电脑存储位置，但是相当关系路径没有变化。</p><h4 id="导功能库进来到py文件-这个文件就可以使用这个功能库"><a href="#导功能库进来到py文件-这个文件就可以使用这个功能库" class="headerlink" title="导功能库进来到py文件  这个文件就可以使用这个功能库"></a>导功能库进来到py文件  这个文件就可以使用这个功能库</h4><p>import pathlib</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-meta"># <span class="hljs-number">1</span>、获取我当前的文件的路径 【动态获取当前文件的绝对路径】</span><br><span class="hljs-keyword">print</span>(pathlib.Path(<span class="hljs-keyword">__file__</span>).absolute())<br><br><span class="hljs-meta"># <span class="hljs-number">2</span>、获取父级的目录</span><br><span class="hljs-keyword">print</span>(pathlib.Path(<span class="hljs-keyword">__file__</span>).absolute().parent.parent)<br><br><span class="hljs-meta"># <span class="hljs-number">3</span>、获取下级的目录：</span><br>file_path = pathlib.Path(<span class="hljs-keyword">__file__</span>).absolute().parent.parent / <span class="hljs-string">&#x27;day06_函数和内置函数&#x27;</span> / <span class="hljs-string">&quot;demo3&quot;</span><br></code></pre></td></tr></table></figure><p>、包 ：package，代码包，包含多个py文件 【包包含多模块】，创建python package默认加一个init.py<br>    - 用来代码模块归类管理 &#x3D;&#x3D; 框架的代码分层里用上。<br>    - 里面的模块【py文件】可以直接进行导入 给别的模块使用。 –import<br>    - 和普通文件夹区别： 包会有init.py ， 包可以可以导入的。</p><p>问题： 每次导入模块之后，源模块里面运行的代码都会被执行一次 【print 函数执行等】。但是并不是我想的。</p><ul><li>如果有代码只想在自己的模块里执行，不想背其他模块导入后再执行 就放在main里面。</li><li>main函数实现。</li><li>作用： 用来调试代码用的。检查一下代码是否功能正常。</li></ul><p>参数：</p><ul><li>sink：日志文件的名字,直接写当前的目录里生成一个名字的日志文件。<ul><li>日志文件需要放在代码分层结构的 outputs&#x2F;logs层级里，要做路径处理 【相对路径-pathlib】</li><li>在tools里handle_path处理日志的路径</li><li>在使用日志模块 导入</li></ul></li><li>encoding: 编码格式，日志需要有中文，日志编码设置为 utf8</li><li>level: 级别一定要大写，INFO， ERROR<ul><li>这里参数设置了一个级别之后，这个级别及其以上的级别的日志都会被记录到日志文件里。级别低的不会记录。</li><li>优先级： critical &gt; error &gt; warning &gt; info &gt; debug</li><li>一般会设置INFO，critical &gt; error &gt; warning &gt; info这几个级别都会被记录日志。</li></ul></li><li>rotation: 进行日志文件分离的。一般会通过时间控制 | 文件大小控制。<ul><li>rotation&#x3D;”12:00”: 按照时间分离，每天12点都会创建换一个新的日志文件</li><li>rotation&#x3D;”1 week”: 按照时间分离，1周会创建换一个新的日志文件</li><li>rotation&#x3D;”20 MB”: 按照文件大小分离，日志文件超过10MB会创建换一个新的日志文件 &#x3D;&#x3D; 更常见</li></ul></li><li>retention: 限定日志文件的个数，超过限定的个数，旧的日志文件就会被删除。</li></ul><p>from loguru import logger<br>from tools.handle_path import log_path  # 导入日志的路径</p><h1 id="2、日志写入到文件："><a href="#2、日志写入到文件：" class="headerlink" title="2、日志写入到文件："></a>2、日志写入到文件：</h1><p>logger.add(sink&#x3D;log_path&#x2F;“lemonapi.log”,<br>           encoding&#x3D;”UTF8”,<br>           level&#x3D;”INFO”,<br>           rotation&#x3D;”1kB”,<br>           retention&#x3D;20)</p><p>#1、日志打印在控制台<br>logger.info(“日常记录日志”)</p><p>– init函数： def <strong>init</strong>():</p><ul><li>名字固定的，不能改，也不要写错– int错的；</li><li>对象的初始化的过程： 每次产生一个对象的过程，都会自动调用这个init初始化函数</li><li>init函数不能设置返回值的，只能保留默认None返回。</li><li>定义对象的属性的。–如何蒂尼实例属性，我们需要先搞清self。</li></ul><p>self：就是对象本身，在类里面表示一个对象。</p><ul><li>在类里面定义实例方法的时候，默认在括号里你加上self，表示这是一个对象的方法。</li><li>车卖给你之前【my_car】 在车厂的车–付钱之后my_car ，是 同一辆车么?<br>  &#x3D;&#x3D;是同一辆车，在类里面叫做self ，实例化之后 my_car.&#x3D;&#x3D; 内存地址都是一样的 同一个对象本身。</li><li>self： 变量名字可以换成其他的命名，se，但是习惯上都会使用self  不要改。</li></ul><p>#<strong>init</strong>(self):类初始化对象会调用<br>class Car:<br>    # 定义类属性，赋值 “True”<br>    wheel &#x3D; “True”<br>    engine &#x3D; “True”<br>    # 类里面定义一个方法：def语法 相当于类里面函数。–初始化方法 跟普通的函数有差异<br>    def <strong>init</strong>(self):<br>        print(“正在生成一辆车…”)</p><h1 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h1><p>my_car &#x3D; Car()</p><p>“””<br>方法： 类和对象的动作和行为</p><ul><li>类方法： 类共有的动作和行为 – 不掌握也可以，用的比较少。使用有很多局限性<ul><li>在方法上面加上申明 @classmethod</li><li>在类方法里只能调用类属性【cls.类属性】 不能调用实例属性</li><li>在类方法里不能调用实例方法。</li></ul></li><li>实例方法：某个具体的对象具备的动作和行为： 重点学习,类里面定义方法默认就是实例方法，所以这个用的最多。</li><li>init函数也是一个方法，实例方法。–特殊的方法  自动调用</li><li>静态方法： 用的更少 基本上。 普通函数 跟类和对象没啥关系。</li></ul><p>自己定义方法：默认就是实例方法</p><ul><li>可以通过对象调用</li><li>不可以通过类调用</li></ul><p>1、实例方法里面调用实例属性。-必须通过self调用</p><ul><li>实例属性 是所有的实例的方法可以共享属性的值。</li><li>实例方法里可以调用类属性，也是self.类实行</li></ul><p>2、实例方法可以实现相互之间的调动 &#x3D;&#x3D; 相当于函数相互调动</p><ul><li>self.实例方法进行调用。</li><li>实例方法定义参数- 参数只有这个方法自己可以用 ，不能共享。</li></ul><p>“””<br>class Car:<br>    wheel &#x3D; “True”<br>    engine &#x3D; “True”<br>    def <strong>init</strong>(self,cl&#x3D;”黑色”,lg&#x3D;”法拉利”): # 参数- 形参,变量，跟属性名没有任何关系<br>        self.color &#x3D; cl  # 实例属性，实例方法里可以调用-共享<br>        self.logo &#x3D; lg<br>        print(“正在生成一辆车…”)</p><pre><code class="hljs"># 定义实例方法 -- 函数 defdef driving(self,test): # 默认加self 表示这是一个实例方法--self就是对象本身    print(&quot;正在开车...&quot;)    print(f&quot;开的车的颜色是&#123;self.color&#125;，开的车logo是&#123;self.logo&#125;&quot;,test)  # 通过self调用实例属性    # 调用充电的方法 --self调用    self.recharge()# 定义实例方法 -- 函数 defdef recharge(self):    print(&quot;正在加油充电...&quot;)    print(f&quot;加油的车的颜色是&#123;self.color&#125;&quot;,self.wheel) # 实例方法里调动类属性 self.wheel# 定义类方法@classmethod  # 申明这个方法是类方法--装饰器 扩展函数的功能def get_engine(cls):  # 不再是self 是cls 代表这个类    print(f&quot;车的引擎是&#123;cls.engine&#125;&quot;) # 在类方法里调用类属性</code></pre><h1 id="实例方法通过实例调动"><a href="#实例方法通过实例调动" class="headerlink" title="实例方法通过实例调动"></a>实例方法通过实例调动</h1><p>my_car &#x3D; Car(cl&#x3D;”红色”,lg&#x3D;”宝马”)<br>print(my_car.color) # my_car对象调调用实例属性<br>print(my_car.wheel)  #  my_car对象调用类属性<br>my_car.driving() #  my_car对象调用实例方法</p><h1 id="my-car-recharge-my-car对象调用实例方法"><a href="#my-car-recharge-my-car对象调用实例方法" class="headerlink" title="my_car.recharge() #  my_car对象调用实例方法"></a>my_car.recharge() #  my_car对象调用实例方法</h1><p>“””<br>属性： 类属性 和实例属性 【特征和状态-天生的五官 手足；后天的-肤色，双眼皮，面容，性格】</p><ul><li>之前类属性和实例属性都是提前定义好了，这种就需要提前设计的时候就知道这个值是多少；</li><li>但是再工作中有些属性没有办法提前知道，中间过程产生的数据。<ul><li>比如： 登录之后接口鉴权，token &#x2F;cookies 【每次登录刷新 过期时间】</li><li>比如注册用户名和手机号不能重复使用，不能提前写死，随机生成之后 动态传参。<ul><li>【类比Jmeter的random，python的faker】，随机生成的， 不能提前知道。</li></ul></li></ul></li></ul><p>没有办法提前设定好的一些属性，需要后天动态生成属性和值。&#x3D;&#x3D;&#x3D; 动态属性。</p><p>动态属性【反射】:就是用来给类或者对象设置属性&#x2F;获取属性&#x2F;删除属性&#x2F;判断是否有属性。&#x3D;&#x3D; 四个方法：内置函数<br>1）设置属性：setattr( 对象&#x2F;类，属性名，属性值)  &#x3D;&#x3D;重点</p><ul><li>属性名需要是字符串类型</li><li>新增这个属性名字 -静态代码不能书别 会有提示，但是动态运行起来了之后就可以识别，所以不会报错的。<br>2）获取属性：getattr(对象&#x2F;类，属性名)  &#x3D;&#x3D;了解<br>3）判断是否存在属性：hasattr(对象&#x2F;类，属性名) &#x3D;&#x3D;知道</li><li>结果是布尔值： True  False</li><li>可以用来多if判断条件</li><li>使用场景： 如果代码里需要使用某个属性，可以先做一个判断是否存在这个属性，再获取使用。避免报错。<br>4）删除属性: delattr(对象&#x2F;类，属性名)  –了解</li><li>用的比较少 了解即可。</li></ul><p>“””</p><h1 id="1）设置属性：setattr-对象-类，属性名，属性值-，新增或者修改属性-用的最多"><a href="#1）设置属性：setattr-对象-类，属性名，属性值-，新增或者修改属性-用的最多" class="headerlink" title="1）设置属性：setattr( 对象&#x2F;类，属性名，属性值) ，新增或者修改属性 &#x3D;&#x3D;用的最多"></a>1）设置属性：setattr( 对象&#x2F;类，属性名，属性值) ，新增或者修改属性 &#x3D;&#x3D;用的最多</h1><p>class Car:<br>    wheel &#x3D; “True”<br>    engine &#x3D; “True”<br>    def <strong>init</strong>(self,cl&#x3D;”黑色”,lg&#x3D;”法拉利”): # 参数- 形参,变量，跟属性名没有任何关系<br>        self.color &#x3D; cl  # 实例属性，实例方法里可以调用-共享<br>        self.logo &#x3D; lg<br>        print(“正在生成一辆车…”)</p><h1 id="实例化对象-取名字-name"><a href="#实例化对象-取名字-name" class="headerlink" title="实例化对象 -取名字 -name"></a>实例化对象 -取名字 -name</h1><p>my_car &#x3D; Car()<br>setattr(my_car,”name”,”小可爱”)  # 动态设置属性name&#x3D;”小可爱” -实例属性<br>print(my_car.color)<br>print(my_car.name)<br>print(my_car.<strong>dict</strong>)  # 查看实例所有的属性 确认是否设置属性成功</p><h1 id="设置类的属性"><a href="#设置类的属性" class="headerlink" title="设置类的属性"></a>设置类的属性</h1><p>setattr(Car,”name”,”大可爱”)<br>print(Car.<strong>dict</strong>) # 查看类所有的属性 确认是否设置属性成功</p><h1 id="2）获取属性：getattr-对象-类，属性名"><a href="#2）获取属性：getattr-对象-类，属性名" class="headerlink" title="2）获取属性：getattr(对象&#x2F;类，属性名)"></a>2）获取属性：getattr(对象&#x2F;类，属性名)</h1><p>print(getattr(Car, “name”)) # 属性名存在的，直接返回属性值</p><h1 id="print-getattr-Car-“age”-属性名不存在的，直接报错：AttributeError-type-object-‘Car’-has-no-attribute-‘age’"><a href="#print-getattr-Car-“age”-属性名不存在的，直接报错：AttributeError-type-object-‘Car’-has-no-attribute-‘age’" class="headerlink" title="print(getattr(Car, “age”)) # 属性名不存在的，直接报错：AttributeError: type object ‘Car’ has no attribute ‘age’"></a>print(getattr(Car, “age”)) # 属性名不存在的，直接报错：AttributeError: type object ‘Car’ has no attribute ‘age’</h1><h1 id="3）判断是否存在属性：hasattr-对象-类，属性名"><a href="#3）判断是否存在属性：hasattr-对象-类，属性名" class="headerlink" title="3）判断是否存在属性：hasattr(对象&#x2F;类，属性名)"></a>3）判断是否存在属性：hasattr(对象&#x2F;类，属性名)</h1><p>print(hasattr(Car, “age”))<br>if hasattr(Car, “age”):<br>    getattr(Car,”age”)<br>else:<br>    setattr(Car,”age”,”3”)<br>    print(getattr(Car,”age”))</p><h1 id="4）删除属性-delattr-对象-类，属性名-–"><a href="#4）删除属性-delattr-对象-类，属性名-–" class="headerlink" title="4）删除属性: delattr(对象&#x2F;类，属性名) –"></a>4）删除属性: delattr(对象&#x2F;类，属性名) –</h1><p>print(Car.<strong>dict</strong>)<br>delattr(Car,”age”)<br>print(Car.<strong>dict</strong>)</p><p>from openpyxl import load_workbook<br>from tools.handle_path import excel_path</p><h1 id="第一步：-找到工作簿对象"><a href="#第一步：-找到工作簿对象" class="headerlink" title="第一步： 找到工作簿对象"></a>第一步： 找到工作簿对象</h1><p>wb &#x3D; load_workbook(excel_path)</p><h1 id="第二步：找表单-sheet-方括号取值-表单的名字"><a href="#第二步：找表单-sheet-方括号取值-表单的名字" class="headerlink" title="第二步：找表单  sheet &#x3D;&#x3D; 方括号取值 表单的名字"></a>第二步：找表单  sheet &#x3D;&#x3D; 方括号取值 表单的名字</h1><p>sh &#x3D; wb[“login”]</p><h1 id="可以获取excel表格所有数据-sh-values是一个生成器，for循环去遍历-或者list转化为嵌套元祖的列表"><a href="#可以获取excel表格所有数据-sh-values是一个生成器，for循环去遍历-或者list转化为嵌套元祖的列表" class="headerlink" title="可以获取excel表格所有数据- sh.values是一个生成器，for循环去遍历 或者list转化为嵌套元祖的列表"></a>可以获取excel表格所有数据- sh.values是一个生成器，for循环去遍历 或者list转化为嵌套元祖的列表</h1><h1 id="print-sh-values-生成器"><a href="#print-sh-values-生成器" class="headerlink" title="print(sh.values) # 生成器"></a>print(sh.values) # 生成器</h1><h1 id="print-list-sh-values-转化为列表之后，每行的数据是一个元组-列表嵌套元组。"><a href="#print-list-sh-values-转化为列表之后，每行的数据是一个元组-列表嵌套元组。" class="headerlink" title="# print(list(sh.values))  # 转化为列表之后，每行的数据是一个元组&#x3D;&#x3D;列表嵌套元组。"></a># print(list(sh.values))  # 转化为列表之后，每行的数据是一个元组&#x3D;&#x3D;列表嵌套元组。</h1><h1 id="for-data-in-sh-values-每次去到一行数据-元组保存的数据"><a href="#for-data-in-sh-values-每次去到一行数据-元组保存的数据" class="headerlink" title="for data in sh.values: # 每次去到一行数据-元组保存的数据"></a>for data in sh.values: # 每次去到一行数据-元组保存的数据</h1><h1 id="print-data"><a href="#print-data" class="headerlink" title="print(data)"></a>print(data)</h1><h1 id="for-i-in-data"><a href="#for-i-in-data" class="headerlink" title="for i in data:"></a>for i in data:</h1><h1 id="print-i"><a href="#print-i" class="headerlink" title="print(i)"></a>print(i)</h1><p>“””<br>任何一款工具操作连接数据库步骤一致：<br>第一步：连接上数据库</p><ul><li>连接数据库信息： ip&#x2F;域名，端口，数据库名字，用户名，密码<br>第二步：需要获取游标，然后执行查询操作【sql语句】</li><li>游标：小朋友看书 手指着看过地方念文字： 读到 哪行手指向哪行。 &#x3D;&#x3D;手指</li><li>数据库读取数据按照游标的位置开始读。前面如果已经读完数据，后面再次读取会从游标的位置开始读取数据。<br>第三步：真正执行sql语句 获取需要的执行结果：</li><li>这个执行结果是数据的数量总数。 如果result &#x3D; 0 ，说明没有符合条件的数据。<br>第四步： 获取具体的查询的数据，结果是格式保存的元组的格式保存。&#x3D;&#x3D;不太方便，希望字典保存。？？</li><li>注意问题： 游标问题<ul><li>cursor.fetchone() :从查询结果里获取一条数据 &#x3D;&#x3D;做多</li><li>cursor.fetchmany(size&#x3D;2): 从查询结果里获取多条数据，通过size参数进行自定义条数。<ul><li>默认是元组嵌套元组，每行数据是一个元组。</li></ul></li><li>cursor.fetchall(): 从查询结果里获取所有的数据<br>第五步：关闭数据库连接</li><li>数据库连接数是有限制的，用完连接数用完了 后面数据库连接就连接不上。用完了数据一定要记得关闭数据库的链接和游标。</li></ul></li></ul><p>import pymysql<br>from pymysql.cursors import DictCursor</p><h1 id="第一步：连接上数据库-获取连接对象"><a href="#第一步：连接上数据库-获取连接对象" class="headerlink" title="第一步：连接上数据库  获取连接对象"></a>第一步：连接上数据库  获取连接对象</h1><p>conn &#x3D; pymysql.connect(<br>    user&#x3D;”lemon_auto”,<br>    password&#x3D;”lemon!@123”,<br>    database&#x3D;”yami_shops”,<br>    port &#x3D; 3306,<br>    host &#x3D; “mall.lemonban.com”,<br>    charset&#x3D;”utf8mb4”,  # 支持中文字符集<br>    cursorclass&#x3D;DictCursor  # 读取的数据默认变成字典的格式<br>)</p><h1 id="第二步：需要获取游标，存在一个变量里。"><a href="#第二步：需要获取游标，存在一个变量里。" class="headerlink" title="第二步：需要获取游标，存在一个变量里。"></a>第二步：需要获取游标，存在一个变量里。</h1><p>cursor &#x3D; conn.cursor()</p><h1 id="第三步：真正执行sql语句-获取需要的执行结果："><a href="#第三步：真正执行sql语句-获取需要的执行结果：" class="headerlink" title="第三步：真正执行sql语句 获取需要的执行结果："></a>第三步：真正执行sql语句 获取需要的执行结果：</h1><p>sql &#x3D; ‘select user_phone,mobile_code from tz_sms_log where user_phone &#x3D; “13555554444” order by rec_date desc;’<br>result &#x3D; cursor.execute(sql)  # 用游标对象调用执行sql的方法<br>print(result)</p><h1 id="第四步：-获取具体的查询的数据"><a href="#第四步：-获取具体的查询的数据" class="headerlink" title="第四步： 获取具体的查询的数据"></a>第四步： 获取具体的查询的数据</h1><h1 id="one-row-data-cursor-fetchone"><a href="#one-row-data-cursor-fetchone" class="headerlink" title="one_row_data &#x3D; cursor.fetchone()"></a>one_row_data &#x3D; cursor.fetchone()</h1><h1 id="print-“fetchone结果”-one-row-data"><a href="#print-“fetchone结果”-one-row-data" class="headerlink" title="print(“fetchone结果”,one_row_data)"></a>print(“fetchone结果”,one_row_data)</h1><p>many_row_data &#x3D; cursor.fetchmany(size&#x3D;None) # 默认就是一条数据<br>print(“fetchmany结果”,many_row_data)</p><h1 id="all-row-data-cursor-fetchall"><a href="#all-row-data-cursor-fetchall" class="headerlink" title="all_row_data &#x3D; cursor.fetchall()"></a>all_row_data &#x3D; cursor.fetchall()</h1><h1 id="print-“fetchmany结果”-all-row-data"><a href="#print-“fetchmany结果”-all-row-data" class="headerlink" title="print(“fetchmany结果”,all_row_data)"></a>print(“fetchmany结果”,all_row_data)</h1><h1 id="第五步：关闭数据库连接"><a href="#第五步：关闭数据库连接" class="headerlink" title="第五步：关闭数据库连接"></a>第五步：关闭数据库连接</h1><p>cursor.close()  # 关闭游标<br>conn.close()  # 关闭连接</p><p>“””<br>1、pytest用例语法规则：–绿色三角，可以执行用例<br>1） 测试函数的形式写：函数名要以test_开头  &#x3D;&#x3D;简单 更常用           NNN   NNNNNNN<br>2) 测试类的形式写： 类名要以Test开头，类里面的方法也要以test_开头 才会被识别为pytest的用例。</p><p>class TestDemo:<br>    def test_02_demo(self):<br>        assert ger_ran() &gt; 10</p><pre><code class="hljs">def test_03_demo(self):    assert ger_ran() &lt; 15</code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程线程协程</title>
    <link href="/2021/03/18/python/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <url>/2021/03/18/python/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>多任务可以通过多进程 多线程 协程来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">##### 多线程实现多任务</span><br><br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;浇花的第<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>秒&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;打墙的第<span class="hljs-subst">&#123;i+<span class="hljs-number">1</span>&#125;</span>秒&quot;</span>)<br><br><span class="hljs-comment">#创造线程</span><br>t = Thread(target=work1)<br>t2 = Thread(target=work2)<br><span class="hljs-comment"># 开启线程</span><br>t.start()<br>t2.start()<br><span class="hljs-comment"># 等待线程执行结束后再往下执行</span><br>t.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行完啦&quot;</span>)<br><br>==============执行结果==============<br>浇花的第<span class="hljs-number">1</span>秒<br>浇花的第<span class="hljs-number">2</span>秒<br>浇花的第<span class="hljs-number">3</span>秒work2<br>work2<br>work2<br>work2<br>work2<br><br>浇花的第<span class="hljs-number">4</span>秒<br>work2<br></code></pre></td></tr></table></figure><p>CPU和多任务的关系  </p><p><img src="/../.vuepress/public/picture/WechatIMG67.jpeg">  </p><h3 id="并发和并行-1"><a href="#并发和并行-1" class="headerlink" title="并发和并行"></a>并发和并行</h3><ul><li><h4 id="并发-指的是任务数多于CPU核数，通过操作系统的各种任务调度算法，实现用多个任务一起执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）"><a href="#并发-指的是任务数多于CPU核数，通过操作系统的各种任务调度算法，实现用多个任务一起执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）" class="headerlink" title="并发 指的是任务数多于CPU核数，通过操作系统的各种任务调度算法，实现用多个任务一起执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）"></a>并发 指的是任务数多于CPU核数，通过操作系统的各种任务调度算法，实现用多个任务一起执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</h4></li><li><h4 id="并行-指的是任务数小于等于CPU核数，即任务真的是一起执行的"><a href="#并行-指的是任务数小于等于CPU核数，即任务真的是一起执行的" class="headerlink" title="并行 指的是任务数小于等于CPU核数，即任务真的是一起执行的"></a>并行 指的是任务数小于等于CPU核数，即任务真的是一起执行的</h4></li></ul><p><img src="/../.vuepress/public/picture/WechatIMG65.jpeg">  </p><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul><li><h4 id="同步-是指线程在访问某一资源时，获得了资源的返回结果后才会执行其他操作（先做某件事，再做某件事）。可以理解为-进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B执行，B执行后将结果给A-A再继续操作"><a href="#同步-是指线程在访问某一资源时，获得了资源的返回结果后才会执行其他操作（先做某件事，再做某件事）。可以理解为-进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B执行，B执行后将结果给A-A再继续操作" class="headerlink" title="同步 是指线程在访问某一资源时，获得了资源的返回结果后才会执行其他操作（先做某件事，再做某件事）。可以理解为 进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B执行，B执行后将结果给A,A再继续操作"></a>同步 是指线程在访问某一资源时，获得了资源的返回结果后才会执行其他操作（先做某件事，再做某件事）。可以理解为 进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B执行，B执行后将结果给A,A再继续操作</h4></li><li><h4 id="异步-与同步相对，是指线程在访问某一资源时，无论是否取得返回结果，都进行下一步操作，当有了资源返回结果时，系统自会通知线程"><a href="#异步-与同步相对，是指线程在访问某一资源时，无论是否取得返回结果，都进行下一步操作，当有了资源返回结果时，系统自会通知线程" class="headerlink" title="异步 与同步相对，是指线程在访问某一资源时，无论是否取得返回结果，都进行下一步操作，当有了资源返回结果时，系统自会通知线程"></a>异步 与同步相对，是指线程在访问某一资源时，无论是否取得返回结果，都进行下一步操作，当有了资源返回结果时，系统自会通知线程</h4></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="简述python线程的缺陷以及适用场景"><a href="#简述python线程的缺陷以及适用场景" class="headerlink" title="简述python线程的缺陷以及适用场景"></a>简述python线程的缺陷以及适用场景</h4><p>因为有GIL锁的存在，python中的多线程在同一时间没办法同时执行（即没办法实现并行）<br>适用场景：涉及到网络 磁盘IO的任务都是IO密集型任务，这类任务的特点是cpu消耗很少<br>任务的大部分时间都在等到IO操作完成（因为IO的速度要远远低于cpu和内存的速度）</p><h3 id="多线程创建方式一"><a href="#多线程创建方式一" class="headerlink" title="多线程创建方式一"></a>多线程创建方式一</h3><p>Thread类可以用来创建线程对象<br>target：指定线程执行的任务（一般是任务函数）<br>args kwargs:接受任务函数的参数  args&#x3D;(“aa”,) kwargs&#x3D;{“name”:zn}<br>name:指定线程的名字   </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><br><span class="hljs-keyword">from</span> threading import Thread<br><br>def work1(url):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(100):<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;第i:&#123;i&#125;个url:&#123;url&#125;&quot;</span>)<br><br><br>def work2():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(100):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2&quot;</span>)<br><br><br><span class="hljs-comment"># 创造线程</span><br>t = Thread(<span class="hljs-attribute">target</span>=work1, args=(<span class="hljs-string">&quot;https:www.baidu.cpmm&quot;</span>,), <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;周诺诺的线程1&quot;</span>)<br>t2 = Thread(<span class="hljs-attribute">target</span>=work2, <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;周诺诺的线程2&quot;</span>)<br><br><span class="hljs-comment"># 开启线程 异步执行的状态</span><br>t.start()<br>t2.start()<br><br><span class="hljs-comment"># 默认等待子线程1执行结束</span><br>t.join()  # 等待子线程t执行结束往下运行<br>t2.join()<br><br><span class="hljs-comment"># 主线程等待子线程执行结束后再往下执行</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行结束&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="多线程创建方式二-继承类来创建线程"><a href="#多线程创建方式二-继承类来创建线程" class="headerlink" title="多线程创建方式二 继承类来创建线程"></a>多线程创建方式二 继承类来创建线程</h3><p>通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，可以通过类来封装，新建一个类，只要继承threading.Thread就可以了，然后重写run方法<br>说明：  threading.Thread类的run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法，而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python解释器进行调度，当该线程获得执行的机会时，就会调用run方法执行线程</p><p>一个线程类只能写一个run方法，如果有多个任务要执行，则要创建多个线程类  </p><figure class="highlight julia"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs julia">创建多线程执行同一个任务<br>from threading <span class="hljs-keyword">import</span> Thread<br><br>class Mytread(Thread):<br>    <span class="hljs-string">&quot;&quot;&quot;自定义的线程类&quot;&quot;&quot;</span><br>    def __init__(self, a, b):<br>        super().__init__()  <span class="hljs-comment"># 重写后需要调用父类init 创建线程</span><br>        self.a = a<br>        self.b = b<br><br>    def run(self):  <span class="hljs-comment"># 方法名必须是run() 通过start()来调起</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        线程执行的任务函数</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>            print(<span class="hljs-string">&quot;我想要计算a+b&quot;</span>, self.a + self.b)<br><br><span class="hljs-comment"># 创建100个线程</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>    Mytread(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).start()<br><br><span class="hljs-comment"># 创建一个线程</span><br>m = MyThread(<span class="hljs-string">&quot;木森)</span><br><span class="hljs-string">m.start()</span><br></code></pre></td></tr></table></figure><h3 id="多线程共享全局变量"><a href="#多线程共享全局变量" class="headerlink" title="多线程共享全局变量"></a>多线程共享全局变量</h3><p>python中的多线程可以共享全局变量<br>缺点：但是会出现资源竞争，导致全局变量数据不准确。比如在计算时赋值还未完成，线程已经切换</p><p>操作系统如何切换py中的线程？<br>GIL全局解释器锁 同一时间只会执行一个线程，如果线程要执行必须要先获取全局解释器锁<br>1.遇到耗时等待 例如time.sleep(1)会自动释放GIL锁<br>2.当线程执行时间达到一定的阈值  会自动释放GIL锁<br>所以线程没有办法并行只能并发  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>n = <span class="hljs-number">100</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        n += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;进程<span class="hljs-subst">&#123;os.getpid()&#125;</span>work1执行玩不的值:&quot;</span>,n)<br>    <span class="hljs-comment"># 在子进程里获取父进程id</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;子进程的父进程id:<span class="hljs-subst">&#123;os.getppid()&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>        n += <span class="hljs-number">1</span><br><br><br>t1 = Thread(target=work1)<br>t2 = Thread(target=work2)<br><span class="hljs-comment"># 启动线程</span><br>t1.start()<br>t2.start()<br>t1.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主进程id:<span class="hljs-subst">&#123;os.getpid()&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="互斥锁解决资源竞争问题"><a href="#互斥锁解决资源竞争问题" class="headerlink" title="互斥锁解决资源竞争问题"></a>互斥锁解决资源竞争问题</h3><p>互斥锁为资源引入一个状态 锁定&#x2F;非锁定<br>某个线程要更改共享数据时，先将其锁定，此时资源的状态为锁定，其他线程不能更改直到该线程释放资源，将资源的状态变成非锁定，其他的线程才能再次锁定该资源<br>互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的准确性<br>threading模块定义了Lock类，可以方便的处理锁定:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">创建锁<br><span class="hljs-keyword">meta</span> = threading.Lock()<br>上锁 <br><span class="hljs-keyword">meta</span>.acquire()<br>释放锁 <br><span class="hljs-keyword">meta</span>.release()<br></code></pre></td></tr></table></figure><p>注意：如果这个锁之前是没有上锁的。那么acquire不会堵塞<br>如果在调用acquire这个锁上锁之前 他已经被其他线程上了锁那么此时acquire堵塞，直到这个锁被解锁为止 </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import threading<br><br>n = <span class="hljs-number">100</span><br><br><span class="hljs-function">def <span class="hljs-title">work1</span>():</span><br><span class="hljs-function">    <span class="hljs-keyword">global</span> n</span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-number">100</span></span>):</span><br><span class="hljs-function">        <span class="hljs-keyword">lock</span>.<span class="hljs-title">acquire</span>() # 上锁</span><br><span class="hljs-function">        n +</span>= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">lock</span>.release() <span class="hljs-meta"># 解锁</span><br><br><br><span class="hljs-function">def <span class="hljs-title">work2</span>():</span><br><span class="hljs-function">    <span class="hljs-keyword">global</span> n</span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-title">range</span>(<span class="hljs-params"><span class="hljs-number">100</span></span>):</span><br><span class="hljs-function">        <span class="hljs-keyword">lock</span>.<span class="hljs-title">acquire</span>() # 上锁</span><br><span class="hljs-function">        n +</span>= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">lock</span>.release() <span class="hljs-meta"># 解锁</span><br><br><br>t1 = threading.Thread(target=work1)<br>t2 = threading.Thread(target=work2)<br><br><span class="hljs-meta"># 创建一把锁</span><br><span class="hljs-keyword">lock</span> = threading.Lock()<br><span class="hljs-meta"># 启动线程</span><br>t1.start()<br>t2.start()<br>t1.<span class="hljs-keyword">join</span>()<br>t2.<span class="hljs-keyword">join</span>()<br>print(n)<br><br></code></pre></td></tr></table></figure><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁<br>尽管死锁很少发生，但一旦发生就会造成应用的停止响应<br>使用线程多的时候一定要避免出现死锁</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> threading<br><br>n = <span class="hljs-number">100</span><br><br>def work1():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>        lockA.acquire()<br>        lockB.acquire()<br>        n += <span class="hljs-number">1</span><br>        lockB.<span class="hljs-keyword">release</span>()<br>        lockA.<span class="hljs-keyword">release</span>()<br><br><br>def work2():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):<br>        lockB.acquire()<br>        lockA.acquire()<br>        n += <span class="hljs-number">1</span><br>        lockA.<span class="hljs-keyword">release</span>()<br>        lockB.<span class="hljs-keyword">release</span>()<br><br><br>t1 = threading.Thread(target=work1)<br>t2 = threading.Thread(target=work2)<br><br># 创建一把锁<br>lockA = threading.<span class="hljs-keyword">Lock</span>()<br>lockB = threading.<span class="hljs-keyword">Lock</span>()<br># 启动线程<br>t1.<span class="hljs-keyword">start</span>()<br>t2.<span class="hljs-keyword">start</span>()<br>t1.<span class="hljs-keyword">join</span>()<br>t2.<span class="hljs-keyword">join</span>()<br>print(n)<br><br></code></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>使用队列来实现线程间数据的同步，可以确保数据的安全<br>queue模块只能在一个进程的多个线程中使用<br>三种队列</p><h3 id="1-先入先出"><a href="#1-先入先出" class="headerlink" title="1.先入先出"></a>1.先入先出</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span><span class="hljs-built_in"> queue </span>import Queue,LifoQueue,PriorityQueue<br><br><span class="hljs-comment"># 初始化一个队列 默认是不限定队列的长度，也可以通过参数去指定队列中数据的最大长度</span><br>q =Queue()<br>q1 =Queue(<span class="hljs-attribute">maxsize</span>=5)<br><br><span class="hljs-comment">#往队列中添加数据</span><br>q.put(1)<br>q.put(3)<br>q1.put(4)<br><span class="hljs-built_in">print</span>(q.qsize())<br><span class="hljs-comment"># 队列中数据满了会堵塞，等待队列中的数据少了再加 可以设置等待的超时时间</span><br>q1.put(2000, <span class="hljs-attribute">timeout</span>=1)<br><span class="hljs-comment"># 往队列中添加数据不等待，如果队列中数据已满直接报错</span><br>q.put(2000,<span class="hljs-attribute">block</span>=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 往队列中添加数据不等待</span><br>q.put_nowait(2200)  <br><br><br><span class="hljs-comment">#获取队列中的数据</span><br><span class="hljs-built_in">print</span>(q.<span class="hljs-built_in">get</span>())<br><span class="hljs-built_in">print</span>(q.<span class="hljs-built_in">get</span>())<br><span class="hljs-built_in">print</span>(q1.<span class="hljs-built_in">get</span>())<br><span class="hljs-comment"># 获取数据 设置等待的超时时间</span><br>q.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">timeout</span>=1)<br><span class="hljs-comment">#获取数据默认不等待如果队列中没有数据直接报错</span><br><span class="hljs-built_in">print</span>(q.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">block</span>=<span class="hljs-literal">False</span>)) <br><span class="hljs-comment">#获取数据默认不等待直接报错如果队列中是空的</span><br><span class="hljs-built_in">print</span>(q.get_nowait())  <br><span class="hljs-comment"># 判断队列中数据是否为空，为空返回True</span><br>q.empty()<br><span class="hljs-comment"># 判断队列中数据是否已满，队列中数据已满返回True</span><br>q.full()<br><span class="hljs-comment">#获取队列中的任务数</span><br><span class="hljs-built_in">print</span>(q.qsize())<br><br><span class="hljs-comment"># join:等待队列中的任务全部执行完毕才会往下执行（不是队列为空，是队列中的所有任务都执行完，队列调用了task_done)</span><br><span class="hljs-comment"># 告诉队列任务执行完毕</span><br><br><span class="hljs-keyword">from</span><span class="hljs-built_in"> queue </span>import<span class="hljs-built_in"> Queue</span><br><span class="hljs-built_in"></span><br>q = Queue()<br>q.put(100)<br>q.put(200)<br><span class="hljs-built_in">print</span>(q.<span class="hljs-built_in">get</span>())<br><span class="hljs-comment"># 每从队列中获取一个数据，要通知队列数据用完了，就会继续往下执行</span><br>q.task_done()<br><span class="hljs-built_in">print</span>(q.<span class="hljs-built_in">get</span>())<br>q.task_done()<br><span class="hljs-comment"># 等待队列中的任务执行完毕（不是队列为空，是队列中所有的任务都执行完，调用了task_done）</span><br>q.join()<br>a = 100<br><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure><h3 id="2-后入先出"><a href="#2-后入先出" class="headerlink" title="2.后入先出"></a>2.后入先出</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">q2 = queue<span class="hljs-selector-class">.LifoQueue</span>()<br>q2<span class="hljs-selector-class">.put</span>(<span class="hljs-number">1</span>)<br>q2<span class="hljs-selector-class">.put</span>(<span class="hljs-number">11</span>)<br>q2<span class="hljs-selector-class">.put</span>(<span class="hljs-number">12</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(q2.get()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="3-优先级队列"><a href="#3-优先级队列" class="headerlink" title="3.优先级队列"></a>3.优先级队列</h3><p>队列中的数据为元祖类型,元祖的第一个元素表示数据的优先级,优先级越小的越先出来<br>关于优先级，尽量使用数值，如果全是字符串，会按ASCII码进行排序<br>quene模块一个队列只能在一个进程中使用 一个进程中多个线程使用  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">#<span class="hljs-number">3</span>.优先级  优先级最低的先出来 塞一个元祖<br>q3 = queue<span class="hljs-selector-class">.PriorityQueue</span>()<br>q3<span class="hljs-selector-class">.put</span>((<span class="hljs-number">11</span>,<span class="hljs-string">&#x27;hh&#x27;</span>))<br>q3<span class="hljs-selector-class">.put</span>((<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;heh&#x27;</span>))<br>q3<span class="hljs-selector-class">.put</span>((<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;hhdddd&#x27;</span>))<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(q3.get()</span></span>)<br></code></pre></td></tr></table></figure><h3 id="队列在多线程中的应用"><a href="#队列在多线程中的应用" class="headerlink" title="队列在多线程中的应用"></a>队列在多线程中的应用</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs routeros">相当于线程锁的作用<br><span class="hljs-keyword">from</span><span class="hljs-built_in"> queue </span>import<span class="hljs-built_in"> Queue</span><br><span class="hljs-built_in"></span><span class="hljs-keyword">from</span> threading import Thread<br><br>q = Queue()<br>q.put(1)<br><br><br>def work1():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(20):<br>        n = q.<span class="hljs-built_in">get</span>() # 从队列中获取数据，work1获取到了 work2便获取不到<br>        n += 1<br>        q.put(n)    # 把数据送回队列<br><br><br>def work2():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(20):<br>        n = q.<span class="hljs-built_in">get</span>()<br>        n += 1<br>        q.put(n)<br><br><br>t = Thread(<span class="hljs-attribute">target</span>=work1)<br>t2 = Thread(<span class="hljs-attribute">target</span>=work2)<br>t.start()<br>t2.start()<br>t.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n:&quot;</span>, q.<span class="hljs-built_in">get</span>())<br><br></code></pre></td></tr></table></figure><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是操作系统资源分配的基本单位,一个进程中可以有多个线程<br>线程：线程是操作系统任务调度的基本单位  </p><p>多个进程可以同时进行<br>每个进程之间资源是独立的</p><h3 id="进程和线程对比"><a href="#进程和线程对比" class="headerlink" title="进程和线程对比"></a>进程和线程对比</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>进程 能够完成多任务，比如在一台电脑上能够同时运行多个软件<br>线程 能够完成多任务，比如一个qq中的多个聊天窗口</p><h4 id="定义的不同"><a href="#定义的不同" class="headerlink" title="定义的不同"></a>定义的不同</h4><p>进程是系统进行资源分配和调度的一个独立单位<br>线程是进程的一个实体，是CPU调度和任务分派的基本单位，它比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源<br>python中同一个进程中的线程 是没办法并行的（GIL)，进程是可以并行的，不同进程中的线程也是可以并行的<br><img src="/the-nuo/picture/Snipaste_2021-05-10_12-01-00.png" alt="进程和线程"></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">from multiprocessing import Process<br><br><br>def <span class="hljs-built_in">work1</span>(name):<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;&#123;name&#125;在浇花&quot;</span>)<br><br><br>def <span class="hljs-built_in">work2</span>(name):<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;&#123;name&#125;在做饭&quot;</span>)<br><br><br>t = <span class="hljs-built_in">Process</span>(target=work1, args=(<span class="hljs-string">&quot;jerry&quot;</span>,))<br>t2 = <span class="hljs-built_in">Process</span>(target=work2, args=(<span class="hljs-string">&quot;jerry&quot;</span>,))<br>t.<span class="hljs-built_in">start</span>()<br>t2.<span class="hljs-built_in">start</span>()<br>t.<span class="hljs-built_in">join</span>()<br>t2.<span class="hljs-built_in">join</span>()<br></code></pre></td></tr></table></figure><h3 id="多进程不可共享全局变量"><a href="#多进程不可共享全局变量" class="headerlink" title="多进程不可共享全局变量"></a>多进程不可共享全局变量</h3><p>Python 多进程默认不能共享全局变量，因为进程的资源是独立的<br>主进程与子进程是并发执行的，进程之间默认是不能共享全局变量的(子进程不能改变主进程中全局变量的值)<br><img src="/the-nuo/picture/Snipaste_2021-05-10_12-13-36.png" alt="主进程与子进程"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Queue, Process<br><br>n = <span class="hljs-number">100</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">50000</span>):<br><br>        n += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1执行完后n&quot;</span>, n)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500</span>):<br>        n += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2执行完后n&quot;</span>, n)<br><br><br>t = Process(target=work1)<br>t2 = Process(target=work2)<br>t.start()<br>t2.start()<br>t.join()<br>t2.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两个子进程执行完后主进程中n的值:&quot;</span>, n)<br><br>=============执行结果=================<br>work1执行完后n:<span class="hljs-number">50100</span><br>work2执行完后n:<span class="hljs-number">600</span><br>两个子进程执行完后主进程中n的值:<span class="hljs-number">100</span><br><br></code></pre></td></tr></table></figure><h3 id="多进程之间通信"><a href="#多进程之间通信" class="headerlink" title="多进程之间通信"></a>多进程之间通信</h3><p>进程之间通信：使用队列<br>multiprocessing.Queue:可以多个进程之间共用（通用）跨进程通讯 队列要在主进程中创建 当成参数传给子进程<br>queue.Queue模块只能在一个进程中使用 一个进程中多个线程使用   </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">from</span> multiprocessing import Queue, Process<br><br><br><br>def work1(<span class="hljs-selector-tag">q</span>):  # 要把队列当成参数传进来<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>        n = q.<span class="hljs-built_in">get</span>()<br>        n += <span class="hljs-number">1</span><br>        q.<span class="hljs-built_in">put</span>(n)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work1 n执行后的值&quot;</span>, q.<span class="hljs-built_in">get</span>())<br><br><br>def <span class="hljs-built_in">work2</span>(q):  # 要把队列当成参数传进来<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>        n = q.<span class="hljs-built_in">get</span>()<br>        n += <span class="hljs-number">1</span><br>        q.<span class="hljs-built_in">put</span>(n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;work2 n执行后的值&quot;</span>, q.<span class="hljs-built_in">get</span>())<br><br><br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    # 队列要在主进程中创建 当成参数传给子进程<br>    q = <span class="hljs-built_in">Queue</span>()<br>    q.<span class="hljs-built_in">put</span>(<span class="hljs-number">100</span>)<br>    t = <span class="hljs-built_in">Process</span>(target=work1, args=(q,))<br>    t1 = <span class="hljs-built_in">Process</span>(target=work2, args=(q,))<br>    t.<span class="hljs-built_in">start</span>()<br>    t1.<span class="hljs-built_in">start</span>()<br>    t.<span class="hljs-built_in">join</span>()<br>    t1.<span class="hljs-built_in">join</span>()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两个子进程执行结束后，主进程打印的n&quot;</span>, q.<span class="hljs-built_in">get</span>())<br><br>=============执行结果=================<br>work1 n执行后的值 <span class="hljs-number">9015</span><br>work2 n执行后的值 <span class="hljs-number">10100</span><br>两个子进程执行结束后，主进程打印的n <span class="hljs-number">10100</span><br></code></pre></td></tr></table></figure><h3 id="通过继承自定义进程类"><a href="#通过继承自定义进程类" class="headerlink" title="通过继承自定义进程类"></a>通过继承自定义进程类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><span class="hljs-keyword">import</span> requests<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">创建4个进程发送100个请求</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myprocess</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, q</span>):<br>        <span class="hljs-built_in">super</span>().__init__()  <span class="hljs-comment"># 重写后需要调用父类init 创建线程</span><br>        <span class="hljs-variable language_">self</span>.q = q<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):  <span class="hljs-comment"># 方法名必须是run() 通过start()来调起</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        线程执行的任务函数</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> <span class="hljs-variable language_">self</span>.q.empty():<br>            <span class="hljs-comment"># 当队列中不为空时即进行下面操作</span><br>                url = <span class="hljs-variable language_">self</span>.q.get()<br>                requests.get(url)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;发送请求：<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># 打印进程id</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.pid&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 创建队列</span><br>q = Queue()<br><span class="hljs-comment"># 创建一个100个url放进队列里</span><br><span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    url = <span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span><br>    q.put(url)<br>q_list = []<br><br><span class="hljs-comment"># 开4个进程执行100个url</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    p = Myprocess(q)<br>    q_list.append(p)<br>    p.start()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> q_list:<br>    i.join()<br></code></pre></td></tr></table></figure><h3 id="获取进程id"><a href="#获取进程id" class="headerlink" title="获取进程id"></a>获取进程id</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><span class="hljs-keyword">import</span> os<br><br>n = <span class="hljs-number">100</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500000</span>):<br>        n += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;进程<span class="hljs-subst">&#123;os.getpid()&#125;</span>work1执行完毕n的值：&quot;</span>, n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;子进程的父进程id:<span class="hljs-subst">&#123;os.getppid()&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">500</span>):<br>        n += <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 获取子进程id</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;进程<span class="hljs-subst">&#123;os.getpid()&#125;</span>work2执行完毕n的值：&quot;</span>, n)<br>    <span class="hljs-comment"># 获取子进程里的父进程id</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;子进程的父进程id:<span class="hljs-subst">&#123;os.getppid()&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    p1 = Process(target=work1)<br>    p2 = Process(target=work2)<br><br>    p1.start()<br>    p2.start()<br><br>    p1.join()<br>    p2.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;两个子进程执行结束之后，主进程打印的n:&#x27;</span>, n)<br>    <span class="hljs-comment"># 获取主进程id</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;主进程获取id:<span class="hljs-subst">&#123;os.getpid()&#125;</span>&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="进程和队列使用实例"><a href="#进程和队列使用实例" class="headerlink" title="进程和队列使用实例"></a>进程和队列使用实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process, Queue<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一、使用队列和进程完成下面要求</span><br><span class="hljs-string"></span><br><span class="hljs-string">1、用一个队列来存储数据</span><br><span class="hljs-string"></span><br><span class="hljs-string">2、创建一个专门生产数据的进程类，当队列中数据数量少于50时，开始生产数据，每次生产200个数据，添加到队列中，每生产完一轮 暂停1秒  </span><br><span class="hljs-string"></span><br><span class="hljs-string">3、创建一个专门获取数据的进程类，当 队列中数据数量  大于10时就开始获取，,循环获取，每次获取20个。当 队列中数据数量  少于10的时候，暂停2秒 </span><br><span class="hljs-string"></span><br><span class="hljs-string">4、 创建一个进程生产数据 ，5个进程获取数据</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Produce</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    生产商品进程类</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, q</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.q = q<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 当队列中数据数量&lt;50时开始生产数据</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.q.qsize() &lt; <span class="hljs-number">50</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">200</span>):<br>                <span class="hljs-variable language_">self</span>.q.put(i)<br>            time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span>(<span class="hljs-title class_ inherited__">Process</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    获取数据进程类</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, q</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.q = q<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.q.qsize() &gt;= <span class="hljs-number">10</span>:<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>                <span class="hljs-variable language_">self</span>.q.get()<br>                <span class="hljs-variable language_">self</span>.q.task_done()<br>        <span class="hljs-keyword">else</span>:<br>            time.sleep(<span class="hljs-number">2</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    q = Queue()<br>    <span class="hljs-comment"># 创建一个生产数据进程</span><br>    p = Produce(q)<br>    p.start()<br>    p.join()<br>    <span class="hljs-comment"># 创建5个消费数据进程</span><br>    q_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        C = Consumer(q)<br>        C.start()<br>        q_list.append(C)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> q_list:<br>        i.join()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程又称微线程，是python中另外一种实现多任务的方式，只不过比线程更小占用更小执行单元（理解为需要的资源）。为啥说他是一个执行单元，因为它自带CPU上下文，这样只要在合适的gr时机，我们可以把一个协程切换到另一个协程。只要这个过程中保存或恢复CPU上下文那么程序还是可以运行的</p><h5 id="通俗的描述"><a href="#通俗的描述" class="headerlink" title="通俗的描述"></a>通俗的描述</h5><p>协程是线程中的一个特殊的函数，这个函数执行的时候，可以在某个地方暂停，并且可以重新在暂停处继续运行，协程在进行切换的时候，只需要保存当前协程函数中的一些临时变量信息，然后切换到另外一个函数中执行，并且切换的次数以及什么时候再切换回原来的函数，都由开发者自己决定。<br>协程切换的时候既不涉及到资源切换们也不涉及到操作系统的调度，而是在同一个程序中切换不同的函数执行，所以协程占用的资源非常少，切换的时候几乎不耗费什么资源，一秒钟切换个上万次系统都扛得住。<br>所以说协程与进程 线程相比不是一个维度的概念</p><h3 id="原生的协程实现多任务-一般不用（了解）"><a href="#原生的协程实现多任务-一般不用（了解）" class="headerlink" title="原生的协程实现多任务 一般不用（了解）"></a>原生的协程实现多任务 一般不用（了解）</h3><h4 id="协程函数的定义和调用"><a href="#协程函数的定义和调用" class="headerlink" title="协程函数的定义和调用"></a>协程函数的定义和调用</h4><p>async 加在def前面定义协程函数<br>await:只能写在协程函数中  await后面必须是一个可等待对象(协程 任务 asyncio.sleep()  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;work1---浇花--<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>  <br><span class="hljs-comment"># 调用协程函数，创建一个协程对象      </span><br>cor1 = work1()  <br><span class="hljs-comment"># 执行协程</span><br>asyncio.run(cor1)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 原生协程实现多任务</span><br><span class="hljs-comment"># 定义一个协程函数</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;work1---浇花--<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 协程中切换必须要添加等待 await.sleep()</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;work1---打枪--<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 协程中切换必须要添加等待 await.sleep()</span><br><br><span class="hljs-comment"># 定义一个启动函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>():<br>    <span class="hljs-comment"># 调用协程函数，返回的是一个协程对象</span><br>    cor1 = work1()<br>    cor2 = work2()<br>    <span class="hljs-comment"># 把协程创建成任务</span><br>    task1 = asyncio.create_task(cor1)<br>    task2 = asyncio.create_task(cor2)<br>    task3 = asyncio.create_task(work1())<br>    task4 = asyncio.create_task(work2())<br>    <span class="hljs-keyword">await</span> task1<br>    <span class="hljs-keyword">await</span> task2<br>    <span class="hljs-keyword">await</span> task3<br>    <span class="hljs-keyword">await</span> task4<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    m = run()<br>    asyncio.run(m)<br></code></pre></td></tr></table></figure><h3 id="greenlet模块实现多任务-一般不用（了解）"><a href="#greenlet模块实现多任务-一般不用（了解）" class="headerlink" title="greenlet模块实现多任务 一般不用（了解）"></a>greenlet模块实现多任务 一般不用（了解）</h3><p>为了更好的使用协程来完成多任务，python中的greenlet模块对其封装，从而使得切换任务变得简单，只能手动去切换</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs scss">import greenlet<br>import <span class="hljs-selector-tag">time</span><br><br><br>def <span class="hljs-built_in">work1</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>)<br>        cor2.<span class="hljs-built_in">switch</span>()   # 手动切换<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;浇花的第&#123;i + 1&#125;次&quot;</span>)<br><br><br>def <span class="hljs-built_in">work2</span>():<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>)<br>        cor1.<span class="hljs-built_in">switch</span>()  # 手动切换<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;打枪的第&#123;i + 1&#125;次&quot;</span>)<br><br><br>cor1 = greenlet.<span class="hljs-built_in">greenlet</span>(work1)<br>cor2 = greenlet.<span class="hljs-built_in">greenlet</span>(work2)<br><br># 调用switch方法才会执行， 通过switch切换到这个协程中去<br>cor1.<span class="hljs-built_in">switch</span>()<br><br></code></pre></td></tr></table></figure><h3 id="gevent模块-使用协程要使用的模块"><a href="#gevent模块-使用协程要使用的模块" class="headerlink" title="gevent模块  使用协程要使用的模块"></a>gevent模块  使用协程要使用的模块</h3><p>gevent模块又对greenlet进行了一层封装<br>当程序遇到io耗时等待的时候 会自动进行切换<br>gevent中默认是遇到gevent.sleep()会进行切换<br>如果让gevent遇到io自动切换,节省运行时间 需要在程序的导包处加一个monkey补丁,注意：只能在单线程中用，不支持多线程<br>加了monkey补丁 遇到time.sleep也会自动切换<br>from gevent import monkey monkey.patch_all() 两行代码要在文件的最上层引入</p><p>线程的切换：耗时io操作  网络磁盘 input output<br>协程切换：遇到io操作  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> gevent <span class="hljs-keyword">import</span> monkey<br>monkey.patch_all()<br><br><span class="hljs-keyword">import</span> gevent<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>():<br>     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        gevent.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 遇到gevent.sleep才会自动切换</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;浇花的第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>次&quot;</span>)<br><br> <span class="hljs-keyword">def</span> <span class="hljs-title function_">work2</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        gevent.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;打枪的第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>次&quot;</span>)<br><span class="hljs-comment"># 创建两个协程</span><br>g1 = gevent.spawn(work1)<br>g2 = gevent.spawn(work2)<br><br><span class="hljs-comment">#线程等待协程执行结束再往下执行</span><br><span class="hljs-comment">#gevent中是遇到gevent.sleep()会自动进行切换</span><br><br>g1.join()<br>g2.join()<br><br>=============================创建<span class="hljs-number">5000</span>个协程请求url===============================<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timeit</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    计算耗时装饰器</span><br><span class="hljs-string">    :param func:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        s_time = time.time()<br>        func(*args, **kwargs)<br>        e_time = time.time()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;此程序耗时：&#x27;</span>, e_time - s_time)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-comment"># 10000个请求 </span><br>urls = [<span class="hljs-string">&quot;https:www.baidu.com&quot;</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work3</span>():<br>    <span class="hljs-keyword">while</span> urls:<br>        url = urls.pop()<br>        <span class="hljs-comment"># gevent.sleep(0.5)   # gevent中是遇到gevent.sleep()会自动进行切换</span><br>        requests.get(ulr,timeout=<span class="hljs-number">1</span>) <span class="hljs-comment"># 如果让gevent遇到io自动切换,节省运行时间 需要在程序的导包处加一个monkey补丁</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;正在请求url:<span class="hljs-subst">&#123;url&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 创建5000个协程</span><br><span class="hljs-meta">@timeit</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    cor_list = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>        cor = gevent.spawn(work3)<br>        cor_list.append(cor)<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> cor_list:<br>        i.join()<br><br><br>main()<br><br></code></pre></td></tr></table></figure><h2 id="进程线程协程对比"><a href="#进程线程协程对比" class="headerlink" title="进程线程协程对比"></a>进程线程协程对比</h2><p>进程 线程 协程对比<br>1.进程是资源分配的单位，<br>2.线程是操作系统调度的单位<br>3.协程又名微线程，存在于线程之中<br>4.进程切换需要的资源最大效率很低<br>5.线程切换需要的资源一般效率一般当然在不考虑G I L锁的情况下。<br>6.协程切换任务资源很小，效率高<br>7.多进程多线程。根据C P U核数不一样，只有多进程能实现并行，但是协程是在一个线程中，所以是并发<br>8.注意点Python中的线程由于GIL锁的存在，并不能够实现并行，要充分利用多核C P U还是需要使用进程来做。<br>协程：协程又称微线程   </p><h2 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h2><p>当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态生成多个进程，但如果是成百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的pool方法<br>初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行请求，但是如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">import <span class="hljs-selector-tag">time</span><br><span class="hljs-selector-tag">from</span> multiprocessing import Pool<br><br><br>def work1(name):<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        time.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(f<span class="hljs-string">&quot;&#123;name&#125;:------work1----&#123;i&#125;-&quot;</span>)<br><br><br>def <span class="hljs-built_in">main</span>():<br>    # 创建一个拥有<span class="hljs-number">5</span>个进程的线程池<br>    po = <span class="hljs-built_in">Pool</span>(<span class="hljs-number">5</span>)<br>    # 往进程池添加<span class="hljs-number">4</span>任务  当任务数超过进程数数时，会先按照最大进程数来执行，执行完后，空出来的进程会继续执行<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    for i in <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        po.<span class="hljs-built_in">apply_async</span>(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,))<br>    # 关闭进程池（进程池停止接收任务）<br>    po.<span class="hljs-built_in">close</span>()<br>    # 主进程等待进程池中的任务结束在往下执行<br>    po.<span class="hljs-built_in">join</span>()<br><br><br>if __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">main</span>()<br><br></code></pre></td></tr></table></figure><h3 id="进程池之间的队列"><a href="#进程池之间的队列" class="headerlink" title="进程池之间的队列"></a>进程池之间的队列</h3><p>进程池和进程池之间进行通讯使用进程池里的队列<br>进程池的Queue 如果要使用Pool创建进程，就需要使用multiprocessing.Manager().Queue()<br>而不是multiprocessing.Queue()，否则会报错  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Pool,Manager<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">name,q</span>):   <span class="hljs-comment"># 队列要作为参数传入</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>:------work1----<span class="hljs-subst">&#123;i&#125;</span>----<span class="hljs-subst">&#123;q.get()&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-comment"># 创建一个用于进程池通讯的队列</span><br>    q = Manager().Queue()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>):<br>        q.put(<span class="hljs-string">f&quot;data-<span class="hljs-subst">&#123;i&#125;</span>&quot;</span>)<br><br><br>    <span class="hljs-comment"># 创建一个拥有5个进程的线程池</span><br>    po = Pool(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>        po.apply_async(work1, (<span class="hljs-string">&quot;musen1&quot;</span>,q)) <span class="hljs-comment"># 队列要作为参数传入</span><br>    <span class="hljs-comment"># 关闭进程池（进程池停止接收任务）</span><br>    po.close()<br>    <span class="hljs-comment"># 主进程等待进程池中的任务结束在往下执行</span><br>    po.join()<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br><br></code></pre></td></tr></table></figure><h2 id="concurrent-futures实现进程池-线程池"><a href="#concurrent-futures实现进程池-线程池" class="headerlink" title="concurrent.futures实现进程池 线程池"></a>concurrent.futures实现进程池 线程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor, ProcessPoolExecutor<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">work1</span>(<span class="hljs-params">name, age</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        time.sleep(<span class="hljs-number">1</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>:------work1----<span class="hljs-subst">&#123;age&#125;</span>---&quot;</span>)<br><br><br><span class="hljs-comment"># ThreadPoolExecutor模块实现了上下文管理器协议</span><br><br><span class="hljs-comment"># 创建一个线程池，开启5个线程</span><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> f:<br>    f.submit(work1, <span class="hljs-string">&quot;musen1&quot;</span>, <span class="hljs-number">18</span>)<br>    f.submit(work1, <span class="hljs-string">&quot;musen2&quot;</span>, <span class="hljs-number">20</span>)<br>    f.submit(work1, <span class="hljs-string">&quot;musen3&quot;</span>, <span class="hljs-number">23</span>)<br>    f.submit(work1, <span class="hljs-string">&quot;musen4&quot;</span>, <span class="hljs-number">50</span>)<br><br><span class="hljs-comment"># 创建一个进程池，开启5个进程  windows要在__main__下面运行</span><br><span class="hljs-keyword">with</span> ProcessPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> ts:<br>    ts.submit(work1, <span class="hljs-string">&quot;nuonuo&quot;</span>, <span class="hljs-number">18</span>)<br>    ts.submit(work1, <span class="hljs-string">&quot;nuonuo&quot;</span>, <span class="hljs-number">18</span>)<br>    ts.submit(work1, <span class="hljs-string">&quot;nuonuo&quot;</span>, <span class="hljs-number">18</span>)<br>    ts.submit(work1, <span class="hljs-string">&quot;nuonuo&quot;</span>, <span class="hljs-number">18</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数进阶</title>
    <link href="/2021/02/18/python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <url>/2021/02/18/python/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h1><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><h5 id="递归函数：在函数内部调用自身"><a href="#递归函数：在函数内部调用自身" class="headerlink" title="递归函数：在函数内部调用自身"></a>递归函数：在函数内部调用自身</h5><h5 id="递归边界：退出递归的终止条件"><a href="#递归边界：退出递归的终止条件" class="headerlink" title="递归边界：退出递归的终止条件"></a>递归边界：退出递归的终止条件</h5><h5 id="使用注意点：递归函数一定要写终止条件，否则将产生无限递归（死循环）"><a href="#使用注意点：递归函数一定要写终止条件，否则将产生无限递归（死循环）" class="headerlink" title="使用注意点：递归函数一定要写终止条件，否则将产生无限递归（死循环）"></a>使用注意点：递归函数一定要写终止条件，否则将产生无限递归（死循环）</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">#通过递归函数实现的任意数的阶乘<br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n)</span></span>:<br>    <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: #递归临界点：不再调用自身<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;执行结束&#x27;</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n<span class="hljs-number">-1</span>)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#通过递归实现斐波拉契数列</span><br>第一个数是<span class="hljs-number">1</span>，后面的每一个数等于前两个数相加之和<br>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">13</span>,<span class="hljs-number">21</span>,<span class="hljs-number">34</span>,<span class="hljs-number">55</span>,<span class="hljs-number">89</span>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fix</span>(<span class="hljs-params">n</span>):<br>  <span class="hljs-keyword">if</span> n&lt;<span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-keyword">elif</span> n ==<span class="hljs-number">1</span> <span class="hljs-keyword">or</span> n ==<span class="hljs-number">2</span>:<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">return</span> fix(n-<span class="hljs-number">1</span>)+fix(n-<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> sys<br><br>def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x)</span></span>:<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x - 1)</span></span><br><br># 获取最大递归深度 一般不用<br>res = sys.getrecursionlimit()<br><span class="hljs-built_in">print</span>(res)<br># 设置最大递归深度 一般不用<br>sys.setrecursionlimit(<span class="hljs-number">4000</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(14)</span></span><br></code></pre></td></tr></table></figure><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><h6 id="纯函数-（只懂概念和原则就好）"><a href="#纯函数-（只懂概念和原则就好）" class="headerlink" title="&#x3D;&#x3D;纯函数&#x3D;&#x3D;（只懂概念和原则就好）"></a>&#x3D;&#x3D;纯函数&#x3D;&#x3D;（只懂概念和原则就好）</h6><p> 一个函数的返回结果只依赖于他的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数</p><h5 id="2-1纯函数的3个原则"><a href="#2-1纯函数的3个原则" class="headerlink" title="2.1纯函数的3个原则"></a>2.1纯函数的3个原则</h5><ul><li>变量都只在函数作用域内获取，作为函数的参数传入</li><li>不会产生副作用，不会改变被传入的数据或者其他数据（全局变量）</li><li>相同的输入 保证相同的输出  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">def add(<span class="hljs-selector-tag">a</span>,<span class="hljs-selector-tag">b</span>)<br>  return <span class="hljs-selector-tag">a</span>+<span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="2-2函数的副作用"><a href="#2-2函数的副作用" class="headerlink" title="2.2函数的副作用"></a>2.2函数的副作用</h5><p>副作用是指函数被调用，完成了函数既定的计算任务，但同时因为访问了外部数据，尤其是因为对外部数据进行了写操作，从而一定改变了系统环境</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">li</span> = [11,22]<br>def <span class="hljs-built_in">f</span>(a,b):<br>    <span class="hljs-keyword">li</span>.<span class="hljs-keyword">append</span>(a)<br>    <span class="hljs-keyword">return</span> a+b<br><span class="hljs-keyword">print</span>(<span class="hljs-built_in">f</span>(10,12))<br></code></pre></td></tr></table></figure><h2 id="python内置函数"><a href="#python内置函数" class="headerlink" title="python内置函数"></a>python内置函数</h2><ul><li><p>1.map函数：会根据提供的函数对指定序列做映射</p></li><li><p>2.filter函数:函数用于过滤序列</p></li><li><p>3.zip函数：函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元祖</p></li></ul><h5 id="filter函数-过滤函数用于过滤序列-第一个参数是函数-第二个参数是可迭代对象，生成器也是可迭代对象"><a href="#filter函数-过滤函数用于过滤序列-第一个参数是函数-第二个参数是可迭代对象，生成器也是可迭代对象" class="headerlink" title="&#x3D;&#x3D;filter函数&#x3D;&#x3D;:过滤函数用于过滤序列.第一个参数是函数 第二个参数是可迭代对象，生成器也是可迭代对象"></a>&#x3D;&#x3D;filter函数&#x3D;&#x3D;:过滤函数用于过滤序列.第一个参数是函数 第二个参数是可迭代对象，生成器也是可迭代对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func1</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> n &lt; <span class="hljs-number">10</span>        <span class="hljs-comment">#如果i&lt;10返回True把可迭代对象中的元素返回到新的列表里如果i&gt;10返回false不保留元素</span><br>li = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>res = <span class="hljs-built_in">filter</span>(func1, li)  <span class="hljs-comment">#把传入filter的可迭代对象的元素全部遍历一遍，遍历出来当做参数传到前面的函数中</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(res))         <span class="hljs-comment">#返回一个迭代器 可以通过list()转化为列表</span><br></code></pre></td></tr></table></figure><h5 id="map函数-：统一处理一批数据时可以用"><a href="#map函数-：统一处理一批数据时可以用" class="headerlink" title="&#x3D;&#x3D;map函数&#x3D;&#x3D;：统一处理一批数据时可以用"></a>&#x3D;&#x3D;map函数&#x3D;&#x3D;：统一处理一批数据时可以用</h5><h6 id="自动将可迭代对象遍历，把遍历出来的数据，当成参数传入map第一个接口的函数中，将函数执行的结果，放到一个迭代器中进行返回"><a href="#自动将可迭代对象遍历，把遍历出来的数据，当成参数传入map第一个接口的函数中，将函数执行的结果，放到一个迭代器中进行返回" class="headerlink" title="自动将可迭代对象遍历，把遍历出来的数据，当成参数传入map第一个接口的函数中，将函数执行的结果，放到一个迭代器中进行返回"></a>自动将可迭代对象遍历，把遍历出来的数据，当成参数传入map第一个接口的函数中，将函数执行的结果，放到一个迭代器中进行返回</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">res</span> = map(lambda x,y:x+y,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])<br><span class="hljs-attribute">print</span>(list(res))<br></code></pre></td></tr></table></figure><h5 id="zip打包-可以接收多个可迭代对象-返回一个迭代器-迭代器中的数据迭代完就没有了"><a href="#zip打包-可以接收多个可迭代对象-返回一个迭代器-迭代器中的数据迭代完就没有了" class="headerlink" title="&#x3D;&#x3D;zip打包&#x3D;&#x3D; 可以接收多个可迭代对象,返回一个迭代器 迭代器中的数据迭代完就没有了"></a>&#x3D;&#x3D;zip打包&#x3D;&#x3D; 可以接收多个可迭代对象,返回一个迭代器 迭代器中的数据迭代完就没有了</h5><h6 id="以多个可迭代对象中最短的一个为准"><a href="#以多个可迭代对象中最短的一个为准" class="headerlink" title="以多个可迭代对象中最短的一个为准"></a>以多个可迭代对象中最短的一个为准</h6><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs leaf">res3 = zip([1, 2, 3], [11, 22, 33], [35, 36, 32, 39])<br>print(res3)             <span class="hljs-punctuation">#</span>返回一个可迭代对象<br><span class="hljs-punctuation">#</span><span class="hljs-keyword">print</span><span class="hljs-params">(<span class="hljs-keyword">list</span><span class="hljs-params">(<span class="hljs-variable">res3</span>)</span>)</span>      <span class="hljs-punctuation">#</span>可以通过list转化为列表<br>print(next(res3))<br>print(next(res3))<br><span class="hljs-punctuation">#</span>返回：以多个可迭代对象中最短的一个为准打包返回<br>(1, 11, 35)<br>(2, 22, 36)<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">通过两个列表一个列表存key 一个列表存value可以快速创建列表<br>res3 = <span class="hljs-built_in">zip</span>(<span class="hljs-selector-attr">[1, 2, 3]</span>, <span class="hljs-selector-attr">[11, 22, 33]</span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(dict(list(res3)</span></span>))<br><br>#&#123;<span class="hljs-number">1</span>: <span class="hljs-number">11</span>, <span class="hljs-number">2</span>: <span class="hljs-number">22</span>, <span class="hljs-number">3</span>: <span class="hljs-number">33</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="all-判断可迭代对象中所有的数据都为真（True"><a href="#all-判断可迭代对象中所有的数据都为真（True" class="headerlink" title="&#x3D;&#x3D;all&#x3D;&#x3D;:判断可迭代对象中所有的数据都为真（True)"></a>&#x3D;&#x3D;all&#x3D;&#x3D;:判断可迭代对象中所有的数据都为真（True)</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">age = <span class="hljs-number">0</span><br><span class="hljs-keyword">name</span> = <span class="hljs-number">1</span><br>res = <span class="hljs-built_in">all</span>(age,<span class="hljs-keyword">name</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h5 id="any-只要有一个参数为真返回True"><a href="#any-只要有一个参数为真返回True" class="headerlink" title="&#x3D;&#x3D;any&#x3D;&#x3D;:只要有一个参数为真返回True"></a>&#x3D;&#x3D;any&#x3D;&#x3D;:只要有一个参数为真返回True</h5><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs fortran">age = <span class="hljs-number">0</span><br><span class="hljs-keyword">name</span> = <span class="hljs-number">1</span><br>res = <span class="hljs-built_in">any</span>(age,<span class="hljs-keyword">name</span>)<br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h5 id="locals-获取当前局部作用域的所有变量，以字典形式进行输出"><a href="#locals-获取当前局部作用域的所有变量，以字典形式进行输出" class="headerlink" title="&#x3D;&#x3D;locals&#x3D;&#x3D;:获取当前局部作用域的所有变量，以字典形式进行输出"></a>&#x3D;&#x3D;locals&#x3D;&#x3D;:获取当前局部作用域的所有变量，以字典形式进行输出</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">aa = <span class="hljs-number">10000</span><br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>:<br>  a = <span class="hljs-number">100</span><br>  b = <span class="hljs-number">200</span><br>  print(locals())<br></code></pre></td></tr></table></figure><h5 id="globals-获取当前作用域内-模块）的所有全局变量，以字典形式输出"><a href="#globals-获取当前作用域内-模块）的所有全局变量，以字典形式输出" class="headerlink" title="globals:获取当前作用域内(模块）的所有全局变量，以字典形式输出"></a>globals:获取当前作用域内(模块）的所有全局变量，以字典形式输出</h5><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">aa = <span class="hljs-number">10000</span><br>def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>:<br>  a = <span class="hljs-number">100</span><br>  b = <span class="hljs-number">200</span><br>  print(globals())<br></code></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>python中有一种特殊的函数 不需要用def去定义，通过lamda表达式来定义<br>语法：lamda 参数:返回值表达式<br> <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"> 以下两种调用方法不常用<br>res4 = lambda <span class="hljs-built_in">a2</span>, <span class="hljs-keyword">b2: </span><span class="hljs-built_in">a2</span> + <span class="hljs-keyword">b2</span><br><span class="hljs-keyword"></span>print(res4(<span class="hljs-number">11</span>,<span class="hljs-number">22</span>))<br><br>res4 = (lambda <span class="hljs-built_in">a2</span>, <span class="hljs-keyword">b2: </span><span class="hljs-built_in">a2</span> + <span class="hljs-keyword">b2)(11,22)</span><br><span class="hljs-keyword"></span>print(res4)<br></code></pre></td></tr></table></figure></p><h6 id="可以结合filter函数一起用"><a href="#可以结合filter函数一起用" class="headerlink" title="可以结合filter函数一起用"></a>可以结合filter函数一起用</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br><span class="hljs-selector-tag">li</span> = <span class="hljs-selector-attr">[1, 2, 33, 45, 667, 43, 21, 12, 45]</span><br>res5 = <span class="hljs-attribute">filter</span>(lambda x: x &lt; <span class="hljs-number">10</span>, li)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(list(res5)</span></span>)<br></code></pre></td></tr></table></figure><h6 id="可以结合推导式一起用"><a href="#可以结合推导式一起用" class="headerlink" title="可以结合推导式一起用"></a>可以结合推导式一起用</h6><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">li</span> = <span class="hljs-selector-attr">[1, 2, 33, 45, 667, 43, 21, 12, 45]</span><br>res5 = <span class="hljs-selector-attr">[(lamda x:x/5)(i) for i in li]</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(res5)</span></span><br></code></pre></td></tr></table></figure><h6 id="三目运算符-适用于只有一种判断，非此即彼的情况"><a href="#三目运算符-适用于只有一种判断，非此即彼的情况" class="headerlink" title="&#x3D;&#x3D;三目运算符&#x3D;&#x3D;:适用于只有一种判断，非此即彼的情况"></a>&#x3D;&#x3D;三目运算符&#x3D;&#x3D;:适用于只有一种判断，非此即彼的情况</h6><p>简化代码</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">a1 = 100<br><span class="hljs-keyword">if</span> a1 &gt; 100:<br>    <span class="hljs-built_in">print</span>(100)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(22)<br><br><span class="hljs-built_in">print</span>(100)<span class="hljs-keyword">if</span> a1 &gt; 100 <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(22)<br></code></pre></td></tr></table></figure><h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><p>1.什么是偏函数</p><p>在python内置模块functools提供了很多有用的功能，其中一个就是偏函数（partial）</p><p>2.偏函数有什么用<br>当函数的参数个数太多，需要简化时。使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> functools import partial<br><br>li1 = [1, 2, 3, 6, 11, 23]<br>l2 = [1, 4, 3, 6, 11, 23]<br>list(filter(lambda x: x &gt; 5, li1))<br>list(filter(lambda x: x &gt; 5, li2))<br><br><span class="hljs-comment"># 通过偏函数创建一个新函数，提前传入原函数需要的参数，让我们在调用时更简单</span><br>func = partial(filter, lambda x: x &gt; 5)<br><span class="hljs-built_in">print</span>(list(func(li1)))<br><span class="hljs-built_in">print</span>(list(func(l2)))<br><br>import requests<br>res = requests.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>,params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:123&#125;,header=&#123;<span class="hljs-string">&quot;ass&quot;</span>:1212&#125;)<br>res2 = requests.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>,params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:124&#125;,header=&#123;<span class="hljs-string">&quot;ass&quot;</span>:1212&#125;)<br>res3 = requests.<span class="hljs-built_in">get</span>(<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>,params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:125&#125;,header=&#123;<span class="hljs-string">&quot;ass&quot;</span>:1212&#125;)<br><br><span class="hljs-built_in">get</span> = partial(requests.get,<span class="hljs-attribute">url</span>=<span class="hljs-string">&#x27;https://www.baidu.com&#x27;</span>,header=&#123;<span class="hljs-string">&quot;ass&quot;</span>:1212&#125;)<br>res1 = <span class="hljs-built_in">get</span>(params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:123&#125;)<br>res1 = <span class="hljs-built_in">get</span>(params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:124&#125;)<br>res1 = <span class="hljs-built_in">get</span>(params=&#123;<span class="hljs-string">&quot;kw&quot;</span>:125&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试问题</title>
    <link href="/2021/02/17/python/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2021/02/17/python/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li>什么是生成器？生成器和普通函数有何不同？<br>回答：</li></ol><p>生成器是使用 yield 关键字的函数，会返回一个迭代器，调用它时不会立即执行，而是返回一个生成器对象。<br>普通函数通过 return 一次性返回结果并结束执行，而生成器可以通过 yield 多次生成值，且每次调用时能恢复状态继续执行。</p><p>生成器和列表解析的区别是什么？<br>回答：</p><p>生成器表达式用 () 定义，而 列表解析用 []。<br>列表解析一次性生成所有元素，消耗较多内存，而生成器表达式按需生成元素，内存开销小。<br>示例：<br>python<br>复制代码<br>gen &#x3D; (x * x for x in range(1000))  # 生成器<br>lst &#x3D; [x * x for x in range(1000)]  # 列表</p><p>如何中断生成器？生成器终止后会发生什么？<br>回答：</p><p>生成器在以下情况会终止：<br>yield 执行完毕后没有后续代码。<br>主动抛出 StopIteration 异常。<br>外部调用 gen.close()。<br>生成器终止后，试图继续获取值会抛出 StopIteration 异常。</p><p>yield 和 return 的区别是什么？<br>回答：</p><p>yield 用于生成器函数，会暂停执行并返回一个值，而不会终止函数。<br>return 用于普通函数，返回值后函数执行结束。如果在生成器中使用 return，会导致抛出 StopIteration 异常。</p><p>生成器能否进行双向通信？<br>回答： 是的，生成器支持双向通信。通过 generator.send(value) 方法可以向生成器中传值。send 的值会成为 yield 表达式的返回值：</p><p>python<br>复制代码<br>def generator():<br>    value &#x3D; yield “Start”<br>    yield value</p><p>gen &#x3D; generator()<br>print(next(gen))        # 输出 “Start”<br>print(gen.send(“Data”)) # 输出 “Data”</p><p>生成器在测试中有什么应用场景？<br>回答：</p><p>数据流模拟：生成器可以模拟大规模或动态变化的数据流。<br>在测试开发中，我们可能需要模拟从外部服务（如 API、数据库、文件系统等）连续流入的大量数据。如果一次性将所有数据加载到内存中，会导致资源消耗过大，甚至内存溢出。这时可以用生成器按需生成模拟数据。<br>懒加载数据：测试中生成动态数据以避免提前加载。<br>在一些测试场景中，不需要立即获取所有数据，而是根据需要逐步加载。例如：<br>分页加载大量数据。<br>从数据库或文件中逐行读取。<br>测试需要实时处理的数据流。<br>生成器可以用于懒加载，在需要时才计算或加载下一批数据。<br>生成器逐行读取文件内容，而不是一次性将整个文件加载到内存。<br>避免了内存占用过高的问题，尤其适合处理超大文件或实时数据。</p><p>实现 Mock 数据：<br>python<br>复制代码<br>def mock_data():<br>    yield {“id”: 1, “name”: “Alice”}<br>    yield {“id”: 2, “name”: “Bob”}</p><p>for 循环迭代的底层步骤<br>假设代码如下：</p><p>python<br>复制代码<br>iterable &#x3D; [1, 2, 3]<br>for item in iterable:<br>    print(item)<br>获取迭代器对象<br>使用内置函数 iter() 将可迭代对象 iterable 转化为迭代器：</p><p>python<br>复制代码<br>iterator &#x3D; iter(iterable)<br>调用 next() 获取下一个值</p><p>for 循环隐式调用 next(iterator) 获取当前值，赋给循环变量 item。<br>如果成功获取到值，执行循环体（print(item)）。<br>如果没有更多值，抛出 StopIteration 异常。<br>捕获 StopIteration 并退出循环</p><p>当 next() 抛出 StopIteration 异常时，for 循环自动捕获该异常并停止迭代，不会报错。</p><p>for 循环迭代的底层步骤<br>假设代码如下：</p><p>python<br>复制代码<br>iterable &#x3D; [1, 2, 3]<br>for item in iterable:<br>    print(item)<br>获取迭代器对象<br>使用内置函数 iter() 将可迭代对象 iterable 转化为迭代器：</p><p>python<br>复制代码<br>iterator &#x3D; iter(iterable)<br>调用 next() 获取下一个值</p><p>for 循环隐式调用 next(iterator) 获取当前值，赋给循环变量 item。<br>如果成功获取到值，执行循环体（print(item)）。<br>如果没有更多值，抛出 StopIteration 异常。<br>捕获 StopIteration 并退出循环</p><p>当 next() 抛出 StopIteration 异常时，for 循环自动捕获该异常并停止迭代，不会报错。</p><p>for 循环迭代的流程图<br>获取迭代器 → 进入循环<br>调用 next() → 检查是否有下一个值<br>有值 → 执行循环体 → 返回步骤 2<br>无值 → 捕获 StopIteration → 结束循环<br>for 循环的核心步骤是：</p><p>调用 iter() 获取迭代器；<br>使用 next() 获取下一个值；<br>捕获 StopIteration 停止循环。</p><p>在 Python 中，for 循环用于遍历可迭代对象（如列表、元组、字符串、字典、集合、生成器等）。其迭代的具体步骤如下：</p><p>for 循环迭代的底层步骤<br>假设代码如下：</p><p>python<br>复制代码<br>iterable &#x3D; [1, 2, 3]<br>for item in iterable:<br>    print(item)<br>获取迭代器对象<br>使用内置函数 iter() 将可迭代对象 iterable 转化为迭代器：</p><p>python<br>复制代码<br>iterator &#x3D; iter(iterable)<br>调用 next() 获取下一个值</p><p>for 循环隐式调用 next(iterator) 获取当前值，赋给循环变量 item。<br>如果成功获取到值，执行循环体（print(item)）。<br>如果没有更多值，抛出 StopIteration 异常。<br>捕获 StopIteration 并退出循环</p><p>当 next() 抛出 StopIteration 异常时，for 循环自动捕获该异常并停止迭代，不会报错。<br>伪代码实现<br>for 循环的工作原理可以用以下伪代码表示：</p><p>python<br>复制代码</p><h1 id="模拟-for-循环的行为"><a href="#模拟-for-循环的行为" class="headerlink" title="模拟 for 循环的行为"></a>模拟 for 循环的行为</h1><p>iterable &#x3D; [1, 2, 3]<br>iterator &#x3D; iter(iterable)  # 获取迭代器</p><p>while True:<br>    try:<br>        item &#x3D; next(iterator)  # 获取下一个值<br>        print(item)  # 执行循环体<br>    except StopIteration:<br>        break  # 捕获异常后退出循环<br>for 循环迭代的流程图<br>获取迭代器 → 进入循环<br>调用 next() → 检查是否有下一个值<br>有值 → 执行循环体 → 返回步骤 2<br>无值 → 捕获 StopIteration → 结束循环<br>例子：手动模拟 for 循环<br>示例 1：用 iter() 和 next() 模拟<br>python<br>复制代码<br>lst &#x3D; [10, 20, 30]</p><h1 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h1><p>iterator &#x3D; iter(lst)</p><h1 id="手动调用-next"><a href="#手动调用-next" class="headerlink" title="手动调用 next"></a>手动调用 next</h1><p>print(next(iterator))  # 输出 10<br>print(next(iterator))  # 输出 20<br>print(next(iterator))  # 输出 30</p><h1 id="print-next-iterator-抛出-StopIteration-异常"><a href="#print-next-iterator-抛出-StopIteration-异常" class="headerlink" title="print(next(iterator))  # 抛出 StopIteration 异常"></a>print(next(iterator))  # 抛出 StopIteration 异常</h1><p>示例 2：结合生成器<br>python<br>复制代码<br>def my_generator():<br>    yield 1<br>    yield 2<br>    yield 3</p><p>gen &#x3D; my_generator()</p><h1 id="手动迭代生成器"><a href="#手动迭代生成器" class="headerlink" title="手动迭代生成器"></a>手动迭代生成器</h1><p>while True:<br>    try:<br>        print(next(gen))<br>    except StopIteration:<br>        break<br>适用的可迭代对象<br>for 循环可以用于任何实现了 迭代协议 或 序列协议 的对象：</p><p>迭代协议：实现了 <strong>iter</strong>() 方法并返回一个迭代器。<br>序列协议：实现了 <strong>getitem</strong>() 方法，从索引 0 开始按顺序获取元素，直到抛出 IndexError。</p><p>Python 中生成器的内置方法是生成器对象提供的用于交互和控制生成器的操作接口。这些方法包括：</p><ol><li><strong>next</strong>()<br>获取生成器的下一个值。<br>每次调用时，生成器运行到下一个 yield 表达式，暂停并返回值。<br>如果没有更多值，抛出 StopIteration 异常。<br>示例：</li></ol><p>python<br>复制代码<br>def my_gen():<br>    yield 1<br>    yield 2<br>    yield 3</p><p>gen &#x3D; my_gen()<br>print(gen.<strong>next</strong>())  # 输出: 1<br>print(gen.<strong>next</strong>())  # 输出: 2<br>print(gen.<strong>next</strong>())  # 输出: 3</p><h1 id="print-gen-next-抛出-StopIteration"><a href="#print-gen-next-抛出-StopIteration" class="headerlink" title="print(gen.next())  # 抛出 StopIteration"></a>print(gen.<strong>next</strong>())  # 抛出 StopIteration</h1><ol start="2"><li>send(value)<br>恢复生成器的执行，并将一个值发送到生成器中作为暂停点的 yield 表达式的结果。<br>第一次调用生成器必须传入 None，因为生成器尚未运行到 yield。<br>用于与生成器交互，实现动态数据传递。<br>示例：</li></ol><p>python<br>复制代码<br>def my_gen():<br>    x &#x3D; yield “Start”<br>    yield f”Received: {x}”</p><p>gen &#x3D; my_gen()<br>print(next(gen))          # 输出: Start<br>print(gen.send(“Hello”))  # 输出: Received: Hello</p><h1 id="print-gen-send-“World”-抛出-StopIteration"><a href="#print-gen-send-“World”-抛出-StopIteration" class="headerlink" title="print(gen.send(“World”)) # 抛出 StopIteration"></a>print(gen.send(“World”)) # 抛出 StopIteration</h1><ol start="3"><li>throw(type, value&#x3D;None, traceback&#x3D;None)<br>在生成器暂停的地方抛出一个指定类型的异常。<br>如果生成器内部捕获了异常，生成器可以继续运行；否则，异常会传播到调用方。<br>用于测试异常处理逻辑或中断生成器。<br>示例：</li></ol><p>python<br>复制代码<br>def my_gen():<br>    try:<br>        yield 1<br>        yield 2<br>    except ValueError as e:<br>        yield f”Exception caught: {e}”<br>    yield 3</p><p>gen &#x3D; my_gen()<br>print(next(gen))  # 输出: 1<br>print(gen.throw(ValueError, “Error!”))  # 输出: Exception caught: Error!<br>print(next(gen))  # 输出: 3<br>4. close()<br>关闭生成器，使其终止执行。<br>在生成器暂停的地方抛出 GeneratorExit 异常，触发清理逻辑。<br>如果生成器捕获了 GeneratorExit，可以执行相关清理代码；否则生成器会直接结束。<br>示例：</p><p>python<br>复制代码<br>def my_gen():<br>    try:<br>        yield 1<br>        yield 2<br>    finally:<br>        print(“Generator is closing”)</p><p>gen &#x3D; my_gen()<br>print(next(gen))  # 输出: 1<br>gen.close()       # 输出: Generator is closing</p><h1 id="print-next-gen-抛出-StopIteration"><a href="#print-next-gen-抛出-StopIteration" class="headerlink" title="print(next(gen))  # 抛出 StopIteration"></a>print(next(gen))  # 抛出 StopIteration</h1><p>生成器内置方法总结<br>方法功能描述典型用途<br><strong>next</strong>()获取生成器的下一个值；运行到下一个 yield 表达式并暂停。遍历生成器中的值。<br>send(value)向生成器发送一个值作为上次 yield 表达式的结果，并继续执行。实现生成器和调用方之间的双向数据通信。<br>throw(type)在生成器暂停的地方抛出异常；可选择捕获或传播。测试生成器的异常处理能力，或手动中断生成器。<br>close()关闭生成器，在暂停点触发 GeneratorExit 异常。提前终止生成器，并执行必要的清理逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自动化相关问题与解决</title>
    <link href="/2021/02/17/AutoTest/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <url>/2021/02/17/AutoTest/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><h4 id="1-接口口自动化坑之python-pymysql库执行sql时-报错SyntaxError-invalid-syntax"><a href="#1-接口口自动化坑之python-pymysql库执行sql时-报错SyntaxError-invalid-syntax" class="headerlink" title="1.接口口自动化坑之python pymysql库执行sql时 报错SyntaxError: invalid syntax"></a>1.接口口自动化坑之python pymysql库执行sql时 报错SyntaxError: invalid syntax</h4><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-00-27.png"></p><p>SELECT * from business_uat_2.by_orders WHERE order_type&#x3D;2 AND pay_type&#x3D;”HT_01” AND is_deleted&#x3D;0 AND sync_tag &#x3D;1 ;</p><p>在mysql中 手动执行时可以执行成功的、但是在用python pysql库执行时就报错了。</p><p>排查了半天发现是HT_01用了 双引号的原因，python执行的sql语句 字段值 必须用单引号。用双引号的话在mysql里可以运行成功。但是在python中运行会报错。</p><h3 id="1-自我介绍"><a href="#1-自我介绍" class="headerlink" title="1.自我介绍"></a>1.自我介绍</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"> <br></code></pre></td></tr></table></figure><h3 id="2-怎么从0到1设计自动化测试流程的？"><a href="#2-怎么从0到1设计自动化测试流程的？" class="headerlink" title="2.怎么从0到1设计自动化测试流程的？"></a>2.怎么从0到1设计自动化测试流程的？</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs clean">背景：<br>   - <span class="hljs-number">1.</span>开发没有持续维护接口文档<br>   - <span class="hljs-number">2.</span>接口测试没有做，没有做过自动化测试，提测后直接进入功能测试。<br>  <br> <span class="hljs-number">1.</span>引入swagger接口文档工具 第二 编写了自动化测试流程介入现有研发流程 流程图，接口测试前移放到和开发阶段同步进行并且编写自动化测试脚本脚本 。<br>前期准备工作：<br>#### <span class="hljs-number">1.</span>技术团队开了自动化项目启动会议<br><span class="hljs-number">1.</span>在会上我用ppt讲解了自动化测试是什么 自动化测试的价值，以及展示了自动化脚本的运行 测试报告的生成和展示。<br>#### <span class="hljs-number">2.</span>搭建了swagger接口文档平台 <br>编写了swagger部署和集成文档，接口文档注释添加规则文档， 接口自动化测试介入开发流程文档，评估了开发接入和学习成本  <br>在swagger宣讲会上了做了介绍和讨论。<br>#### <span class="hljs-number">3.</span>自动化测试框架的搭建<br><br>测试流程<br><span class="hljs-number">1.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span><br>#### <span class="hljs-number">4.</span>项目试点落地实施<br>选了三个迭代版本进行试点 循序渐进，前两个版本仅要求他们做了主流程接口文档的维护<br>我们按照接口自动化测试介入现有研发流程图来进行开发和测试之间的磨合。<br>开发出接口时会进行一轮接口测试，开发也会及时维护接口文档。 <br>三个版本后推广到了当前所以的迭代项目  <br><br>#### <span class="hljs-number">5.</span>扫尾工作<br><span class="hljs-number">1.</span>历史接口注释添加 这个主要是开发团队的任务由我来主导，和各个开发leader对接，自己预估给出排期我负责check进度和质量。<br>三个月左右我们的历史接口注释添加完毕<br><br><span class="hljs-number">2.</span>测试这块后期进行了接口测试用例设计，测试脚本编写方面的培训。<br>当前我们测试团队成员均会先进行接口测试并编写调试接口脚本。<br><br>在整个过程中流程的制定主要是和领导还有开发leader一起  <br>接口平台的搭建是和运维一起搭的   <br>swagger的部署和接入这块是和架构师一起做的。<br></code></pre></td></tr></table></figure><h3 id="3-从中有没有遇到过阻力你认为最大的困难是什么？"><a href="#3-从中有没有遇到过阻力你认为最大的困难是什么？" class="headerlink" title="3.从中有没有遇到过阻力你认为最大的困难是什么？"></a>3.从中有没有遇到过阻力你认为最大的困难是什么？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">最大的困难还是团队之间拥有同一目标，统一认知，拥抱变化愿意改变既有习惯和模式<br>首先我觉得最最重要是领导的支持，这是推进落地必不可少的条件，第二是自己的坚持和强大的内心。<br><br><br>比如接口测试文档，之前开发团队并没有及时维护，现在推进swagger接口文档有些开发觉得额外增加了工作量，一开始有抵触情绪。  <br>我们前期也有一定的心里预期也做了一些工作来避免这些。<br><br><span class="hljs-bullet">- </span>1.开了说明会 告诉他们接入的好处，对项目质量的好处对开发团队的好处。评估了开发学习成本和学习时间。直观告诉这个东西很快可以搞定。 <br><span class="hljs-bullet">- </span>2.各系统如何接入swagger，接口注释如何添加全部编写了说明文档。并且在会议上做了演示和讲解。<br><span class="hljs-bullet">- </span>3.并没有立马大规模推广，进行了试点和磨合，循序渐进的来推进<br></code></pre></td></tr></table></figure><h3 id="4-从中你学到了什么？"><a href="#4-从中你学到了什么？" class="headerlink" title="4.从中你学到了什么？"></a>4.从中你学到了什么？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>1.首先善于观察和思考项目流程中的痛点并且思考解决方案<br><span class="hljs-bullet">- </span>2.善于借力，多和架构师运维合作，共同完成一些技术推进工作<br><span class="hljs-bullet">- </span>3.拥有强大的内心很重要，并且领导也很重要，要多争取领导的支持和站台<br></code></pre></td></tr></table></figure><h4 id="5-介绍一个接口自动化框架"><a href="#5-介绍一个接口自动化框架" class="headerlink" title="5.介绍一个接口自动化框架"></a>5.介绍一个接口自动化框架</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">接口自动化是采用python+ddt+unittest <br>excel存储测试用例，ddt数据驱动读取测试用例拆包传到unittest 测试类中运行。.<br>主要设计思想 <br>第一：测试数据和测试用例分离，测试账号存储在配置文件，测试用例存储在excel，减少维护成本，提高用例可用性<br>第二：ddt 测试数据和测试代码分离，通过ddt读取数据来驱动测试用例批量执行。保证测试数据发生大量变化的情况下，测试代码可以不用改变<br><br>测试用例层：datas：excel测试数据存储。以模块为单位 一个模块一个<span class="hljs-keyword">sheet页</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">          cases:</span> 测试用例 一个模块一个文件，读取excel对应<span class="hljs-keyword">sheet页的测试用例批量发起请求并断言</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">          conf:</span>配置文件 主要负责接口<span class="hljs-keyword">base地址 </span>账号信息 数据库连接信息存储<br>逻辑处理层：handle excel<br>        handle mysql<br>        handle <span class="hljs-built_in">config</span><br>        handle log<br><span class="hljs-symbol">        context:</span>处理关联接口的测试用例<br>输出层：logs 运行日志输出<br>       reports 测试用例输出<br><br>第三方模块：htmlrunner生成测试报告<br><span class="hljs-symbol">main:</span>执行主入口模块<br>持续集成：<br>集成了<span class="hljs-keyword">jenkis拉取git代码运行 </span>生成测试报告发送测试邮件并且集成了钉钉@相关联系人进行测试报告分析和查看<br><span class="hljs-keyword">jenkis上配置了三个任务 </span>分别拉取对应git分支的代码执行。<br>测试环境 验证环境 生产环境维护了<span class="hljs-number">3</span>套代码，逻辑是一样的，主要是测试账号 请求url配置信息的不同 <br><br>执行策略：<br>生产环境是每次上线发布后执行<br>验证环境 配置的定时时间每天运行<br>测试环境 也是每次执行冒烟测试时自行运行<br><br>稳定性方面<span class="hljs-comment">;主要是加入了重运行机制。</span><br><br></code></pre></td></tr></table></figure><h3 id="6-介绍一下UI自动化框架"><a href="#6-介绍一下UI自动化框架" class="headerlink" title="6.介绍一下UI自动化框架"></a>6.介绍一下UI自动化框架</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">数据分离 测试数据和测试用例分离<br>PO设计模式 测试对象和测试用例分离 一般分为三层 1.页面维度的元素定位 2，页面维度的元素操作 3.测试用例<br>用例当中看不到元素定位和操作<br>测试用例层：<br>逻辑处理层<br>输出层<br></code></pre></td></tr></table></figure><h3 id="7-为什么选择-现在的python-ddt-unittest接口框架"><a href="#7-为什么选择-现在的python-ddt-unittest接口框架" class="headerlink" title="7.为什么选择 现在的python+ddt+unittest接口框架"></a>7.为什么选择 现在的python+ddt+unittest接口框架</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">本人比较熟悉python <span class="hljs-keyword">unittest</span>框架<br>如果现在的话，根据团队成员的不同水平，如果全员均不会写脚本的话，会采用httprunner为主。<br></code></pre></td></tr></table></figure><h3 id="8-怎么排查bug"><a href="#8-怎么排查bug" class="headerlink" title="8.怎么排查bug"></a>8.怎么排查bug</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>1.如果直接出现报错查看报错日志。也可以通过skywalking查看哪个系统挂掉了<br><span class="hljs-bullet">- </span>2.看一下是否和后端有交互，如果没有就是一个前端的bug.如果有先查看前端传参是否正确，前端传参正确，一般就是后端的问题，去数据库按照查询条件捞数据，查看是否后端sql脚本问题，逻辑处理的问题。<br></code></pre></td></tr></table></figure><h3 id="9-找一个业务说明一下系统之间的调用关系和技术实现"><a href="#9-找一个业务说明一下系统之间的调用关系和技术实现" class="headerlink" title="9.找一个业务说明一下系统之间的调用关系和技术实现"></a>9.找一个业务说明一下系统之间的调用关系和技术实现</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs">1.学员端有一个线上课程打卡功能<br>业务逻辑是这样：学员在学员端点击线上课程跳转到第三方鲸打卡小程序。完成打卡操作后，鲸打卡会把打卡信息 比如用户手机号，得分 推送回我们。我们会在进行后续的添加积分操作<br><br>当前在学员端的操作查询学员线上课程信息等级信息积分信息调用student系统。后续积分操作会调用crm系统进行学员积分添加。<br>关于技术实现：  <br>我们当前学员端在鲸打卡小程序的打卡操作一般集中在晚上。打卡时间比较集中，会在一个时间段内把打卡信息推送过来，<br>此时我们放在mq消息队列中，业务系统慢慢去消费处理。如果mq在消费消息中出现异常，mq会有重试机制 一直重试<br><br>银联对账机制：<br>在销售端创建银联订单推送银联，订单同步失败后，会重新推送不断调银联接口。<br><br>我们的合同创建过程信息比较多分为4步每一次点击下一步会跳到一个新的页面，且在每一步都有可能直接关闭，<br>前面创建过程使用了redis缓存机制。等到第四步确认提交后数据统一落库。<br></code></pre></td></tr></table></figure><h3 id="10-讲解一下功能测试用例设计-选取一个你们公司的场景"><a href="#10-讲解一下功能测试用例设计-选取一个你们公司的场景" class="headerlink" title="10.讲解一下功能测试用例设计 选取一个你们公司的场景"></a>10.讲解一下功能测试用例设计 选取一个你们公司的场景</h3><p>背景：<br>1.创建银联订单：</p><h3 id="11选取一个接口-比如订单接口-讲解一下接口测试用例设计"><a href="#11选取一个接口-比如订单接口-讲解一下接口测试用例设计" class="headerlink" title="11选取一个接口 比如订单接口 讲解一下接口测试用例设计"></a>11选取一个接口 比如订单接口 讲解一下接口测试用例设计</h3><ul><li>1.输入可根据参数类型进行设计<ul><li>a 必填项校验 </li><li>b 参数长度校验  超长字符未进行处理，会导致存储显示等异常</li><li>c 参数值的有效性校验 比如身份证号手机号 </li><li>d 参数是枚举值，各种枚举值都要测试，每一种枚举值就代表一种测试场景</li><li>f 参数的默认值，边界值，特殊字符，空字符等。</li><li>e 唯一性校验 有些字段必须唯一不能重复 比如姓名或者身份证号</li></ul></li><li>2.接口处理可按照逻辑进行用例设计，接口逻辑结合实际的业务场景逻辑复杂先画业务流程图或xmind写测试点 要做到场景覆盖。<ul><li>a 约束条件 比如实物为有限状态才能赠送。学员有课时才能参加活动</li><li>b 状态限制 比如我们的系统大部分状态下都需要登录状态且权限正确才能操作</li><li>c 数值限制 比如学员升级接口。如果学员课时不足无法扣课时则不能进行升级</li><li>d 顺序分析 一些接口是有调用顺序的，比如打乱顺序调用是否会报错</li><li>场景覆盖时考虑异常场景，比如我们的创建订单并同步银行接口。同步失败或者接口超时后，是否有正常业务提示。</li><li>重复提交（幂等）比如我们的核销扣课时接口，只能扣一次如果短时间内多次点击的话，要看开发是否有做处理 如唯一字段唯一索引，重复插入数据报错</li></ul></li></ul><h3 id="12-接口测试用例返回值校验怎么校验？"><a href="#12-接口测试用例返回值校验怎么校验？" class="headerlink" title="12.接口测试用例返回值校验怎么校验？"></a>12.接口测试用例返回值校验怎么校验？</h3><p>针对输出 可根据结果进行分析设计</p><ul><li>a 校验返回值 code msg</li><li>b 了解数据库通过sql脚本去验证</li></ul><h3 id="13-讲解一下你的接口测试平台"><a href="#13-讲解一下你的接口测试平台" class="headerlink" title="13.讲解一下你的接口测试平台"></a>13.讲解一下你的接口测试平台</h3><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_21-04-03.png"></p><h3 id="14-django的生命周期"><a href="#14-django的生命周期" class="headerlink" title="14.django的生命周期"></a>14.django的生命周期</h3><p>前端请求—&gt;nginx—&gt;uwsgi.—&gt;中间件—&gt;url路由—-&gt;view试图—&gt;orm—-&gt;拿到数据返回给view—-&gt;试图将数据渲染到模版中拿到字符串—-&gt;中间件—&gt;uwsgi—-&gt;nginx—-&gt;前端渲染。</p><h3 id="15-django中间件"><a href="#15-django中间件" class="headerlink" title="15.django中间件"></a>15.django中间件</h3><p>中间件是 Django 用来处理请求和响应的钩子框架，配置文件settings.py的 MIDDLEWARE 配置项列表中</p><h3 id="16-选取一个模块介绍一下你们公司的业务"><a href="#16-选取一个模块介绍一下你们公司的业务" class="headerlink" title="16.选取一个模块介绍一下你们公司的业务"></a>16.选取一个模块介绍一下你们公司的业务</h3><h3 id="17-介绍一下公司一个功能模块的测试用例设计"><a href="#17-介绍一下公司一个功能模块的测试用例设计" class="headerlink" title="17.介绍一下公司一个功能模块的测试用例设计"></a>17.介绍一下公司一个功能模块的测试用例设计</h3><h3 id="18-性能当前怎么做的，性能测试流程。关键指标"><a href="#18-性能当前怎么做的，性能测试流程。关键指标" class="headerlink" title="18.性能当前怎么做的，性能测试流程。关键指标"></a>18.性能当前怎么做的，性能测试流程。关键指标</h3><h3 id="19-怎么把控测试进度"><a href="#19-怎么把控测试进度" class="headerlink" title="19.怎么把控测试进度"></a>19.怎么把控测试进度</h3><p>1.每月需求碰头会，了解接下来一个月的安排<br>2.执行测试团队人力资源排期表。团队一起来维护。横列是日期</p><ul><li>1.在项目前期制定合理的测试计划，充分考虑测试的风险点，预估充足的测试时间。</li><li>2.关键节点把控 开发提测节点延迟预警，如果延迟要尽快反馈，商量解决方案。和测试人员及时了解测试进度，是否按照预期推进，阻塞流程是否有及时解决。</li><li>3.过程监控，tapd上查看各项目bug趋势，每天新增解决bug，判断当前项目所处阶段，测试人员时间安排</li><li>4.测试日报</li><li>4.如果有需求变更，参照需求变更</li></ul><h3 id="20-怎么把控测试质量"><a href="#20-怎么把控测试质量" class="headerlink" title="20.怎么把控测试质量"></a>20.怎么把控测试质量</h3><ul><li>按照测试分层，最底层做单元测试，    </li><li>中间层，做接口测试，集成测试。  接口测试工作前移和开发一起进行  </li><li>最上层做ui测试，端到端测试，探索性测试。  </li><li>每个测试阶段，投入不同的测试手段。</li></ul><h3 id="21-怎么把控测试覆盖度"><a href="#21-怎么把控测试覆盖度" class="headerlink" title="21.怎么把控测试覆盖度"></a>21.怎么把控测试覆盖度</h3><ul><li>首先接口测试覆盖所有接口，包括后期自动化脚本回归。 </li><li>功能是覆盖所有的需求功能点，用例100%执行，bug全部回归完毕</li></ul><h3 id="22-介绍一下项目重构中遇到的问题以及怎么解决的"><a href="#22-介绍一下项目重构中遇到的问题以及怎么解决的" class="headerlink" title="22.介绍一下项目重构中遇到的问题以及怎么解决的"></a>22.介绍一下项目重构中遇到的问题以及怎么解决的</h3><h3 id="23-重构项目的测试方案"><a href="#23-重构项目的测试方案" class="headerlink" title="23.重构项目的测试方案"></a>23.重构项目的测试方案</h3><p>根据测试计划<br>总得测试方案 1.及早介入 2.先化整为零各个击破，然后再交叉测试<br>1.根据项目需求分析后 我们确认做三轮功能测试，接口自动化测试 和 个别高并发场景做性能压测<br>2.第一轮：接口测试+模块测试+接口主流程冒烟测试脚本编写及第一轮集成测试<br>  第二轮：集成测试关联模块测试+回归测试<br>  第三轮：集成测试交叉测试+迁移数据校验+性能测试<br>  第四轮：上线</p><h3 id="24-对于需求变更你是怎么做的"><a href="#24-对于需求变更你是怎么做的" class="headerlink" title="24.对于需求变更你是怎么做的"></a>24.对于需求变更你是怎么做的</h3><p>1.评估需求是否合理，和这个版本是否有很大关系，能否放到下个版本。<br>2.评估变更影响范围，回归测试范围，是否需要改变测试方案，评估出测试时间<br>3.结合开发时间评估，给出需求变更总时间，并结合deadline时间交给产品确定是否接受需求变更时间和成本<br>4.通过的话开始详细需求评审，测试用例新增和修改。确定测试方案。并按照正常测试流程介入</p><h3 id="25-团队建设方面你是怎么做的"><a href="#25-团队建设方面你是怎么做的" class="headerlink" title="25.团队建设方面你是怎么做的"></a>25.团队建设方面你是怎么做的</h3><ul><li>1.测试团队制度建设：我觉得好的制度建设有利于绩效考评和工作开展<ul><li>1.每周五测试团队内部周会，每周五邮件形式发送工作周报，总结一周工作下周计划及每周遇到的问题无论是测试问题还是流程问题，一起讨论方案</li><li>2.工作总结。每个版本迭代结束后，测试点，逻辑图，测试用例，sql脚本，项目总结等全部整理归档到confluence</li></ul></li><li>2.奖惩制度<ul><li>1.项目上线后发生重大功能漏测，根据bug等级不同进行相应惩罚</li><li>2.有突出贡献的有奖励</li></ul></li><li>3.技术分享及培训<ul><li>1.每2~3周会进行一场分享，可以是技术分享，业务分享，也可以是大家一起进行阅读，时间在1小时。比如极客时间的软件测试52讲一起阅读</li></ul></li><li>4.设立okr和绩效考核<ul><li>团队成员根据自己情况设立okr.会定期对okr进行面谈。绩效考核也以okr的实现情况来评级</li></ul></li></ul><h3 id="26-如何管理测试团队"><a href="#26-如何管理测试团队" class="headerlink" title="26.如何管理测试团队"></a>26.如何管理测试团队</h3><ul><li>1.建立监控机制<ul><li>工作周报 月度总结 年度总结</li></ul></li><li>2.建立考核制度</li><li>3.建立培训机制和评审机制</li><li>4.技术文档库及交流社区平台建设</li></ul><h3 id="27-怎么教会测试团队成员从0到1运用postman-接口测试用例脚本编写"><a href="#27-怎么教会测试团队成员从0到1运用postman-接口测试用例脚本编写" class="headerlink" title="27.怎么教会测试团队成员从0到1运用postman,接口测试用例脚本编写"></a>27.怎么教会测试团队成员从0到1运用postman,接口测试用例脚本编写</h3><ul><li>1.提前找postman相关视频发给团队成员观看并要求记笔记</li><li>2.编写postman使用培训文档，接口测试用例编写原则并结合公司接口来现场讲解如何使用postman测试接口</li><li>3.接口测试用例组内互相review。</li><li>4.在前期练手项目中，慢慢接入。前2~3个项目只要求覆盖主流程，熟练后慢慢覆盖到所以接口，并且要求前期接口测试过程中必须有bug提交<br>关于接口测试脚本：</li><li>1.编写接口测试脚本培训文档。讲解当前的接口框架每个模块的作用，编写单接口测试用例 关联接口测试用例步骤，测试数据的编写规范比如入参格式。</li><li>2.以公司项目接口为例进行现场讲解。</li><li>3.先选取项目试点 2~3个版本积少成多，慢慢推广</li></ul>]]></content>
    
    
    <categories>
      
      <category>AutoTest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AutoTest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GIT学习</title>
    <link href="/2021/02/17/CICD/GIT%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/02/17/CICD/GIT%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h3><ul><li>Git是目前世界上最先进的分布式版本控制系统（没有之一），用于敏捷高效地处理任何或小或大的项目</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持Git 是什么？</li><li>Git是目前世界上最先进的分布式版本控制系统（没有之一），用于敏捷高效地处理任何或小或大的项目</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持<br>版本库是集中存放在中央服务器的<br>而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活<br>干完活了，再把自己的活推送给中央服务器<br>中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆</li></ul><p>缺点<br>集中式版本控制系统最大的毛病就是必须联网才能工作<br>如果在局域网内还好，带宽够大，速度够快<br>可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，体验极其不好</p>]]></content>
    
    
    <categories>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CICD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包和装饰器</title>
    <link href="/2021/02/17/python/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2021/02/17/python/%E9%97%AD%E5%8C%85%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="闭包和装饰器"><a href="#闭包和装饰器" class="headerlink" title="闭包和装饰器"></a>闭包和装饰器</h1><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包的概念：</p><p> 一个完整的闭包须满足以下三个条件</p><ul><li>1.函数中嵌套一个函数</li><li>2.外层函数返回内层函数的函数名</li><li>3.内层函数对外部作用域有一个非全局变量的引用(不能引用全部变量)保持封闭状态。</li></ul><p>闭包函数调用:返回的不仅仅是个函数，这个函数还有一个封闭的外部作用域</p><p>闭包的作用就是锁定数据 保持数据安全</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">不是闭包<br>a = <span class="hljs-number">100</span><br>def func():<br>  a = <span class="hljs-number">100</span><br>  def <span class="hljs-keyword">wrapper</span>():<br>    print(a*<span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br></code></pre></td></tr></table></figure> <figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs leaf"> 是闭包<br> def func(num):<br>    <br>    def count_book():<br>        print(num)<br>    return count_book<br><span class="hljs-punctuation">#</span>第一种调用<br>func(30)()<br><span class="hljs-punctuation">#</span>第二种调用<br>res = func(30)<br>res()<br>print(res.__closure__) <span class="hljs-punctuation">#</span>储存的是30，num是countbook引用的非全局变量<br><br><span class="hljs-punctuation">#</span><span class="hljs-params">(<span class="hljs-operator">&lt;</span><span class="hljs-variable">cell</span> <span class="hljs-variable">at</span> 0<span class="hljs-variable">x0000023EB08BC888</span>: <span class="hljs-keyword">in</span><span class="hljs-variable">t</span> <span class="hljs-variable">object</span> <span class="hljs-variable">at</span> 0<span class="hljs-variable">x00007FF88902B6F0</span><span class="hljs-operator">&gt;</span>,)</span><br>__closure__储存函数引用的非全局变量在这个属性里，可以实现数据的锁定提高数据的安全性<br></code></pre></td></tr></table></figure><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><h3 id="开放封闭原则"><a href="#开放封闭原则" class="headerlink" title="开放封闭原则"></a>开放封闭原则</h3><h5 id="开放：对代码功能的扩展是开放的"><a href="#开放：对代码功能的扩展是开放的" class="headerlink" title="开放：对代码功能的扩展是开放的"></a>开放：对代码功能的扩展是开放的</h5><h5 id="封闭：对已经实现的功能代码修改是封闭的"><a href="#封闭：对已经实现的功能代码修改是封闭的" class="headerlink" title="封闭：对已经实现的功能代码修改是封闭的"></a>封闭：对已经实现的功能代码修改是封闭的</h5><p>装饰器是对开放封闭原则的一种体现</p><p>装饰器的作用：在不修改功能代码的同时，给代码扩展新的功能</p><p>@是装饰器的语法 @ddt @data @classmethod</p><p>装饰器原理</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def docaretor(f):<br>    def <span class="hljs-keyword">wrapper</span>():<br>        print(<span class="hljs-string">&#x27;新增的功能：自动化测试&#x27;</span>)<br>        # 调用原功能函数<br>        f()<br>        # print(f)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br><br>@docaretor  # @docaretor 的作用等同于后面那一行代码==&gt;  func = docaretor(func)<br>def func():<br>    print(<span class="hljs-string">&#x27;功能函数原有的代码一：敲代码&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;功能函数原有的代码二：写作业&#x27;</span>)<br><br>func()<br></code></pre></td></tr></table></figure><h3 id="装饰器的应用场景"><a href="#装饰器的应用场景" class="headerlink" title="装饰器的应用场景"></a>装饰器的应用场景</h3><p>1.登录验证</p><p>2.函数运行时间统计</p><p>3.执行函数之前做准备工作</p><p>4.执行函数后清理功能</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">def login(func):<br>    def <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span>:<br>        username = <span class="hljs-string">&quot;ss&quot;</span><br>        passwd = <span class="hljs-string">&quot;abc123&quot;</span><br>        user = input(<span class="hljs-string">&quot;请输入用户名&quot;</span>)<br>        psw = input(<span class="hljs-string">&quot;请输入密码&quot;</span>)<br>        <span class="hljs-keyword">if</span> username == user and passwd == psw:<br>            func()<br>        <span class="hljs-keyword">else</span>:<br>            print(<span class="hljs-string">&quot;用户名或密码错误&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">fun</span></span><br><br><br><span class="hljs-meta">@login</span>      #<span class="hljs-meta">@login</span>:语法糖----index=login(index)即index=<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">index</span><span class="hljs-params">()</span></span>=<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br>def index():<br>    print(<span class="hljs-string">&quot;这是一个网站首页&quot;</span>)<br><br>index()   #即调用<span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h3 id="装饰器装饰带参数的函数"><a href="#装饰器装饰带参数的函数" class="headerlink" title="装饰器装饰带参数的函数"></a>装饰器装饰带参数的函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">func</span>): <span class="hljs-comment">#func用来接收被装饰的函数的</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complex</span>(<span class="hljs-params">a,b</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两数相乘的结果为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a*b))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两数相除的结果为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a/b))<br>        func(a,b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span><br><br><br><span class="hljs-meta">@count                </span><span class="hljs-comment">#add_num=count(add_num) add_num(2,4)=complex(2,4)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_num</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两数相加的结果为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a+b))<br><br>add_num(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure><h3 id="函数装饰器装饰类"><a href="#函数装饰器装饰类" class="headerlink" title="函数装饰器装饰类"></a>函数装饰器装饰类</h3><p>装饰器来装饰类的话return必须写 否则会返回None<br>装饰函数的话可以不写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#用函数装饰器装饰类</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complex</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是一个登陆功能&quot;</span>)<br>        <span class="hljs-keyword">return</span> func(*args,**kwargs)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span><br><br><span class="hljs-meta">@count  </span><span class="hljs-comment">#Myclass=count(Myclass)即Myclass=complex Myclass()=complex()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,name,age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self,location</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;在&#123;&#125;读书&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-variable language_">self</span>.name,location))<br><br>m = Myclass(<span class="hljs-string">&#x27;musen&#x27;</span>,<span class="hljs-number">18</span>)<br><span class="hljs-built_in">print</span>(m)<br>m.read(<span class="hljs-string">&quot;上海&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;姓名：&#123;&#125;，年龄：&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(m.name,m.age))<br><br></code></pre></td></tr></table></figure><h3 id="通过装饰器传参"><a href="#通过装饰器传参" class="headerlink" title="通过装饰器传参"></a>通过装饰器传参</h3> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>def musen(<span class="hljs-type">name</span>, age):<br>    def doc(func):<br>        &quot;&quot;&quot;<br>        :param func: 接收被装饰的函数的<br>        :return:<br>        &quot;&quot;&quot;<br>        def <span class="hljs-keyword">wrapper</span>(*args, **kwargs):<br>            print(<span class="hljs-string">&#x27;装饰器扩展的功能代码&#x27;</span>)<br>            print(&quot;装饰器传递的参数name：&quot;, <span class="hljs-type">name</span>)<br>            print(&quot;装饰器传递的参数age：&quot;, age)<br>            # 调用原功能函数<br>            func(*args, **kwargs)<br>            print(<span class="hljs-string">&#x27;----------执行完毕-----------&#x27;</span>)<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br>    <span class="hljs-keyword">return</span> doc<br><br><br>@musen(<span class="hljs-string">&#x27;python27&#x27;</span>, <span class="hljs-number">18</span>)  # ===&gt;  <span class="hljs-keyword">work</span> = musen(<span class="hljs-string">&#x27;python&#x27;</span>)(<span class="hljs-keyword">work</span>)<br>def <span class="hljs-keyword">work</span>(a, b):<br>    print(&quot;a+b:&quot;, a + b)<br><br><br><span class="hljs-keyword">work</span>(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>)<br><br></code></pre></td></tr></table></figure><h3 id="一个函数被多个装饰器装饰-哪个离得近先执行哪个"><a href="#一个函数被多个装饰器装饰-哪个离得近先执行哪个" class="headerlink" title="一个函数被多个装饰器装饰  哪个离得近先执行哪个"></a>一个函数被多个装饰器装饰  哪个离得近先执行哪个</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>def doc(func):<br>    &quot;&quot;&quot;<br>    :param func: 接收被装饰的函数的<br>    :return:<br>    &quot;&quot;&quot;<br><br>    def <span class="hljs-keyword">wrapper</span>(*args, **kwargs):<br>        print(<span class="hljs-string">&#x27;------2-----&#x27;</span>)<br>        print(<span class="hljs-string">&#x27;装饰器doc扩展的功能代码&#x27;</span>)<br>        # 调用原功能函数<br>        func(*args, **kwargs)<br>        print(<span class="hljs-string">&#x27;----------执行完毕--4---------&#x27;</span>)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br><br>def count_time(func):<br>    &quot;&quot;&quot;<br>    :param func: 接收被装饰的函数的<br>    :return:<br>    &quot;&quot;&quot;<br><br>    def <span class="hljs-keyword">wrapper</span>(*args, **kwargs):<br>        # 函数调用之前获取一下当前的实际：start_time<br>        start_time = <span class="hljs-type">time</span>.time()<br>        print(<span class="hljs-string">&#x27;-------1----------&#x27;</span>)<br>        # 调用原功能函数<br>        func(*args, **kwargs)<br>        # 函数调用之后：再获取一下当前时间 end_time<br>        end_time = <span class="hljs-type">time</span>.time()<br>        print(<span class="hljs-string">&#x27;-----------5-------&#x27;</span>)<br>        print(<span class="hljs-string">&#x27;函数运行的时间为：&#x27;</span>, end_time - start_time)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br><br>@count_time  # <span class="hljs-keyword">work</span> = count_time(<span class="hljs-keyword">work</span>)<br>@doc  # <span class="hljs-keyword">work</span> = doc(<span class="hljs-keyword">work</span>)<br>def <span class="hljs-keyword">work</span>(a, b):<br>    print(<span class="hljs-string">&#x27;----3-------&#x27;</span>)<br>    print(&quot;a+b:&quot;, a + b)<br><br><br><span class="hljs-keyword">work</span>(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>)<br><br>==============运行结果=================<br><br><span class="hljs-comment">-------1----------</span><br><span class="hljs-comment">------2-----</span><br>装饰器doc扩展的功能代码<br><span class="hljs-comment">----3-------</span><br>a+b: <span class="hljs-number">33</span><br><span class="hljs-comment">----------执行完毕--4---------</span><br><span class="hljs-comment">-----------5-------</span><br>函数运行的时间为： <span class="hljs-number">5.3882598876953125e-05</span><br><br></code></pre></td></tr></table></figure><h3 id="通过类去实现装饰器"><a href="#通过类去实现装饰器" class="headerlink" title="通过类去实现装饰器"></a>通过类去实现装饰器</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ruby">python中的魔术方法 __开头 __结尾的方法叫做魔术方法<br>不需要手动去调用，都是在特定的情况下自动执行的<br><br>__call__ 可以让对象像函数一样调用（对象加括号去调用的时候会触发）<br>__init__ 类创建对象的时候会被触发<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decorate</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, func</span>):<br>        <span class="hljs-variable language_">self</span>.func = func<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__call__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, *args, **kwargs</span>):<br>        print(<span class="hljs-string">&quot;装饰器添加的功能代码一&quot;</span>)<br>        <span class="hljs-variable language_">self</span>.func()<br>        print(<span class="hljs-string">&quot;装饰器添加的功能代码二&quot;</span>)<br><br><br><span class="hljs-comment"># res = Decorate(11)</span><br><br><span class="hljs-variable">@Decorate</span>  <span class="hljs-comment"># func = Decorate(func)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    print(<span class="hljs-string">&quot;原功能函数&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="python中内置的装饰器"><a href="#python中内置的装饰器" class="headerlink" title="python中内置的装饰器"></a>python中内置的装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">cls</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;类方法&quot;</span>)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">func01</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;静态方法&quot;</span>)<br><br><span class="hljs-meta">    @property  </span><span class="hljs-comment"># 将类里面的一个方法当成属性来使用，像属性一样被访问</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;只读属性&#x27;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;7890&#x27;</span><br><br><br>MyTest.func()<br><br>MyTest.func01()<br><br>m = MyTest()<br>res = m.name<br><br><span class="hljs-built_in">print</span>(res)<br><br></code></pre></td></tr></table></figure><h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">count</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complex</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        func(*args,**kwargs)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">complex</span><br><br><br><span class="hljs-meta">@count                </span><span class="hljs-comment">#add_num=count(add_num)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_num</span>(<span class="hljs-params">a,b</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;两数相加的结果为：&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a+b))<br><br><span class="hljs-meta">@count          </span><span class="hljs-comment">#index=count(index)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是一个首页&quot;</span>)<br>    <br><span class="hljs-meta">@count          </span><span class="hljs-comment">#index=count(index)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是一个首页&quot;</span>)<br>add_num(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br>index()<br></code></pre></td></tr></table></figure><h3 id="缓存装饰器-优化递归实现斐波拉契数列"><a href="#缓存装饰器-优化递归实现斐波拉契数列" class="headerlink" title="缓存装饰器 优化递归实现斐波拉契数列"></a>缓存装饰器 优化递归实现斐波拉契数列</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go">from functools <span class="hljs-keyword">import</span> lru_cache<br><br><br>@lru_cache(maxsize=<span class="hljs-number">128</span>)<br>def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n)</span></span>:<br>    <span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    elif n == <span class="hljs-number">1</span> or n == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        res = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n - 1)</span></span> + <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n - 2)</span></span><br>        <span class="hljs-keyword">return</span> res<br><br><br>res = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(500)</span></span><br><br><span class="hljs-built_in">print</span>(res)<br></code></pre></td></tr></table></figure><h3 id="装饰器案例"><a href="#装饰器案例" class="headerlink" title="装饰器案例"></a>装饰器案例</h3><ul><li>1.计算函数运行时间 <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> def count_time(func):<br>    &quot;&quot;&quot;<br>    :param func: 接收被装饰的函数的<br>    :return:<br>    &quot;&quot;&quot;<br><br>    def <span class="hljs-keyword">wrapper</span>(*args, **kwargs):<br>        # 函数调用之前获取一下当前的实际：start_time<br>        start_time = <span class="hljs-type">time</span>.time()<br>        # 调用原功能函数<br>        func(*args, **kwargs)<br>        # 函数调用之后：再获取一下当前时间 end_time<br>        end_time = <span class="hljs-type">time</span>.time()<br>        print(<span class="hljs-string">&#x27;函数运行的时间为：&#x27;</span>, end_time - start_time)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br><br><br>@count_time<br>def <span class="hljs-keyword">work</span>():<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-type">time</span>.sleep(<span class="hljs-number">1</span>)<br><br><br>@count_time<br>def number2(a, b):<br>    print(&quot;a+b的结果：&quot;, a + b)<br><br><br># <span class="hljs-keyword">work</span>()<br><br>number2(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure></li><li>2.编写装饰器，为多个函数加上认证的功能（用户的账号密码来源于文件），要求登录成功一次，后续的函数都无需再输入用户名和密码</li></ul> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    users = <span class="hljs-built_in">eval</span>(f.read())<br><br><span class="hljs-comment">##判断token是否为false 当为false while not false =while true 执行下面代码 因为token为false进入登陆叶敏</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">login_check</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    登陆验证的装饰器</span><br><span class="hljs-string">    :param func: type:functions</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">ado</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> users[<span class="hljs-string">&#x27;token&#x27;</span>]:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--------登陆页面--------&quot;</span>)<br>            username = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;账号：&quot;</span>)<br>            pwd =<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;密码：&quot;</span>)<br>            <span class="hljs-comment">#登陆校验</span><br>            <span class="hljs-keyword">if</span> users[<span class="hljs-string">&quot;username&quot;</span>] == username <span class="hljs-keyword">and</span> users[<span class="hljs-string">&quot;pwd&quot;</span>] == pwd:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登陆成功&quot;</span>)<br>                users[<span class="hljs-string">&quot;token&quot;</span>] = <span class="hljs-literal">True</span><br>                func()<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;登陆用户名或密码错误，请重新输入：&quot;</span>)<br><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            func(*args,**kwargs)  <span class="hljs-comment">#token值为true直接调用函数</span><br><br>    <span class="hljs-keyword">return</span> ado<br><br><span class="hljs-meta">@login_check</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>(): <span class="hljs-comment">#index=ado(index)</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是商城首页&quot;</span>)<br><br><span class="hljs-meta">@login_check</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">good_list</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这是商品列表第&#123;&#125;页&quot;</span>.<span class="hljs-built_in">format</span>(num))<br><br><br>index()<br>good_list(<span class="hljs-number">4</span>)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试用例设计</title>
    <link href="/2020/10/18/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/10/18/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h2><p>软件测试需求分析</p><h2 id="1-什么是软件测试需求？"><a href="#1-什么是软件测试需求？" class="headerlink" title="1.什么是软件测试需求？"></a>1.什么是软件测试需求？</h2><p>测试需求就是明确在项目中要测试什么。<br>我们在测试活动中，首先要明确测试需求（what),才能决定怎么测（how)什么时候测（when)需要多少人（who)测试的环境是什么（where),测试中需要的技能，工具以及相应的背景知识，测试中可能遇到的风险等等。</p><h2 id="2-软目件需求分析的的"><a href="#2-软目件需求分析的的" class="headerlink" title="2.软目件需求分析的的"></a>2.软目件需求分析的的</h2><p>测试需求分析的主要目的“获取测试点，根据测试点来编写测试用例</p><ul><li>1.把不直观的需求—–转变为直观的需求（用例图&#x2F;活动图 flow图）<ul><li>a.使得测试范围可以度量（有多少功能，有多少功能项）度量测试范围（规定测试范围）</li><li>b.使得独立的功能点对应的所 有处理分支可以度量 度量独立功能点的功能处理分支（细化独立功能点的功能范围）</li><li>c.使得该系统需要测试的业务场景可以度量    度量业务场景（各种各样的流程图也是各种业务场景）</li></ul></li><li>2.把不明确的需求转变为可度量的需求明确其功能点的输入，处理和输出结果（明确输入—-输出的结果）</li></ul><h2 id="3-如何对软件测试需求分析"><a href="#3-如何对软件测试需求分析" class="headerlink" title="3.如何对软件测试需求分析"></a>3.如何对软件测试需求分析</h2><p>需求分析和测试需求分析的区别?  先需求分析(产品经理）——-测试需求分析（测试人员）</p><p>需求分析：初步设想（客户需求）-需求分析-需求规格：输入，处理和输出（先得到原始需求，由产品经理进行需求分析，然后输出需求规格说明书）</p><p>测试需求分析：单个功能点输入处理输出——-业务流程分析——-全局–（整个系统）——隐式需求挖掘（UI，性能，安全，应用性等)</p><h2 id="4-测试需求分析"><a href="#4-测试需求分析" class="headerlink" title="4.测试需求分析"></a>4.测试需求分析</h2><ul><li>通过分析需求描述中的输入，输出，处理，限制，约束等给出对应的验证内容：（功能测试）</li><li>通过分析各个功能模块之间的业务顺序，和接口之间信息和数据的传递，对存在功能交互的功能项，给出对应的验证内容（功能交互性测试，握手）</li><li>考虑到需求的完整性，要充分考虑隐性需求的验证，比如界面的验证，注册账号的唯一性（界面，易用性，兼容性，安全性，性能）</li><li>根据场景法和错误分析法补充测试案例</li></ul><h4 id="测试点分析步骤："><a href="#测试点分析步骤：" class="headerlink" title="测试点分析步骤："></a>测试点分析步骤：</h4><ul><li>1.正常功能：核心最基本的功能</li><li>2.功能验证：规则：按顺序从上至下，对每一个输入项进行验证</li><li>3.功能交互验证</li><li>4.隐性需求<br>充分熟悉产品业务，挖掘隐性需求。（UI，兼容，性能，安全，易用）</li></ul><h2 id="5-需求的变更"><a href="#5-需求的变更" class="headerlink" title="5.需求的变更"></a>5.需求的变更</h2><p>对于一个存在生命周期的软件产品来说，软件的开发和测试往往都不是一次性的，因为随着新的需求出现，以及对原有版本的改进，新的版本会不断的发布。<br>  我们都面临一个点实际问题：就是软件需求在开发过程中会不断发生变化，有时候到了后期还会有新的需求加进来，或者是发版以后发现原来的需求存在缺陷，之后重新返工，那么我们该如何在最终发布之前，确定需求呢？</p><p>如此我们就必须要考虑软件需求的版本化控制。当要进行一个新版本的迭代时，我们在工作开始之前就确认好本次需求的范围：如实出现需求变更，则根据市场策略，已公布的发布时间，客户需求，实现的代价，难易程度以及对现有工作影响等方面考虑，对需求进行适度划分，严格定义当前版本需要实现的功能，而其他的部分，则作为未来版本的需求<br>总之遵循一个原则，对一个版本的需求版更，必须早发现，早讨论，早决定，早调整。</p><h4 id="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"><a href="#以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。" class="headerlink" title="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"></a>以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。</h4><p>桌子<br>功能度：桌子能不能放东西。<br>安全性：打造桌子所用的木料有没有毒或者腐烂污染<br>可靠性：杯子从不同高度落下的损坏程度<br>可移植性：桌子在不同的地方、温度等环境下是否都可以正常使用<br>兼容性：桌子能否作为饭桌，书桌，游戏桌子使用。<br>易用性：桌子是否平滑不拉手、桌角是否打磨平整，桌子的高度设置是否符合人体工学标准、是否方便办公<br>用户文档：使用手册是否对桌子的用法、限制、使用条件等有详细描述<br>疲劳测试：将桌子放上100kg重物放24小时检查桌子表面的情况<br>压力测试：在桌子上面不断加重物，看压力多大时桌子会倾斜  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试需求分析</title>
    <link href="/2020/09/17/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <url>/2020/09/17/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h2><p>软件测试需求分析</p><h2 id="1-什么是软件测试需求？"><a href="#1-什么是软件测试需求？" class="headerlink" title="1.什么是软件测试需求？"></a>1.什么是软件测试需求？</h2><p>测试需求就是明确在项目中要测试什么。<br>我们在测试活动中，首先要明确测试需求（what),才能决定怎么测（how)什么时候测（when)需要多少人（who)测试的环境是什么（where),测试中需要的技能，工具以及相应的背景知识，测试中可能遇到的风险等等。</p><h2 id="2-软目件需求分析的的"><a href="#2-软目件需求分析的的" class="headerlink" title="2.软目件需求分析的的"></a>2.软目件需求分析的的</h2><p>测试需求分析的主要目的“获取测试点，根据测试点来编写测试用例</p><ul><li>1.把不直观的需求—–转变为直观的需求（用例图&#x2F;活动图 flow图）<ul><li>a.使得测试范围可以度量（有多少功能，有多少功能项）度量测试范围（规定测试范围）</li><li>b.使得独立的功能点对应的所 有处理分支可以度量 度量独立功能点的功能处理分支（细化独立功能点的功能范围）</li><li>c.使得该系统需要测试的业务场景可以度量    度量业务场景（各种各样的流程图也是各种业务场景）</li></ul></li><li>2.把不明确的需求转变为可度量的需求明确其功能点的输入，处理和输出结果（明确输入—-输出的结果）</li></ul><h2 id="3-如何对软件测试需求分析"><a href="#3-如何对软件测试需求分析" class="headerlink" title="3.如何对软件测试需求分析"></a>3.如何对软件测试需求分析</h2><p>需求分析和测试需求分析的区别?  先需求分析(产品经理）——-测试需求分析（测试人员）</p><p>需求分析：初步设想（客户需求）-需求分析-需求规格：输入，处理和输出（先得到原始需求，由产品经理进行需求分析，然后输出需求规格说明书）</p><p>测试需求分析：单个功能点输入处理输出——-业务流程分析——-全局–（整个系统）——隐式需求挖掘（UI，性能，安全，应用性等)</p><h2 id="4-测试需求分析"><a href="#4-测试需求分析" class="headerlink" title="4.测试需求分析"></a>4.测试需求分析</h2><ul><li>通过分析需求描述中的输入，输出，处理，限制，约束等给出对应的验证内容：（功能测试）</li><li>通过分析各个功能模块之间的业务顺序，和接口之间信息和数据的传递，对存在功能交互的功能项，给出对应的验证内容（功能交互性测试，握手）</li><li>考虑到需求的完整性，要充分考虑隐性需求的验证，比如界面的验证，注册账号的唯一性（界面，易用性，兼容性，安全性，性能）</li><li>根据场景法和错误分析法补充测试案例</li></ul><h4 id="测试点分析步骤："><a href="#测试点分析步骤：" class="headerlink" title="测试点分析步骤："></a>测试点分析步骤：</h4><ul><li>1.正常功能：核心最基本的功能</li><li>2.功能验证：规则：按顺序从上至下，对每一个输入项进行验证</li><li>3.功能交互验证</li><li>4.隐性需求<br>充分熟悉产品业务，挖掘隐性需求。（UI，兼容，性能，安全，易用）</li></ul><h2 id="5-需求的变更"><a href="#5-需求的变更" class="headerlink" title="5.需求的变更"></a>5.需求的变更</h2><p>对于一个存在生命周期的软件产品来说，软件的开发和测试往往都不是一次性的，因为随着新的需求出现，以及对原有版本的改进，新的版本会不断的发布。<br>  我们都面临一个点实际问题：就是软件需求在开发过程中会不断发生变化，有时候到了后期还会有新的需求加进来，或者是发版以后发现原来的需求存在缺陷，之后重新返工，那么我们该如何在最终发布之前，确定需求呢？</p><p>如此我们就必须要考虑软件需求的版本化控制。当要进行一个新版本的迭代时，我们在工作开始之前就确认好本次需求的范围：如实出现需求变更，则根据市场策略，已公布的发布时间，客户需求，实现的代价，难易程度以及对现有工作影响等方面考虑，对需求进行适度划分，严格定义当前版本需要实现的功能，而其他的部分，则作为未来版本的需求<br>总之遵循一个原则，对一个版本的需求版更，必须早发现，早讨论，早决定，早调整。</p><h4 id="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"><a href="#以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。" class="headerlink" title="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"></a>以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。</h4><p>桌子<br>功能度：桌子能不能放东西。<br>安全性：打造桌子所用的木料有没有毒或者腐烂污染<br>可靠性：杯子从不同高度落下的损坏程度<br>可移植性：桌子在不同的地方、温度等环境下是否都可以正常使用<br>兼容性：桌子能否作为饭桌，书桌，游戏桌子使用。<br>易用性：桌子是否平滑不拉手、桌角是否打磨平整，桌子的高度设置是否符合人体工学标准、是否方便办公<br>用户文档：使用手册是否对桌子的用法、限制、使用条件等有详细描述<br>疲劳测试：将桌子放上100kg重物放24小时检查桌子表面的情况<br>压力测试：在桌子上面不断加重物，看压力多大时桌子会倾斜  </p>]]></content>
    
    
    <categories>
      
      <category>测试基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux</title>
    <link href="/2020/07/17/testbasic/linux/"/>
    <url>/2020/07/17/testbasic/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h1><h2 id="web基础架构"><a href="#web基础架构" class="headerlink" title="web基础架构"></a>web基础架构</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_15-31-59.png"></p><h2 id="内外网区别"><a href="#内外网区别" class="headerlink" title="内外网区别"></a>内外网区别</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-09_15-32-28.png"><br>内网又被称为局域网或私网<br>外网又称为广域网或者公网</p><p>我们平时说的上网都是访问的外网<br>一个公司内部的所有电脑连接起来构成了一个局域网<br>如果你的项目是部署了在局域网，其他公司的电脑肯定访问不了你的项目网站<br>如果你的项目是发布到了外网，你不管是谁都可以访问到你的项目网站  </p><h2 id="计算机网络七层模型-OSI"><a href="#计算机网络七层模型-OSI" class="headerlink" title="计算机网络七层模型-OSI"></a>计算机网络七层模型-OSI</h2><p>（Please DO NOT TEll Stupid People Anything)<br>七层模型也成为OSI参考模型，它是由七层构成的一个体系标准，实现了计算机之间的通讯互联</p><ul><li>Physical(Layer1)  物理层：中继器，集线器，网线，HUB</li><li>Data LInk(Layer2)   数据链路层：网卡，网桥，交换机</li><li>Network(Layer3)     网络层：路由器，防火墙，多层交换机</li><li>Transport(Layer4)   传输层：进程和端口</li><li>Sension(Layer5)      会话层：建立会话，sension认证，断点续传</li><li>Presentation(Layer6) 表示层：编码方式，图像调节码，URL字段传输码</li><li>Application(Layer7)应用层：应用程序，如FTP,SMTP,HTTP<br>电子信号传输和硬件接口数据发送时，从第7层到1层，接受时相反</li></ul><h2 id="常见网络协议"><a href="#常见网络协议" class="headerlink" title="常见网络协议"></a>常见网络协议</h2><ul><li>HTTP协议（超文本传输协议）</li><li>SOAP协议（web service接口）（简单对象访问协议）</li><li>TCP协议（传输控制协议）udp协议（用户数据报协议）<br>TCP协议和UDP协议的区别是TCP协议是可靠的传输协议，因为需要建立连接了才能传输数据，而UDP协议不是。</li></ul><p>TCP协议建立连接握手3次，断开连接握手4次</p><h2 id="防火墙的概念"><a href="#防火墙的概念" class="headerlink" title="防火墙的概念"></a>防火墙的概念</h2><p>所谓防火墙，是指一种将内部网和公众访问网（如Internet)分开的方法，他实际上是一种隔离技术，保护内部网免受非法用户的侵入，它是一种位于内部网络与外部网络之间的网络安全系统，一项信息安全的防护系统，依照特定的规则，允许或是限制传输的数据通过如</p><h3 id="防火墙的基本特征"><a href="#防火墙的基本特征" class="headerlink" title="防火墙的基本特征"></a>防火墙的基本特征</h3><p>内部网络和外部网络之间的所有网络数据流都必须经过防火墙<br>只有符合安全策略的数据流才能通过防火墙<br>防火墙自身应具有非常强的抗打击免疫力</p><p>6.DHCP<br>动态主机配置协议（DYnamic Host Configuration Protocal)动态的分配IP地址，所以虚拟的ip地址会一直变化。</p><p>7.DNS<br>域名（网址）解析服务器，通过你的域名来进行解析，找到你的服务器ip地址</p><h2 id="Xshell-xftp"><a href="#Xshell-xftp" class="headerlink" title="Xshell xftp"></a>Xshell xftp</h2><h4 id="xshell与xftp"><a href="#xshell与xftp" class="headerlink" title="xshell与xftp"></a>xshell与xftp</h4><ul><li>xshell是一个客户端软件，用来连接Linux系统的主机，并通过其命令行界面操作Linux</li><li>xftp是一款文件传输软件，可以将本地window上的软件传输到LInux上<br>获取虚拟机ip地址的命令：ifconfig<br>如果shell连接页面显示的为乱码，则需要把默认语言改为unicode(UT-8)</li></ul><h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><h4 id="LINUX简介：Linux是一套免费试用，支持多用户，多任务，多线程，多CPU的操作系统。很多大型，中型甚至巨型项目都在使用Linux"><a href="#LINUX简介：Linux是一套免费试用，支持多用户，多任务，多线程，多CPU的操作系统。很多大型，中型甚至巨型项目都在使用Linux" class="headerlink" title="LINUX简介：Linux是一套免费试用，支持多用户，多任务，多线程，多CPU的操作系统。很多大型，中型甚至巨型项目都在使用Linux."></a>LINUX简介：Linux是一套免费试用，支持多用户，多任务，多线程，多CPU的操作系统。很多大型，中型甚至巨型项目都在使用Linux.</h4><h4 id="Linux发行版：Linux的发行版说简单点就是将LInux与应用软件做一个打包，目前市面上比较知名的发行版有：Ubuntu-Redhat"><a href="#Linux发行版：Linux的发行版说简单点就是将LInux与应用软件做一个打包，目前市面上比较知名的发行版有：Ubuntu-Redhat" class="headerlink" title="Linux发行版：Linux的发行版说简单点就是将LInux与应用软件做一个打包，目前市面上比较知名的发行版有：Ubuntu,Redhat."></a>Linux发行版：Linux的发行版说简单点就是将LInux与应用软件做一个打包，目前市面上比较知名的发行版有：Ubuntu,Redhat.</h4><p>Centos(cimmunity enterprise operating system)等等。</p><h4 id="Linux入门须知"><a href="#Linux入门须知" class="headerlink" title="Linux入门须知"></a>Linux入门须知</h4><ul><li>Linux(Linux命令）是以严格区分大小写，没有特别的说明保持小写。</li><li>Linux所有的内容都是以文件的形式保存，不靠扩展名来区分文件类型，（带扩展名的也可以看到文件名的一部分）</li><li>常识：顶级目录 根目录（最上层）</li><li>命令之间是有空格的，不要像英文字母一样全部挤在一起</li><li>错误提示：command not found</li><li>命令没找到第一反应应该是去检查命令是不是写错了</li></ul><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><ul><li>Ctrl+c 结束当前正在运行的程序</li><li>Tab: 使用，自动关联，快速补齐</li><li>方向键“上”“下”对历史命令，上一个下一个进行查找，移动光标</li><li>方向键“左”“右”移动光标</li><li>Ctrl+L:清屏</li></ul><h2 id="系统管理相关命令"><a href="#系统管理相关命令" class="headerlink" title="系统管理相关命令"></a>系统管理相关命令</h2><ul><li>su:在不退出登录的情况下，切换到另一个用户的身份<br>  #超级用户提示符<br> ￥普通用户提示符  </li><li>hostname:查看主机名</li><li>who:查询登录到系统的用户</li><li>whoami:确认自己的身份</li><li>history:查看运行命令的历史</li><li>ifconfig:显示或设置网络设备的命令，我们可以用这个命令查看自己虚拟机的历史</li><li>ping:ping是windows，Unix,Linux系统下的一个命令，ping也属于一个通信协议，是TCP&#x2F;IP协议的一部分。利用ping命令可以检查网络是否联通</li><li>kill：杀死进程（kii-9进程号，强制杀死进程）</li><li>date:显示日期 修改时间date-s时间或日期</li></ul><p>虚拟机一般不关机，直接点电源-挂起虚拟机（相当于window睡眠）<br>右键点击虚拟机-管理-克隆虚拟机（不用重复安装）<br>邮件点击虚拟机——快照（保存当前虚拟机状态）  </p><h2 id="目录操作命令："><a href="#目录操作命令：" class="headerlink" title="目录操作命令："></a>目录操作命令：</h2><p>Linux文件系统是采用层级式的树状目录结构，在此结构的最上层是根目录：&#x2F;，下层是各种各样的子目录和文件。</p><ul><li><p>linux内核版本：uname -a</p></li><li><p>linux发行版本：cat &#x2F;etc&#x2F;issue</p></li><li><p>系统内存： free -m</p></li><li><p>硬盘信息： df -h</p></li><li><p>sda表示一块硬盘 sdb表示两块硬盘 sda1 表示一块硬盘的的一个分区  sda2表示一块硬盘的第二个分区</p></li><li><p>&#x2F;  linux 文件系统的上层根目录</p></li><li><p>root 存放root用户的相关文件</p></li><li><p>home  存放普通用户的相关文件</p></li><li><p>bin       存放常用命令的目录，如vi,su,普通命令可以读取的任务</p></li><li><p>pwd命令：显示当前路径</p></li><li><p>cd命令：切换目录 用法：cd切换目录    </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span>../或者<span class="hljs-built_in">cd</span> ..切换到上层目录    <br><span class="hljs-built_in">cd</span> /切换到根目录<br><span class="hljs-built_in">cd</span> ~或只有<span class="hljs-built_in">cd</span>切换到用户主目录（home底下以用户名命名的文件夹）<br>/    root 目录<br><span class="hljs-built_in">cd</span>/opt  <span class="hljs-built_in">cd</span>/bin与 <span class="hljs-built_in">cd</span> /bin的区别：<span class="hljs-built_in">cd</span> /bin从根目录去找bin目录   <span class="hljs-built_in">cd</span> bin从当前(opt)目录去找bin目录<br></code></pre></td></tr></table></figure></li><li><p>mkdir创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> 目录名（创建中文目录时要把语言改为UTF-8否则会乱码）<br><span class="hljs-built_in">mkdir</span> -p创建不存在的目录（p为parents ,<span class="hljs-built_in">mkdir</span> /test/a.txt<br></code></pre></td></tr></table></figure></li><li><p>rmdir 删除空目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rmdir</span> 目录名(删除空目录）<br><span class="hljs-built_in">rm</span> -rf 目录名（-rf强制删除的意思,删除非空目录）<br><span class="hljs-built_in">touch</span> 创建文件 <span class="hljs-built_in">touch</span> a.txt<br><span class="hljs-built_in">cat</span>     查看文件内容<br></code></pre></td></tr></table></figure></li><li><p>vi:是linux下常用的，功能强大的文本编辑器</p><ul><li>调用方法：vi a.txt(如果a.txt不存在，则创建，保存退出则创建成功）</li><li>按键盘i进入编辑状态（主机：键盘输入都是英文输入法下进行输入）</li><li>退出编辑按ESC键，退出方法：</li><li>不保存退出   :q！</li><li>保存退出       :wq</li><li>输入&#x2F;,进入搜索，输入你需要搜索的文字，按ENTER（必须按esc退出编辑模式后操作）</li><li>按键盘G,直接定位到最末行（必须按esc退出编辑模式后操作）</li><li>按键盘g直接定位到首行 （必须按esc退出编辑模式后操作）</li></ul></li></ul><p>在linux系统中，几乎所有的内容包括文档，命令，设备和目录等都组织成文件的格式，用文件来管理，常用的文件管理命令有：<br>ll 或ls -1查看文件&#x2F;目录，以及他们对应的属性信息</p><ul><li><p>cp复制命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">用法：cp <span class="hljs-selector-attr">[选项]</span>文件名或目录 目标地址  cp <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span>  <span class="hljs-selector-tag">b</span><br>     -<span class="hljs-attribute">R</span>拷贝目录及目录下所有的目录和文件  拷贝目录时用<br>     cp <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span> 将<span class="hljs-selector-tag">a</span>文件复制，且另命名为<span class="hljs-selector-tag">b</span>文件<br></code></pre></td></tr></table></figure></li><li><p>mv 移动命令finfo 用法： mv文件名或目录，目标位置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">mv <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> ../       将a文件移动到上级目录（将一个文件移动到另一个目录没有重命名）<br>mv <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span>  ../<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span> 将a文件移动到上一级并改名为b文件（将一个文件移动到另一个目录并重命名）<br><br>移动目录的时候，如果出现覆盖的情况，且被覆盖的目录非空，需要加一个<span class="hljs-string">&#x27;-b&#x27;</span>的参数才能移动成功，被覆盖的目录此时会生产一个备份。<br>mv -<span class="hljs-selector-tag">b</span> test nuonuozhou<br></code></pre></td></tr></table></figure></li><li><p>rm:删除文件或目录（i:操作时进行询问）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-f强制删除文件</span><br><span class="hljs-deletion">-r删除目录</span><br></code></pre></td></tr></table></figure></li><li><p>find:查找文件 用法：find【路径】【选项】</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">常用选项有：find . -name <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> 在当前目录查找<span class="hljs-selector-tag">a</span>.txt文件<br>find    /  -name <span class="hljs-selector-tag">a</span>.txt从根目录查找<span class="hljs-selector-tag">a</span>.txt文件<br>find  /user/local/  -name <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span>  <br></code></pre></td></tr></table></figure></li><li><p>grep命令</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">功能：在指定文件中查找字符（串）并打印该行,过滤经常跟着管道符一起出现<br>用法：<span class="hljs-keyword">grep</span> 字符串 文件名<br>     <span class="hljs-keyword">grep</span> xyz <span class="hljs-keyword">file</span> 在<span class="hljs-keyword">file</span>文件中找寻band字符串所在的那一行。<br></code></pre></td></tr></table></figure></li><li><p>cat: 显示文本文件内容<br>用法：cat 文件名 cat 文件名字</p></li><li><p>head 查看前几行<br> 用法：head-n 5 文件名</p></li><li><p>tail 从指定点开始将文件写到标准输出<br> 使用tail命令的-f选项可以方便的查阅正在改变的日志文件<br> tail -n 5文件名 查看后几行<br> tail -f error .log 不断刷新，看到最新内容</p></li></ul><h2 id="系统资源查询命令"><a href="#系统资源查询命令" class="headerlink" title="系统资源查询命令"></a>系统资源查询命令</h2><ul><li><p>ps 查看进程（动态）  </p><ul><li>ef 显示所有运行进程，并显示启动进程的命令  </li><li>Uid 用户ID  </li><li>PID :进程ID  </li><li>PPID:父进程  </li><li>C:进程CPU占用率</li><li>Stime:进程从启动到现在的时间， TTY:终端号 CMD:命令名称和参数</li></ul></li><li><p>netstat 查看网络状况（net status的简写）</p><ul><li>netstat -apn查看所有端口</li><li>an, 按一定顺序排列输出</li><li>p, 表示显示哪个进程在调用</li></ul></li></ul><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><ul><li>管道使用“|”符号，并且在命令之间建立管道，将前面的命令的输出作为后面命令的输入  </li><li>如ll |grep abc,管道前面的命令显示当前目录下的文件，后面从列出的文件名中寻找还有abc字符串的文件或者目录</li></ul><h3 id="工作常用情况：杀死服务进程（比如杀死tomcat进程的）"><a href="#工作常用情况：杀死服务进程（比如杀死tomcat进程的）" class="headerlink" title="工作常用情况：杀死服务进程（比如杀死tomcat进程的）"></a>工作常用情况：杀死服务进程（比如杀死tomcat进程的）</h3><h4 id="通过进程名找到进程，再杀死进程"><a href="#通过进程名找到进程，再杀死进程" class="headerlink" title="通过进程名找到进程，再杀死进程"></a>通过进程名找到进程，再杀死进程</h4><ul><li>2.通过命令查找tomcat进程： ps -ef |grep tomcat (ps -ef是查找所有运行的进程，通过管道符找到所有进程中包含了“tomcat”字符串的进程，即为tomcat进程）假如：5541</li><li>3.杀掉此进程，kill -9 进程Id (kill -9 5541)</li></ul><h4 id="通过端口来找到进程，在杀死进程"><a href="#通过端口来找到进程，在杀死进程" class="headerlink" title="通过端口来找到进程，在杀死进程"></a>通过端口来找到进程，在杀死进程</h4><ul><li>1.通过命令查找到占用此端口的进程编号：netstat -apn |grep 8080 根据8080查进程，假如5541</li><li>2.杀掉进程：kill -9 pid (kill -9 5541)</li></ul><h4 id="权限赋予命令chmod"><a href="#权限赋予命令chmod" class="headerlink" title="权限赋予命令chmod"></a>权限赋予命令chmod</h4><p>linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限，为了保护系统的安全性，linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。在linux中我们可以使用||或者ls -l命令来显示一个文件的属性以及文件所属的用户和组</p><ul><li>chmod语法：chmod [-R]xyz文件或目录</li><li>读（r) 4    写（w) :2   执行（x):1</li><li>chmod 332 test.sh    最高权限777，相加</li><li>chmod 777  -R xxx 所有文件子文件权限全部改掉，不加-R只能改最外层</li></ul><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><ul><li>将文件压缩成tar.gz&#x2F;.tar格式用tar命令，使用-z调用gzip,</li><li>如：将test压缩成test.tar.gz tar   -czvf   test.tar.gz  test    </li><li>将.tar.gz&#x2F;.tar格式解压： 如：将test.tar.gz解压得到test文件夹 tar -xzvf  test.tar.gz</li></ul><h5 id="命令参数详解"><a href="#命令参数详解" class="headerlink" title="命令参数详解"></a>命令参数详解</h5><ul><li>c建立归档</li><li>x解归档</li><li>z有gzip属性的压缩文件</li><li>v显示所有过程</li><li>f使用档案名字，必填项，是最后一个参数，文件名</li></ul><h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><ul><li>将test文件压缩成test.zip,使用-r把文件压缩进去，否则生成一个空文件夹 zip -r test.zip  test</li><li>将zip格式的压缩文件解压使用unzip命令 例如：将test.zip文件夹解压 unzip test.zip失效</li><li>关闭防火墙命令<br>即时生效 重启后<ul><li>开启：service iptables start</li><li>关闭：service iptables stop</li></ul></li><li>永久关闭防火墙<ul><li>开启：chkconfig iptables on</li><li>关闭 ：chkconfig iptables off</li></ul></li></ul><h2 id="重启关闭退出登录命令"><a href="#重启关闭退出登录命令" class="headerlink" title="重启关闭退出登录命令"></a>重启关闭退出登录命令</h2><ul><li>重启命令：reboot</li><li>其他：shutdown -r now</li><li>关机命令：halt</li><li>其他：shutdown -h now<br>poweroff</li><li>注销：logout</li></ul><h3 id="用-shell脚本运行helloworld"><a href="#用-shell脚本运行helloworld" class="headerlink" title="用 shell脚本运行helloworld"></a>用 shell脚本运行helloworld</h3><ul><li>#!&#x2F;bin&#x2F;sh是指此脚本使用&#x2F;bin&#x2F;sh来解释执行，</li><li>#!是特殊的表示符，其后面根的是此解释此脚本的shell的路径。</li><li>其实第一句的#!是对脚本的解释器程序路径，脚本的内容是由解释器解释的，我们可以用各种各样的解释器来写对应的脚本。</li><li>比如说&#x2F;bin&#x2F;csh脚本，&#x2F;bin&#x2F;perl脚本，&#x2F;bin&#x2F;awk脚本，&#x2F;bin&#x2F;sed脚本，甚至&#x2F;bin&#x2F;echo等等。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash同理。</span><br>vim helloworld.shn<br><span class="hljs-comment">#!/bin/sh</span><br><span class="hljs-built_in">echo</span><span class="hljs-string">&quot;helloworld&quot;</span><br>退出保存<br>./helloworld.sh运行 如果不能运行 先进行授权 chomod 744 helloworld.sh<br></code></pre></td></tr></table></figure></li></ul><h5 id="echo-将后面的字符串输出到标准输出终端-stdout"><a href="#echo-将后面的字符串输出到标准输出终端-stdout" class="headerlink" title="echo 将后面的字符串输出到标准输出终端(stdout)"></a>echo 将后面的字符串输出到标准输出终端(stdout)</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"> vi helloworld.java<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">helloworld</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> <span class="hljs-keyword">args</span>[]</span>)</span>&#123;<br>                 system.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;helloworld!!&quot;</span>);<br>                 &#125;<br>&#125;<br>javac helloworld.java  编译 <br>java hellworld执行<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试准备</title>
    <link href="/2020/06/17/interview/README/"/>
    <url>/2020/06/17/interview/README/</url>
    
    <content type="html"><![CDATA[<h3 id="2-怎么从0到1设计自动化测试流程的？"><a href="#2-怎么从0到1设计自动化测试流程的？" class="headerlink" title="2.怎么从0到1设计自动化测试流程的？"></a>2.怎么从0到1设计自动化测试流程的？</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs clean">背景：<br>   - <span class="hljs-number">1.</span>开发没有持续维护接口文档<br>   - <span class="hljs-number">2.</span>接口测试没有做，没有做过自动化测试，提测后直接进入功能测试。<br>  <br> <span class="hljs-number">1.</span>引入swagger接口文档工具 第二 编写了自动化测试流程介入现有研发流程 流程图，接口测试前移放到和开发阶段同步进行并且编写自动化测试脚本脚本 。<br>前期准备工作：<br>#### <span class="hljs-number">1.</span>技术团队开了自动化项目启动会议<br><span class="hljs-number">1.</span>在会上我用ppt讲解了自动化测试是什么 自动化测试的价值，以及展示了自动化脚本的运行 测试报告的生成和展示。<br>#### <span class="hljs-number">2.</span>搭建了swagger接口文档平台 <br>编写了swagger部署和集成文档，接口文档注释添加规则文档， 接口自动化测试介入开发流程文档，评估了开发接入和学习成本  <br>在swagger宣讲会上了做了介绍和讨论。<br>#### <span class="hljs-number">3.</span>自动化测试框架的搭建<br><br>测试流程<br><span class="hljs-number">1.</span> <span class="hljs-number">2.</span> <span class="hljs-number">3.</span><br>#### <span class="hljs-number">4.</span>项目试点落地实施<br>选了三个迭代版本进行试点 循序渐进，前两个版本仅要求他们做了主流程接口文档的维护<br>我们按照接口自动化测试介入现有研发流程图来进行开发和测试之间的磨合。<br>开发出接口时会进行一轮接口测试，开发也会及时维护接口文档。 <br>三个版本后推广到了当前所以的迭代项目  <br><br>#### <span class="hljs-number">5.</span>扫尾工作<br><span class="hljs-number">1.</span>历史接口注释添加 这个主要是开发团队的任务由我来主导，和各个开发leader对接，自己预估给出排期我负责check进度和质量。<br>三个月左右我们的历史接口注释添加完毕<br><br><span class="hljs-number">2.</span>测试这块后期进行了接口测试用例设计，测试脚本编写方面的培训。<br>当前我们测试团队成员均会先进行接口测试并编写调试接口脚本。<br><br>在整个过程中流程的制定主要是和领导还有开发leader一起  <br>接口平台的搭建是和运维一起搭的   <br>swagger的部署和接入这块是和架构师一起做的。<br></code></pre></td></tr></table></figure><h3 id="3-从中有没有遇到过阻力你认为最大的困难是什么？"><a href="#3-从中有没有遇到过阻力你认为最大的困难是什么？" class="headerlink" title="3.从中有没有遇到过阻力你认为最大的困难是什么？"></a>3.从中有没有遇到过阻力你认为最大的困难是什么？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">最大的困难还是团队之间拥有同一目标，统一认知，拥抱变化愿意改变既有习惯和模式<br>首先我觉得最最重要是领导的支持，这是推进落地必不可少的条件，第二是自己的坚持和强大的内心。<br><br><br>比如接口测试文档，之前开发团队并没有及时维护，现在推进swagger接口文档有些开发觉得额外增加了工作量，一开始有抵触情绪。  <br>我们前期也有一定的心里预期也做了一些工作来避免这些。<br><br><span class="hljs-bullet">- </span>1.开了说明会 告诉他们接入的好处，对项目质量的好处对开发团队的好处。评估了开发学习成本和学习时间。直观告诉这个东西很快可以搞定。 <br><span class="hljs-bullet">- </span>2.各系统如何接入swagger，接口注释如何添加全部编写了说明文档。并且在会议上做了演示和讲解。<br><span class="hljs-bullet">- </span>3.并没有立马大规模推广，进行了试点和磨合，循序渐进的来推进<br></code></pre></td></tr></table></figure><h3 id="4-从中你学到了什么？"><a href="#4-从中你学到了什么？" class="headerlink" title="4.从中你学到了什么？"></a>4.从中你学到了什么？</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>1.首先善于观察和思考项目流程中的痛点并且思考解决方案<br><span class="hljs-bullet">- </span>2.善于借力，多和架构师运维合作，共同完成一些技术推进工作<br><span class="hljs-bullet">- </span>3.拥有强大的内心很重要，并且领导也很重要，要多争取领导的支持和站台<br></code></pre></td></tr></table></figure><h4 id="5-介绍一个接口自动化框架"><a href="#5-介绍一个接口自动化框架" class="headerlink" title="5.介绍一个接口自动化框架"></a>5.介绍一个接口自动化框架</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">接口自动化是采用python+ddt+unittest <br>excel存储测试用例，ddt数据驱动读取测试用例拆包传到unittest 测试类中运行。.<br>主要设计思想 <br>第一：测试数据和测试用例分离，测试账号存储在配置文件，测试用例存储在excel，减少维护成本，提高用例可用性<br>第二：ddt 测试数据和测试代码分离，通过ddt读取数据来驱动测试用例批量执行。保证测试数据发生大量变化的情况下，测试代码可以不用改变<br><br>测试用例层：datas：excel测试数据存储。以模块为单位 一个模块一个<span class="hljs-keyword">sheet页</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">          cases:</span> 测试用例 一个模块一个文件，读取excel对应<span class="hljs-keyword">sheet页的测试用例批量发起请求并断言</span><br><span class="hljs-keyword"></span><span class="hljs-symbol">          conf:</span>配置文件 主要负责接口<span class="hljs-keyword">base地址 </span>账号信息 数据库连接信息存储<br>逻辑处理层：handle excel<br>        handle mysql<br>        handle <span class="hljs-built_in">config</span><br>        handle log<br><span class="hljs-symbol">        context:</span>处理关联接口的测试用例<br>输出层：logs 运行日志输出<br>       reports 测试用例输出<br><br>第三方模块：htmlrunner生成测试报告<br><span class="hljs-symbol">main:</span>执行主入口模块<br>持续集成：<br>集成了<span class="hljs-keyword">jenkis拉取git代码运行 </span>生成测试报告发送测试邮件并且集成了钉钉@相关联系人进行测试报告分析和查看<br><span class="hljs-keyword">jenkis上配置了三个任务 </span>分别拉取对应git分支的代码执行。<br>测试环境 验证环境 生产环境维护了<span class="hljs-number">3</span>套代码，逻辑是一样的，主要是测试账号 请求url配置信息的不同 <br><br>执行策略：<br>生产环境是每次上线发布后执行<br>验证环境 配置的定时时间每天运行<br>测试环境 也是每次执行冒烟测试时自行运行<br><br>稳定性方面<span class="hljs-comment">;主要是加入了重运行机制。</span><br><br></code></pre></td></tr></table></figure><h3 id="6-介绍一下UI自动化框架"><a href="#6-介绍一下UI自动化框架" class="headerlink" title="6.介绍一下UI自动化框架"></a>6.介绍一下UI自动化框架</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">数据分离 测试数据和测试用例分离<br>PO设计模式 测试对象和测试用例分离 一般分为三层 1.页面维度的元素定位 2，页面维度的元素操作 3.测试用例<br>用例当中看不到元素定位和操作<br>测试用例层：<br>逻辑处理层<br>输出层<br></code></pre></td></tr></table></figure><h3 id="7-为什么选择-现在的python-ddt-unittest接口框架"><a href="#7-为什么选择-现在的python-ddt-unittest接口框架" class="headerlink" title="7.为什么选择 现在的python+ddt+unittest接口框架"></a>7.为什么选择 现在的python+ddt+unittest接口框架</h3><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d">本人比较熟悉python <span class="hljs-keyword">unittest</span>框架<br>如果现在的话，根据团队成员的不同水平，如果全员均不会写脚本的话，会采用httprunner为主。<br></code></pre></td></tr></table></figure><h3 id="8-怎么排查bug"><a href="#8-怎么排查bug" class="headerlink" title="8.怎么排查bug"></a>8.怎么排查bug</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>1.如果直接出现报错查看报错日志。也可以通过skywalking查看哪个系统挂掉了<br><span class="hljs-bullet">- </span>2.看一下是否和后端有交互，如果没有就是一个前端的bug.如果有先查看前端传参是否正确，前端传参正确，一般就是后端的问题，去数据库按照查询条件捞数据，查看是否后端sql脚本问题，逻辑处理的问题。<br></code></pre></td></tr></table></figure><h3 id="9-找一个业务说明一下系统之间的调用关系和技术实现"><a href="#9-找一个业务说明一下系统之间的调用关系和技术实现" class="headerlink" title="9.找一个业务说明一下系统之间的调用关系和技术实现"></a>9.找一个业务说明一下系统之间的调用关系和技术实现</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs">1.学员端有一个线上课程打卡功能<br>业务逻辑是这样：学员在学员端点击线上课程跳转到第三方鲸打卡小程序。完成打卡操作后，鲸打卡会把打卡信息 比如用户手机号，得分 推送回我们。我们会在进行后续的添加积分操作<br><br>当前在学员端的操作查询学员线上课程信息等级信息积分信息调用student系统。后续积分操作会调用crm系统进行学员积分添加。<br>关于技术实现：  <br>我们当前学员端在鲸打卡小程序的打卡操作一般集中在晚上。打卡时间比较集中，会在一个时间段内把打卡信息推送过来，<br>此时我们放在mq消息队列中，业务系统慢慢去消费处理。如果mq在消费消息中出现异常，mq会有重试机制 一直重试<br><br>银联对账机制：<br>在销售端创建银联订单推送银联，订单同步失败后，会重新推送不断调银联接口。<br><br>我们的合同创建过程信息比较多分为4步每一次点击下一步会跳到一个新的页面，且在每一步都有可能直接关闭，<br>前面创建过程使用了redis缓存机制。等到第四步确认提交后数据统一落库。<br></code></pre></td></tr></table></figure><h3 id="10-讲解一下功能测试用例设计-选取一个你们公司的场景"><a href="#10-讲解一下功能测试用例设计-选取一个你们公司的场景" class="headerlink" title="10.讲解一下功能测试用例设计 选取一个你们公司的场景"></a>10.讲解一下功能测试用例设计 选取一个你们公司的场景</h3><p>背景：<br>1.创建银联订单：</p><h3 id="11选取一个接口-比如订单接口-讲解一下接口测试用例设计"><a href="#11选取一个接口-比如订单接口-讲解一下接口测试用例设计" class="headerlink" title="11选取一个接口 比如订单接口 讲解一下接口测试用例设计"></a>11选取一个接口 比如订单接口 讲解一下接口测试用例设计</h3><ul><li>1.输入可根据参数类型进行设计<ul><li>a 必填项校验 </li><li>b 参数长度校验  超长字符未进行处理，会导致存储显示等异常</li><li>c 参数值的有效性校验 比如身份证号手机号 </li><li>d 参数是枚举值，各种枚举值都要测试，每一种枚举值就代表一种测试场景</li><li>f 参数的默认值，边界值，特殊字符，空字符等。</li><li>e 唯一性校验 有些字段必须唯一不能重复 比如姓名或者身份证号</li></ul></li><li>2.接口处理可按照逻辑进行用例设计，接口逻辑结合实际的业务场景逻辑复杂先画业务流程图或xmind写测试点 要做到场景覆盖。<ul><li>a 约束条件 比如实物为有限状态才能赠送。学员有课时才能参加活动</li><li>b 状态限制 比如我们的系统大部分状态下都需要登录状态且权限正确才能操作</li><li>c 数值限制 比如学员升级接口。如果学员课时不足无法扣课时则不能进行升级</li><li>d 顺序分析 一些接口是有调用顺序的，比如打乱顺序调用是否会报错</li><li>场景覆盖时考虑异常场景，比如我们的创建订单并同步银行接口。同步失败或者接口超时后，是否有正常业务提示。</li><li>重复提交（幂等）比如我们的核销扣课时接口，只能扣一次如果短时间内多次点击的话，要看开发是否有做处理 如唯一字段唯一索引，重复插入数据报错</li></ul></li></ul><h3 id="12-接口测试用例返回值校验怎么校验？"><a href="#12-接口测试用例返回值校验怎么校验？" class="headerlink" title="12.接口测试用例返回值校验怎么校验？"></a>12.接口测试用例返回值校验怎么校验？</h3><p>针对输出 可根据结果进行分析设计</p><ul><li>a 校验返回值 code msg</li><li>b 了解数据库通过sql脚本去验证</li></ul><h3 id="13-讲解一下你的接口测试平台"><a href="#13-讲解一下你的接口测试平台" class="headerlink" title="13.讲解一下你的接口测试平台"></a>13.讲解一下你的接口测试平台</h3><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-19_21-04-03.png"></p><h3 id="14-django的生命周期"><a href="#14-django的生命周期" class="headerlink" title="14.django的生命周期"></a>14.django的生命周期</h3><p>前端请求—&gt;nginx—&gt;uwsgi.—&gt;中间件—&gt;url路由—-&gt;view试图—&gt;orm—-&gt;拿到数据返回给view—-&gt;试图将数据渲染到模版中拿到字符串—-&gt;中间件—&gt;uwsgi—-&gt;nginx—-&gt;前端渲染。</p><h3 id="15-django中间件"><a href="#15-django中间件" class="headerlink" title="15.django中间件"></a>15.django中间件</h3><p>中间件是 Django 用来处理请求和响应的钩子框架，配置文件settings.py的 MIDDLEWARE 配置项列表中</p><h3 id="16-选取一个模块介绍一下你们公司的业务"><a href="#16-选取一个模块介绍一下你们公司的业务" class="headerlink" title="16.选取一个模块介绍一下你们公司的业务"></a>16.选取一个模块介绍一下你们公司的业务</h3><h3 id="17-介绍一下公司一个功能模块的测试用例设计"><a href="#17-介绍一下公司一个功能模块的测试用例设计" class="headerlink" title="17.介绍一下公司一个功能模块的测试用例设计"></a>17.介绍一下公司一个功能模块的测试用例设计</h3><h3 id="18-性能当前怎么做的，性能测试流程。关键指标"><a href="#18-性能当前怎么做的，性能测试流程。关键指标" class="headerlink" title="18.性能当前怎么做的，性能测试流程。关键指标"></a>18.性能当前怎么做的，性能测试流程。关键指标</h3><h3 id="19-怎么把控测试进度"><a href="#19-怎么把控测试进度" class="headerlink" title="19.怎么把控测试进度"></a>19.怎么把控测试进度</h3><p>1.每月需求碰头会，了解接下来一个月的安排<br>2.执行测试团队人力资源排期表。团队一起来维护。横列是日期</p><ul><li>1.在项目前期制定合理的测试计划，充分考虑测试的风险点，预估充足的测试时间。</li><li>2.关键节点把控 开发提测节点延迟预警，如果延迟要尽快反馈，商量解决方案。和测试人员及时了解测试进度，是否按照预期推进，阻塞流程是否有及时解决。</li><li>3.过程监控，tapd上查看各项目bug趋势，每天新增解决bug，判断当前项目所处阶段，测试人员时间安排</li><li>4.测试日报</li><li>4.如果有需求变更，参照需求变更</li></ul><h3 id="20-怎么把控测试质量"><a href="#20-怎么把控测试质量" class="headerlink" title="20.怎么把控测试质量"></a>20.怎么把控测试质量</h3><ul><li>按照测试分层，最底层做单元测试，    </li><li>中间层，做接口测试，集成测试。  接口测试工作前移和开发一起进行  </li><li>最上层做ui测试，端到端测试，探索性测试。  </li><li>每个测试阶段，投入不同的测试手段。</li></ul><h3 id="21-怎么把控测试覆盖度"><a href="#21-怎么把控测试覆盖度" class="headerlink" title="21.怎么把控测试覆盖度"></a>21.怎么把控测试覆盖度</h3><ul><li>首先接口测试覆盖所有接口，包括后期自动化脚本回归。 </li><li>功能是覆盖所有的需求功能点，用例100%执行，bug全部回归完毕</li></ul><h3 id="22-介绍一下项目重构中遇到的问题以及怎么解决的"><a href="#22-介绍一下项目重构中遇到的问题以及怎么解决的" class="headerlink" title="22.介绍一下项目重构中遇到的问题以及怎么解决的"></a>22.介绍一下项目重构中遇到的问题以及怎么解决的</h3><h3 id="23-重构项目的测试方案"><a href="#23-重构项目的测试方案" class="headerlink" title="23.重构项目的测试方案"></a>23.重构项目的测试方案</h3><p>根据测试计划<br>总得测试方案 1.及早介入 2.先化整为零各个击破，然后再交叉测试<br>1.根据项目需求分析后 我们确认做三轮功能测试，接口自动化测试 和 个别高并发场景做性能压测<br>2.第一轮：接口测试+模块测试+接口主流程冒烟测试脚本编写及第一轮集成测试<br>  第二轮：集成测试关联模块测试+回归测试<br>  第三轮：集成测试交叉测试+迁移数据校验+性能测试<br>  第四轮：上线</p><h3 id="24-对于需求变更你是怎么做的"><a href="#24-对于需求变更你是怎么做的" class="headerlink" title="24.对于需求变更你是怎么做的"></a>24.对于需求变更你是怎么做的</h3><p>1.评估需求是否合理，和这个版本是否有很大关系，能否放到下个版本。<br>2.评估变更影响范围，回归测试范围，是否需要改变测试方案，评估出测试时间<br>3.结合开发时间评估，给出需求变更总时间，并结合deadline时间交给产品确定是否接受需求变更时间和成本<br>4.通过的话开始详细需求评审，测试用例新增和修改。确定测试方案。并按照正常测试流程介入</p><h3 id="25-团队建设方面你是怎么做的"><a href="#25-团队建设方面你是怎么做的" class="headerlink" title="25.团队建设方面你是怎么做的"></a>25.团队建设方面你是怎么做的</h3><ul><li>1.测试团队制度建设：我觉得好的制度建设有利于绩效考评和工作开展<ul><li>1.每周五测试团队内部周会，每周五邮件形式发送工作周报，总结一周工作下周计划及每周遇到的问题无论是测试问题还是流程问题，一起讨论方案</li><li>2.工作总结。每个版本迭代结束后，测试点，逻辑图，测试用例，sql脚本，项目总结等全部整理归档到confluence</li></ul></li><li>2.奖惩制度<ul><li>1.项目上线后发生重大功能漏测，根据bug等级不同进行相应惩罚</li><li>2.有突出贡献的有奖励</li></ul></li><li>3.技术分享及培训<ul><li>1.每2~3周会进行一场分享，可以是技术分享，业务分享，也可以是大家一起进行阅读，时间在1小时。比如极客时间的软件测试52讲一起阅读</li></ul></li><li>4.设立okr和绩效考核<ul><li>团队成员根据自己情况设立okr.会定期对okr进行面谈。绩效考核也以okr的实现情况来评级</li></ul></li></ul><h3 id="26-如何管理测试团队"><a href="#26-如何管理测试团队" class="headerlink" title="26.如何管理测试团队"></a>26.如何管理测试团队</h3><ul><li>1.建立监控机制<ul><li>工作周报 月度总结 年度总结</li></ul></li><li>2.建立考核制度</li><li>3.建立培训机制和评审机制</li><li>4.技术文档库及交流社区平台建设</li></ul><h3 id="27-怎么教会测试团队成员从0到1运用postman-接口测试用例脚本编写"><a href="#27-怎么教会测试团队成员从0到1运用postman-接口测试用例脚本编写" class="headerlink" title="27.怎么教会测试团队成员从0到1运用postman,接口测试用例脚本编写"></a>27.怎么教会测试团队成员从0到1运用postman,接口测试用例脚本编写</h3><ul><li>1.提前找postman相关视频发给团队成员观看并要求记笔记</li><li>2.编写postman使用培训文档，接口测试用例编写原则并结合公司接口来现场讲解如何使用postman测试接口</li><li>3.接口测试用例组内互相review。</li><li>4.在前期练手项目中，慢慢接入。前2~3个项目只要求覆盖主流程，熟练后慢慢覆盖到所以接口，并且要求前期接口测试过程中必须有bug提交<br>关于接口测试脚本：</li><li>1.编写接口测试脚本培训文档。讲解当前的接口框架每个模块的作用，编写单接口测试用例 关联接口测试用例步骤，测试数据的编写规范比如入参格式。</li><li>2.以公司项目接口为例进行现场讲解。</li><li>3.先选取项目试点 2~3个版本积少成多，慢慢推广</li></ul>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件生命周期</title>
    <link href="/2020/06/17/testbasic/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/06/17/testbasic/%E8%BD%AF%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="软件的生命周期-软件测试工作流程"><a href="#软件的生命周期-软件测试工作流程" class="headerlink" title="软件的生命周期&amp;软件测试工作流程"></a>软件的生命周期&amp;软件测试工作流程</h1><p>小知识</p><ul><li>C&#x2F;S:client-server：一定要安装一个客户端才能使用的软件 比如qq,微信，爱奇艺，网易云音乐<ul><li>缺点：每次更新都要更新服务端与客户端，比如说超市收银系统每次更新每台电脑必须重装客户   端，特别是有分店的情况，人力物力财力都很大</li></ul></li><li>B&#x2F;S:browser-server:只需要一个浏览器，就可以访问服务的，就是B&#x2F;S。比如火车票出票系统，企业官网，OA系统，爱奇艺，爱奇艺在线直播，qq空间<ul><li>优点：只需要更新服务器就OK，不需要去更新浏览器，用户主动性比较高，比如说天猫，淘宝</li></ul></li></ul><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>软件生命周期（SDLC,System Development Life Cycle,SDLC)是软件从开始立项到最终被废弃不用这个过程叫做软件生命周期，整个生命周期包括问题定义及规划，需求分析，系统设计，软件编程，软件测试，软件维护等阶段</p><h3 id="1970年第一个软件生命周期，瀑布型生命周期"><a href="#1970年第一个软件生命周期，瀑布型生命周期" class="headerlink" title="1970年第一个软件生命周期，瀑布型生命周期"></a>1970年第一个软件生命周期，瀑布型生命周期</h3><ul><li>用户需求—-</li><li>需求分析7%（用户，系统分析员，项目管理员）产生分析报告</li><li>系统设计6%（项目分析员，高级程序员，项目管理员）产生系统设计报告</li><li>软件编程7%（项目管理员，程序员）产生源程序</li><li>软件测试13%（用户，高级程序员，程序员）产生测试报告</li><li>软件维护67%（用户，系统分析员，项目管理员，程序员）更改需求</li><li>需求分析（循环）</li></ul><h4 id="具体每个阶段需要做的事"><a href="#具体每个阶段需要做的事" class="headerlink" title="具体每个阶段需要做的事"></a>具体每个阶段需要做的事</h4><ul><li>一.问题的定义及规划<br>  主要确定软件开发的目的及可行性，制定开发计划</li><li>二.需求分析<br>  在确定软件开发可行的情况下，对软件需要实现的各个功能进项详细分析，明确客户需求，输出需求规格说明书、</li><li>三.软件设计<ul><li>把需求分析得到的结果转换为软件结构和数据结构，形成系统架构</li><li>概要设计：主要是架构的实现</li><li>详细设计：对该要设计中表述的各模块进行深入分析，这一阶段要求达到伪代码级别。</li></ul></li><li>四：软件编码<br>  按照详细设计好的模块功能表，编程人员编写出计算机可运行的程序代码。</li><li>五：软件测试<br>   在软件设计完成后经过严密的测试，以发现整个设计过程中存在的bug并加以解决</li></ul><h4 id="测试的方法主要有白盒测试和黑盒测试两种"><a href="#测试的方法主要有白盒测试和黑盒测试两种" class="headerlink" title="测试的方法主要有白盒测试和黑盒测试两种"></a>测试的方法主要有白盒测试和黑盒测试两种</h4><pre><code class="hljs">- 单元测试：主要是测试程序代码，为的是确保   各单元模块被正确编译，一般是开发来完成- 集成测试：单元测试后，将各单元组合成完整的体系，测试软件之间的接口是否正确，数据能否正确传输。- 系统测试：把软件系统搭建起来，按照软件规格说明书中所要求，测试软件其性能功能等是否和用户需求相符合，在软件中运行是否存在漏洞等- 验收测试：用户对软件进行验收</code></pre><ul><li>六：运行维护<br>  软件的维护包括纠错性维护和改进型维护</li></ul><h2 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h2><p>软件生命周期模型也称为软件过程模型，反映软件生存周期各个阶段的工作如何组织，衔接，常见的生命周期模型：瀑布模型，V模型，螺旋模型，W模型等。</p><h4 id="V模型"><a href="#V模型" class="headerlink" title="V模型"></a>V模型</h4><p>RAD模型是软件开发过程中的一个重要模型，他通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。</p><ul><li>用户需求           验收测试</li><li>需求分析           系统测试（根据需求说明书编写）</li><li>概要设计           集成测试 （根据概要设计中模块功能及接口等实现方法编写）</li><li>详细设计           单元测试（和详细设计一起出来）<br>    - 软件编码</li></ul><h2 id="软件测试基本流程"><a href="#软件测试基本流程" class="headerlink" title="软件测试基本流程"></a>软件测试基本流程</h2><ul><li><p>测试需求分析阶段：主要学习业务，分析需求点</p></li><li><p>计划阶段：编写测试计划，参考软件需求规格说明点，项目总体计划，内容包括测试范围，进度的安排，人力物力的分配，和风险的评估与规避</p></li><li><p>设计阶段：主要是编写测试用例，会参考需求文档，详细设计文档等，又不明确的要及时和开发产品经理沟通，编写后会一起进行评审。</p></li><li><p>执行阶段：如果评审通过，正式进入系统测试，只软件大道测需求的要求，没有重大bug,测试结束</p></li><li><p>评估阶段：输出测试报告，对整个测试的过程和版本质量进行一个详细的评估，确认是否可以上线。</p></li></ul><h4 id="测试工作流程图"><a href="#测试工作流程图" class="headerlink" title="测试工作流程图"></a>测试工作流程图</h4><ul><li><p>测试工作流程：需求分析-需求评审-测试编写测试计划-编写测试用例-用例评审-部署测试环境-冒烟正式测试-提交bug并跟踪（N轮））-测试通过-测试报告-发布上线</p></li><li><p>开发工作流程：需求分析-需求评审-开发编写开发计划-概要设计，详细设计-编写代码并自测-提交测试-修改bug再提交测试（N轮）-测试通过</p></li><li><p>开发环境：编写代码调试的环境</p></li><li><p>测试环境：模拟用户使用的环境</p></li><li><p>生产环境：淘宝，天猫的线上环境真实的环境，面向客户正式使用的环境</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler抓包</title>
    <link href="/2020/06/17/testbasic/Fiddler%E6%8A%93%E5%8C%85/"/>
    <url>/2020/06/17/testbasic/Fiddler%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="fiddler抓包工具"><a href="#fiddler抓包工具" class="headerlink" title="fiddler抓包工具"></a>fiddler抓包工具</h1><h2 id="1-什么是Fiddler，它可以做什么"><a href="#1-什么是Fiddler，它可以做什么" class="headerlink" title="1.什么是Fiddler，它可以做什么"></a>1.什么是Fiddler，它可以做什么</h2><ul><li>Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一。</li><li>Fiddler能够记录客户端和服务器之间的所有http请求，可以针对特定的http请求，分析请求数据，设置断点，调试web应用，修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。</li><li>既然是代理，也就是说客户端的所有请求都要先经过Fiddler,然后转发到相应的服务器，反之服务器的所有响应，也都会先经过Fiddler,然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为：127.0.0.1:8888的浏览器和应用程序</li></ul><p>使用了FIddler后，web客户端和服务器的请求如右图所示：</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-19-14.png"></p><h2 id="本地回路地址"><a href="#本地回路地址" class="headerlink" title="本地回路地址"></a>本地回路地址</h2><p>本地回路地址是指本地回环地址，本地回环地址不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。</p><h4 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h4><p>一般都会用来检查本地网络协议、基本数据接口等是否正常的。<br>主要作用有两个：</p><ul><li>一是测试本机的网络配置，能PING通127.0.0.1说明本机的网卡和IP协议安装都没有问题；</li><li>另一个作用是某些SERVER&#x2F;CLIENT的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，SERVER的IP地址设为127.0.0.1同样也可以运行。</li></ul><p>本地回环地址指的是以127开头的地址（127.0.0.1 - 127.255.255.254），通常用127.0.0.1来表示。</p><h2 id="2-利用Fiddler录制web请求"><a href="#2-利用Fiddler录制web请求" class="headerlink" title="2.利用Fiddler录制web请求"></a>2.利用Fiddler录制web请求</h2><ul><li>1.打开浏览器，设置服务代理器为：127.0.0.1端口为：8888</li><li>2.打开Fiddler,然后打开浏览器，进行目标网站访问</li><li>3.录制请求如下：<br><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-19-37.png"></li></ul><p><a href="http://www.cnblogs.com/chengchengla1990/p/5681775.html">http://www.cnblogs.com/chengchengla1990/p/5681775.html</a>  界面详解<br><a href="http://blog.csdn.net/andrewpj/article/det">http://blog.csdn.net/andrewpj/article/det</a> ails&#x2F;45440097 session请求详解</p><h2 id="3-Fiddler各个组件分析"><a href="#3-Fiddler各个组件分析" class="headerlink" title="3.Fiddler各个组件分析"></a>3.Fiddler各个组件分析</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-33-47.png"></p><h4 id="web-session面板：主要是Fiddler抓取到的每条http请求（每一条称为一个session）"><a href="#web-session面板：主要是Fiddler抓取到的每条http请求（每一条称为一个session）" class="headerlink" title="web session面板：主要是Fiddler抓取到的每条http请求（每一条称为一个session）"></a>web session面板：主要是Fiddler抓取到的每条http请求（每一条称为一个session）</h4><p>主要包含了请求的URL,协议，状态码，body等信息，详细的字段含义如下</p><ul><li><ol><li>http request 的顺序，从1开始，按照页面加载请求的顺序递增</li></ol></li><li><ol start="2"><li>Result   http响应的状态，可以参考这里</li></ol></li><li><ol start="3"><li>protocol：请求使用的协议（如http，https，ftp)</li></ol></li><li><ol start="4"><li>host 请求地址的域名</li></ol></li><li>5.URL：请求的服务器路径和文件名，也包括GET参数</li><li><ol start="6"><li>BODY: 请求的大小，以byte为单位</li></ol></li><li>7.caching:请求的缓存过期时间或缓存控制 header等值</li><li><ol start="8"><li>content-type: 请求响应的类型</li></ol></li><li>9.process 发出此请求的windows进程和进程ID</li><li>10：comments:用户通过脚本或者右键菜单给此session增加的备注</li><li>11.custom: 用户可以通过脚本设置的自定义值</li></ul><h4 id="HTTP状态码（HTTP-Status-Code）是用以表示网页服务器HTTP响应状态的3位数字代码"><a href="#HTTP状态码（HTTP-Status-Code）是用以表示网页服务器HTTP响应状态的3位数字代码" class="headerlink" title="HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码"></a>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码</h4><p>常见的http  code:200  ok 302  move 400 bad request 401 Unauthorized 403Forbidden  404 Not Found 405Method Not Allowed 500 Internal Server Error 服务器内部错误</p><h4 id="如果只想抓取一个网站的包的话"><a href="#如果只想抓取一个网站的包的话" class="headerlink" title="如果只想抓取一个网站的包的话"></a>如果只想抓取一个网站的包的话</h4><p>把fiddler的默认端口8888改掉，改成7777，右边第一个在启动时作为系统代理不打钩<br>后把火狐的端口也改成7777。<br>重启fiddler<br>crtl+x 清除右边session<br>statistic:<br>关于http请求的性能和其他数据分析，我们可以从中看出一些基本性能数据，如DNS解析的时间，建立TCP&#x2F;IP连接的时间消耗等信息</p><h5 id="inspectors"><a href="#inspectors" class="headerlink" title="inspectors"></a>inspectors</h5><ul><li>分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。</li><li>对于每一部分，提供了多种不同格式查看每个请求的响应的内容</li><li>JPG格式使用imageview就可以看到图片</li><li>HTML&#x2F;JS&#x2F;CSS使用textview 可以看到响应的内容</li><li>raw标签可以查看原始的符合http标准的请求和响应头</li><li>cookies标签可以看到请求的cookie和响应的set-cookie头信息</li></ul><h5 id="AutoResponder-调试bug"><a href="#AutoResponder-调试bug" class="headerlink" title="AutoResponder   调试bug"></a>AutoResponder   调试bug</h5><p>Fiddler比较重要且强大的功能之一，可用于拦截某一请求，并重定向到本地资源，或者使用Fiddler的内置响应，可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的的文件或者得到的Fiddler的内置响应。当勾选allow autoresponser并设置相应的规则后，进行使用。因此，如果要调试服务器的某个脚本文件，可以将该脚本拦截到本地，在本地修改完脚本以后，在修改服务器的内容，这样可以保证尽量在真实的环境下去调试，从而最大限度的减少bug发生的可能性。</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-38-23.png"></p><h5 id="Composer-设计者-也可以做接口测试，可以修改数据，从fiddler端发起请求"><a href="#Composer-设计者-也可以做接口测试，可以修改数据，从fiddler端发起请求" class="headerlink" title="Composer  设计者  也可以做接口测试，可以修改数据，从fiddler端发起请求"></a>Composer  设计者  也可以做接口测试，可以修改数据，从fiddler端发起请求</h5><p>Parsed输入请求的url之后，execute即可，也可以修改相应的头信息（如添加常用的accept,host,referrer,cookie,cache-control等头部）后execute<br>把请求信息拖到右边，可以看到具体的请求信息。点击excute可以从fiddler端发起请求代替浏览器端<br>可以绕过前端，去发现前端一些发现不了的bug 提高网站的健壮性，可以判断是前端的文图<br>比如说先登录获取session信息 然后拖住登录login请求拖到composer里，查看webform会以表单形式把用户名和密码列出来,修改密码或用户名点击execute 重新登录查看statis里的提示 可以绕过前端，比如密码输入1个字gaus<br>也可以用来做接口测试</p><h5 id="Filters-相当于数据库里面的where-过滤"><a href="#Filters-相当于数据库里面的where-过滤" class="headerlink" title="Filters  相当于数据库里面的where 过滤"></a>Filters  相当于数据库里面的where 过滤</h5><p>另一个更强大的功能，提供了多维度的过滤规则,足以满足日常开发调试的需求，Fiddler的过滤器非常强大，可以过滤特定http状态码的请求，可以过滤特定请求类型的http请求（如css请求，image请求，js请求等）可以过滤请求报文大于或小于等于指定大小（byte)<br>intrante内网  internet外网</p><h4 id="利用Fiddler设置断点进行调试修改"><a href="#利用Fiddler设置断点进行调试修改" class="headerlink" title="利用Fiddler设置断点进行调试修改"></a>利用Fiddler设置断点进行调试修改</h4><p>1.Fiddler菜单栏-rules-automatic breakpoint选择断点方式<br>before request 也就是发送请求之后，fiddler代理中转之前，这是可以修改请求的数据<br>after request 也就是服务器响应之后，在fiddler将响应中转给客户端之前，这是可以修改响应的结果</p><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>我们都知道HTTP并非是安全传输，在HTTPS基础上使用SSL协议进行加密构成的HTTPS协议是相对安全的。目前越来越多的企业选择使用HTTPS协议与用户进行通信，如百度、谷歌等。HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。<br>一言以弊之，HTTPS是通过一次非对称加密算法（如RSA算法）进行了协商密钥的生成与交换，然后在后续通信过程中就使用协商密钥进行对称加密通信。HTTPS协议传输的原理和过程简图如下所示</p><h2 id="Fiddler抓取HTTPS协议原理"><a href="#Fiddler抓取HTTPS协议原理" class="headerlink" title="Fiddler抓取HTTPS协议原理"></a>Fiddler抓取HTTPS协议原理</h2><p>我们都知道，Fiddler是个很好的代理工具，可抓取协议请求用于调试。关于Fiddler抓取HTTP协议的原理和配置比较简单，对Fiddler和客户端稍作配置，便能使得Fiddler轻易地获取HTTP请求。但是由于HTTPS协议的特殊性，要进一步地配置Fiddler，我们首先要了解一下fiddler抓取HTTPS协议的原理才能更好地理解如何对fiddler进行配置。Fiddler本身就是一个协议代理工具，在上一节HTTPS原理图上，客户端与服务器端进行通信的过程全部都由Fiddler获取到，也就是如下图所示：</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-21-43.png"></p><ul><li>服务器—&gt;客户端：Fiddler接收到服务器发送的密文， 用对称密钥解开， 获得服务器发送的明文。再次加密， 发送给客户端。</li><li>客户端—&gt;服务端：客户端用对称密钥加密，被Fiddler截获后，解密获得明文。再次加密，发送给服务器端。由于Fiddler一直拥有通信用对称密钥enc_key， 所以在整个HTTPS通信过程中信息对其透明。</li></ul><h2 id="Fiddler抓取HTTPS设置"><a href="#Fiddler抓取HTTPS设置" class="headerlink" title="Fiddler抓取HTTPS设置"></a>Fiddler抓取HTTPS设置</h2><p>（一）首先对Fiddler进行设置：打开工具栏-&gt;Tools-&gt;Fiddler Options-&gt;HTTPS</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-22-11.png"></p><p>选中Capture HTTPS CONNECTs，因为我们要用Fiddler获取手机客户端发出的HTTPS请求，所以中间的下拉菜单中选中from remote clients only。选中下方Ignore server certificate errors.</p><h2 id="Fiddler抓包之app抓包"><a href="#Fiddler抓包之app抓包" class="headerlink" title="Fiddler抓包之app抓包"></a>Fiddler抓包之app抓包</h2><h4 id="1-保证电脑和手机连接的是同一个无线网，可以直接用手机测试也可以用模拟器"><a href="#1-保证电脑和手机连接的是同一个无线网，可以直接用手机测试也可以用模拟器" class="headerlink" title="1.保证电脑和手机连接的是同一个无线网，可以直接用手机测试也可以用模拟器"></a>1.保证电脑和手机连接的是同一个无线网，可以直接用手机测试也可以用模拟器</h4><p>抓取http请求</p><h5 id="1-设置手机"><a href="#1-设置手机" class="headerlink" title="1.设置手机"></a>1.设置手机</h5><p>找到手机连接的wif,双击后点击修改网络—将代理改为为手动代理—–</p><ul><li>1）服务器主机名为电脑的ip地址（cmd ipconfig查看）</li><li>2）服务器端口设定为8888，必须为8888固定的 ,</li><li>3）ip为DHCP点击保存</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-22-41.png"></p><h4 id="2-设置Fiddler"><a href="#2-设置Fiddler" class="headerlink" title="2.设置Fiddler"></a>2.设置Fiddler</h4><p>菜单栏点击Tools-Options-Connections  勾选Allow remote computers to connect选项 ，端口改为固定的8888  勾选一下Monitor all connections选项 点击OK</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-55-42.png"></p><h4 id="3-设置完毕后，点击手机端的app-Fidder就会出现请求信息了。"><a href="#3-设置完毕后，点击手机端的app-Fidder就会出现请求信息了。" class="headerlink" title="3.设置完毕后，点击手机端的app,Fidder就会出现请求信息了。"></a>3.设置完毕后，点击手机端的app,Fidder就会出现请求信息了。</h4><h3 id="抓取https请求"><a href="#抓取https请求" class="headerlink" title="抓取https请求"></a>抓取https请求</h3><ul><li>1）Android手机<br>1.设置Fiddler<br>菜单栏点击Tools-Options-HTTPS勾选以下3项</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-22-11.png"></p><p>2.在手机端安装一下证书<br>1.在手机浏览器输入以下网址，中间为电脑的ip地址，注意替换</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-23-58.png"></p><p>2.输入后进入以下画面，点击红线标注部分下载证书</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_13-00-04.png"></p><p>有的安卓手机比如我的华为，点击红线部分下载证书后，网页转到无证书页面。<br>此时可以百度 Fiddler证书安装问题。解决方法如下<br>在电脑运行栏输入cmd  进入后</p><ul><li><ol><li>cd “C:\Program Files (x86)\Fiddler2”      cd后面为Fiddler安装路径 这一步为进入Fiddler</li></ol></li><li><ol start="2"><li>输入  makecert.exe -r -ss my -n “CN&#x3D;DO_NOT_TRUST_FiddlerRoot, O&#x3D;DO_NOT_TRUST, OU&#x3D;Created by <a href="http://www.fiddler2.com/">http://www.fiddler2.com</a>“ -sky signature -eku 1.3.6.1.5.5.7.3.1 -h 1 -cy authority -a sha1 -m 120 -b 09&#x2F;05&#x2F;2012</li></ol></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_13-01-12.png"></p><p>然后在进入手机浏览器输入<a href="http://192.168.1.107:8888/">http://192.168.1.107:8888/</a>  此时就可以下载证书了。<br>如果手机自动安装的话，直接就可以截取https的包了。<br>如果手机不自动安装的话，自己要找到下载路径自己点击安装。<br>如果只想抓取某个app的请求的话</p><ol><li>点击Filters进行设置</li></ol><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-25-05.png"></p><p>粘贴host地址的时候要去掉host:后粘贴到上面框里</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_12-25-24.png"></p>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bug生命周期</title>
    <link href="/2020/05/17/testbasic/bug%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/05/17/testbasic/bug%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="bug的生命周期-bug状态处理"><a href="#bug的生命周期-bug状态处理" class="headerlink" title="bug的生命周期&amp;bug状态处理"></a>bug的生命周期&amp;bug状态处理</h1><h2 id="bug的定义"><a href="#bug的定义" class="headerlink" title="bug的定义"></a>bug的定义</h2><p>软件的bug狭义的是指软件程序的漏洞或缺陷，广义概念除此之外还包括测试工程师或用户发现和提出的软件可改进细节，或与需求文档存在差异的功能实现等。<br>我们的职责就是发现这些bug，提交给开发，让开发去修改</p><h2 id="bug是怎么来的？"><a href="#bug是怎么来的？" class="headerlink" title="bug是怎么来的？"></a>bug是怎么来的？</h2><ul><li>1.缺乏有效沟通</li><li>2.软件的复杂度</li><li>3.编程错误</li><li>4.不断变更的需求</li><li>5.时间的压力</li></ul><h2 id="bug的类型"><a href="#bug的类型" class="headerlink" title="bug的类型"></a>bug的类型</h2><p>要确定一个bug类型，需要对项目（或产品）有比较深的理解，这个划分对开发定位问题影响较小，但对于问题类型的统计就比较重要了。</p><p>常见的bug类型划分：代码错误，界面优化，设计缺陷，配置相关，安装部署，安全相关，性能问题，标准规范，测试脚本，其他。</p><p>其他划分：功能类，界面类 性能类    易用性类 兼容类    其他</p><h2 id="缺陷的等级"><a href="#缺陷的等级" class="headerlink" title="缺陷的等级"></a>缺陷的等级</h2><p>bug的等级一般分为四级，也有分五级的，如果是等级越高，那么对应的优先级也会高一些，然后有些公司还会根据你提的bug数量和bug等级，作为绩效考核的一部分。<br>-（1）致命性错误<br>     1.常规操作引起的系统崩溃，死机，死循环<br>     2.造成数据泄露的安全性问题，比如恶意攻击造成的账户私密信息泄露<br>     3.涉及金钱<br>     4.用户数据受到破坏，或者危及人身安全<br>-（2）严重错误<br>     1.重要功能不能实现<br>     2.错误的波及面广，影响到其他重要功能实现<br>     3.非常规操作导致的程序崩溃，死机，死循环<br>     4.数据不能保存，系统的次要功能完全丧失，系统所提供的功能或服务受到明显影响<br>-（3）一般错误<br>     不影响产品的运行，不能成为故障起因，但对产品外观和下道工序影响较大的缺陷<br>     1.次要功能能不能正常实现<br>     2.操作界面错误（包括数据窗口内列名定义，含义不一致）<br>     3.查询错误，数据错误显示<br>     4.简单的输入限制未放在前台进行控制<br>     5.删除操作未给出提示<br>-（4）细微错误<br>     程序在一些显示上不美观，不符合用户习惯，或者是一些文字的错误<br>     1.界面不规范<br>      2.辅助说明描述不清楚<br>      3.提示窗口文字未采用行业术语<br>     4.界面存在文字性错误<br>优先级分为4级，一般问题越严重，其处理的优先级越高</p><h2 id="bug的生命周期"><a href="#bug的生命周期" class="headerlink" title="bug的生命周期"></a>bug的生命周期</h2><p>就是一个bug被发现到这个bug被关闭的过程。<br>生命周期中的一般缺陷状态：<br>新建——指派——已解决——待验——关闭<br>如果待验的bug在验证时没有解决好，我们需要重新打开（激活）——指派——已解决——待验，循环这个过程。中间状态拒绝——延期等  </p><h2 id="bug处理流程"><a href="#bug处理流程" class="headerlink" title="bug处理流程"></a>bug处理流程</h2><ul><li><p>1.发现bug–提交bug—指派bug—研发确认bug——（否）设计如此无法复现                 </p></li><li><p>2.发现bug–提交bug—指派bug—研发确认bug——-(是）研发是否解决——-（否）不予解决，延期</p></li><li><p>3.发现bug–提交bug—指派bug—研发确认bug——-(是）研发是否解决——-（是）回归验证bug—是否通过验证—–（是） 关闭bug</p></li><li><p>4.发现bug–提交bug—指派bug—研发确认bug——-(是）研发是否解决——-（是）回归验证bug—是否通过验证—–（否） 激活——指派bug~~~~~~~~~~</p></li><li><p>1.激活bug:已经指派给开发的，要关注bug走向，随时跟踪，如果一直未修复，提醒开发修改，如果已经修复等待测试环境更新后进行验证</p></li><li><p>2.已解决bug：等待测试环境更新后进行验证，验证通过则关闭，验证不通过则重新打开指派给开发</p></li><li><p>3.重复bug:先去查看下是否跟开发指定的bug重复？如果确定是重复则庀：如果不重复，说明原因，重新打开指派给开发</p></li><li><p>4.无法重现：确认开发环境是否跟测试环境一致，包括操作步骤，浏览器，特定账号等，如果多个版本验证之后，如果开发说重现不了，依据bug的严重程度跟产品，开发一起确认关闭，如果找到重现原音，注明清楚并在此指派给开发</p></li><li><p>5.不予解决：找产品经理进行确认，确认不予解决进行关闭，确认需要解决请备注原因，并打开指派给开发</p></li><li><p>6.设计如此：找产品经理进行确认，确认设计如此进行关闭，确认是问题，备注原因重新指派给开发</p></li><li><p>7.延期修改：请看下bug严重程度，是否影响当前版本发布，与产品经理确认，不予延期请根据情况进行激活与情况说明，确认延期则做好记录，后续版本进行关注。</p></li></ul><p>面试题：</p><h4 id="有没有你印象深刻的bug"><a href="#有没有你印象深刻的bug" class="headerlink" title="有没有你印象深刻的bug"></a>有没有你印象深刻的bug</h4><p>有很多印象深刻的bug,比如说后台播放 av source时rev on开启back camera后，关闭，重复开启-关闭几次后机器出现重启。</p><h4 id="bug的生命周期-1"><a href="#bug的生命周期-1" class="headerlink" title="bug的生命周期"></a>bug的生命周期</h4><p>新建bug指派给开发–开发已解决—-评价验证bug,修复后—关闭bug</p><h4 id="当你打开了一个bug-但开放不认为是bug-如何处理？"><a href="#当你打开了一个bug-但开放不认为是bug-如何处理？" class="headerlink" title="当你打开了一个bug,但开放不认为是bug,如何处理？"></a>当你打开了一个bug,但开放不认为是bug,如何处理？</h4><p>首先查找需求说明书和式样书，寻找确切的依据，如果是用户体验票，侧从用户的角度来说明为什么是bug,如果开发依然认为不是bug的话，交由产品经理来判定</p><h4 id="对于复现率不高的bug如何处理？你再发现bug并确认bug的过程中"><a href="#对于复现率不高的bug如何处理？你再发现bug并确认bug的过程中" class="headerlink" title="对于复现率不高的bug如何处理？你再发现bug并确认bug的过程中"></a>对于复现率不高的bug如何处理？你再发现bug并确认bug的过程中</h4><p>复现率不高的bug要立马录像，拍照片，截取log,保留现场，直接叫开发来调查问题。<br>如果现场已经被破坏，只能在以后每天的测试中带着再现，把这个问题在测试人员中展开一下，别的测试人员也可以帮忙验证。</p>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APP压力稳定性测试</title>
    <link href="/2020/04/17/testbasic/APP%E5%8E%8B%E5%8A%9B%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95/"/>
    <url>/2020/04/17/testbasic/APP%E5%8E%8B%E5%8A%9B%E7%A8%B3%E5%AE%9A%E6%80%A7%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="APP压力稳定性测试"><a href="#APP压力稳定性测试" class="headerlink" title="APP压力稳定性测试"></a>APP压力稳定性测试</h1><ul><li>1.android系统自带monkey程序，模拟用户触摸屏幕，滑动track ball，按键等操作莱多设备上的程序进行压力测试，检验程序多久的时间会发生异常</li><li>2.adb （android debug bridge)用来连接安卓手机和PC端的桥梁，通过adb服务，在PC端命令行界面面对手机或者模拟器进行全面的操作<br>用手机来操作的话，要用一个数据线连接，打开usb的开发者模式（USB调试），确认连接成功后在cmd命令行输入命令</li><li>3.monkey什么时候用？等而产品稳定了，没有特别多的bug时候，一般用monkey去测试待测试应用的稳定性，健壮性，（是否会发生闪退，崩溃）手机出厂前的整机测试</li></ul><h2 id="adb常见命令"><a href="#adb常见命令" class="headerlink" title="adb常见命令"></a>adb常见命令</h2><ul><li>adb device 检测连接到电脑的安卓设备，这个是我们后期经常会用到</li><li>adb pull &lt;手机全路径&gt;&lt;本机路径&gt;从手机中拉取信息放到本地电脑上</li><li>adb push&lt;本机文件全路径&gt;&lt;手机路径&gt;从本地推动信息到手机上</li><li>adb start-server 当adb出现问题或者adb启动不起来的时候，先kill掉进程然后adb kill-sever 然后输入adb start-server</li><li>adb shell 登录设备shell(命令行的人机画面）ll ls命令都可以用，进入到linux命令环境，相当于执行远程命令</li><li>ctrl+c回到命令行界面</li><li>获取当前正在使用的app包名 adb shell dumpsys activity |find “mFocuseActivity”</li></ul><h2 id="monkey常用命令"><a href="#monkey常用命令" class="headerlink" title="monkey常用命令"></a>monkey常用命令</h2><ul><li>adb shell monkey{+命令参数}次数</li><li>adb shell monkey -help&#x2F;-h</li><li>-v 用于指定反馈信息级别，（信息级别就是日志的详细程度）总共分为3个程度</li><li>-p +包名 用于约束限制，用此参数指定一个或多个包(package，即app名字）</li><li>adb shell monkey  -p com.wandoujia.phoenix2 -v -v -v 100<br>白名单：只运行这个文件里面的包<br>黑名单：这个文件里的包不运行</li></ul><h4 id="如果要运行很多包："><a href="#如果要运行很多包：" class="headerlink" title="如果要运行很多包："></a>如果要运行很多包：</h4><ul><li>先把很多包名放到一个文件.txt  adb push上传到手机上，然后 adb shell monkey -pkg-whitelist-file +安卓手机文件全路径</li><li>-s 用于指定伪随机数生成器的seed值，如果seed值相同，则两次Monkey测试所产生的时间序列也相同，用于问题重现</li><li>adb shell monkey -s  1505730657339(seed值） -v -v -v 100</li><li>throttle &lt;毫秒&gt;用于指定用户操作（即事件）见的时延，单位是毫秒  操作与操作之间的间隔</li><li>adb shell monkey  -p com.wandoujia.phoenix2  – throttle 3000 -v -v -v 100</li><li>randomize-throttle 一定要与throtle绑定出现</li><li>在事件之间插入随机延迟，随即延迟范围为0到throttle设置的时间，单位为毫秒 百分比事件</li><li>adb shell monkey  -p com.wandoujia.phoenix2  -throttle 3000 –randomize-throttle -v -v -v 100</li></ul><h4 id="百分比事件-–pct-touch"><a href="#百分比事件-–pct-touch" class="headerlink" title="百分比事件 –pct -touch"></a>百分比事件 –pct -touch</h4><p>adb shell monkey –pct-touch 70 -v -v -v 100 操作100次点击操作占到了70%</p><h2 id="monkey小知识"><a href="#monkey小知识" class="headerlink" title="monkey小知识"></a>monkey小知识</h2><ul><li>1.查找包名<br>adb shell 进入shell命令行界面<br>cd data&#x2F;data<br>ls<br>把所有包名都罗列出来根据关键词去查找包名</li></ul><h4 id="如何查看前台运行的包名和应用名"><a href="#如何查看前台运行的包名和应用名" class="headerlink" title="如何查看前台运行的包名和应用名"></a>如何查看前台运行的包名和应用名</h4><p>adb shell dumpsys activity | grep “mFocusedActivity”<br>通过工具sdk–&gt; hierarchyviewer.bat</p><h4 id="导出日志到本地"><a href="#导出日志到本地" class="headerlink" title="导出日志到本地"></a>导出日志到本地</h4><p>adb shell monkey {+命令参数}次数&gt;PC本地路径<br>adb shell monkey -v -v -v 1000&gt;d:\monkey.txt</p><h4 id="app客户端性能测试"><a href="#app客户端性能测试" class="headerlink" title="app客户端性能测试"></a>app客户端性能测试</h4><ul><li>测试时间：与功能测试必行</li><li>测试范围：产品的核心功能，用户使用最频繁，与用户交互最多</li><li>检测方向：</li><li>CPU占用</li><li>内存的占用</li><li>流量的耗用</li><li>电量的耗用</li><li>测试工具：GT 可以直接安装到手机。http：&#x2F;&#x2F;gt.qq.com</li><li>Emmgee:<a href="https://github.com/NetEase/Emmgee">https://github.com/NetEase/Emmgee</a></li><li>itest</li><li>弱网测试<br>直接设置路由器限速<br>Network Emulator Toolkit 工具<br>关注：卡死，崩溃 无响应 闪退 业务交互数据的正确性<br><a href="http://blog.csdn.net/no1mwb/article/details/53638681">http://blog.csdn.net/no1mwb/article/details/53638681</a></li></ul><h2 id="兼容性测试"><a href="#兼容性测试" class="headerlink" title="兼容性测试"></a>兼容性测试</h2><ul><li>手工测试：适应市场主流手机</li><li>国内主流云测试平台</li><li>testin云测 <a href="http://www.testin.cn/">http://www.testin.cn/</a></li><li>百度云MTC <a href="http://mtc.baidu.com/">http://mtc.baidu.com</a></li><li>腾讯优测<a href="http://utest.qq.com/">http://utest.qq.com</a></li><li>阿里MQC(<a href="http://mqc.aliyun.com/">http://mqc.aliyun.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>团队日常管理</title>
    <link href="/2020/04/17/manage/metting/"/>
    <url>/2020/04/17/manage/metting/</url>
    
    <content type="html"><![CDATA[<h2 id="周会模板"><a href="#周会模板" class="headerlink" title="周会模板"></a>周会模板</h2><h4 id="周会时间"><a href="#周会时间" class="headerlink" title="周会时间"></a>周会时间</h4><p>每周五为各小组周会时间，持续时间40分钟内！</p><p>每人时间不超过3分钟</p><h4 id="周会参与人员"><a href="#周会参与人员" class="headerlink" title="周会参与人员"></a>周会参与人员</h4><p>各小组成员必须参与本组的周会，</p><p>如无法参加周会，请提前告知小组长，</p><p>无故不参加周会者，与个人积分挂勾，</p><h4 id="周会内容"><a href="#周会内容" class="headerlink" title="周会内容"></a>周会内容</h4><p>本周工作内容总结</p><h4 id="下周工作计划"><a href="#下周工作计划" class="headerlink" title="下周工作计划"></a>下周工作计划</h4><p>提出工作中遇到的问题，以及解决办法的建议，</p><p>需要得到的支持【资源，其他】</p><p>小组参与成员交流工作中的其他问题并提出个人意见</p><p>周会输出<br>会议纪要【按照会议纪要模版输出】</p><p>如下所示：</p><h2 id="周报模板"><a href="#周报模板" class="headerlink" title="周报模板"></a>周报模板</h2><p>周报时间<br>各小组周报：时间每周六18:00截止</p><p>技术部周报：时间每周六21:00截止</p><p>未按时发送周报者，自觉贡献奶茶基金【20？】</p><p>周报内容：<br>本周工作内容：每项具体完成度需清晰【XX%】</p><p>1、         xxxxXXX【30%】</p><p>2、         xxxxxXXX【90%】</p><p>3、         xXXXXXX【100%】</p><p>4、         XXXXXX【100%】</p><p>下周工作计划：</p><p>1、           xxxxXXX【30%】</p><p>2、         xxxxxXXX【90%】</p><p>3、         xXXXXXX【100%】</p><p>4、         XXXXXX【100%】</p><p>待确认：【需要其他小组，部门协助，支持的事项】</p><p>1、         XXXXXXX</p><p>2、         XXXXXXX</p><h2 id="绩效面谈清单"><a href="#绩效面谈清单" class="headerlink" title="绩效面谈清单"></a>绩效面谈清单</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-07-13.png"></p><h2 id="自动化测试报告邮件格式"><a href="#自动化测试报告邮件格式" class="headerlink" title="自动化测试报告邮件格式"></a>自动化测试报告邮件格式</h2><p>【日期】<br>【测试模块】<br>【运行次数&#x2F;平均通过率】<br>【测试用例数】<br>【测试bug数】<br>【测试人员】<br> 8月计划：  </p><ul><li><ol><li></li></ol></li><li><ol start="2"><li></li></ol></li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-10-22.png"></p><h2 id="测试报告邮件回复格式"><a href="#测试报告邮件回复格式" class="headerlink" title="测试报告邮件回复格式"></a>测试报告邮件回复格式</h2><p>  测试需求：每日对账-添加黑名单详细类型<br>  测试阶段：sit测试<br>  测试结论：测试通过<br>  测试覆盖：黑名单通知、非黑名单不通知  </p><h2 id="测试排期和格式"><a href="#测试排期和格式" class="headerlink" title="测试排期和格式"></a>测试排期和格式</h2><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-12-39.png"></p>]]></content>
    
    
    <categories>
      
      <category>manage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>manage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sql</title>
    <link href="/2020/02/19/testbasic/sql/"/>
    <url>/2020/02/19/testbasic/sql/</url>
    
    <content type="html"><![CDATA[<h1 id="sql基础"><a href="#sql基础" class="headerlink" title="sql基础"></a>sql基础</h1><h2 id="常见数据库类型介绍"><a href="#常见数据库类型介绍" class="headerlink" title="常见数据库类型介绍"></a>常见数据库类型介绍</h2><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>Codd提出了关系模型算法，为关系型数据库的诞生奠定了基础</p><h3 id="1-1-市面上的数据库产品介绍"><a href="#1-1-市面上的数据库产品介绍" class="headerlink" title="1.1 市面上的数据库产品介绍"></a>1.1 市面上的数据库产品介绍</h3><p>用二维表存储数据 Oracle、Mysql、postgre、SQL server、DB2、Informix-Online、…</p><h4 id="1-1-1-Oracle"><a href="#1-1-1-Oracle" class="headerlink" title="1.1.1 Oracle"></a>1.1.1 Oracle</h4><p>在OL TP&#x2F;AP（在线事务管理&#x2F;访问管理）都很优秀）</p><h4 id="1-1-2-Mysql"><a href="#1-1-2-Mysql" class="headerlink" title="1.1.2 Mysql"></a>1.1.2 Mysql</h4><p>是一个轻量级的数据库服务器原属于Apache，后被Oracle收购，在面向并发式的大量的业务处理时，性能表现非常差、并且不支持第二索引和第三索引，面向一些复杂的数据结构时，其检索效率会偏低一些、存储过程、触发器的管理较简单，但是现在随着数据库缓存的出现，Mysql逐渐成为大家的主流的选择</p><h4 id="1-1-3-PostgreSQL（诞生最晚）"><a href="#1-1-3-PostgreSQL（诞生最晚）" class="headerlink" title="1.1.3 PostgreSQL（诞生最晚）"></a>1.1.3 PostgreSQL（诞生最晚）</h4><p>第一个提出了对象关系型数据库，储存数据更加灵活。相较于传统数据库，可以对对象类型数据进行存储，并且，对OL TP&#x2F;AP的处理能力仅次于Oracle，可以自动优化读写操作。</p><h4 id="1-1-4-SQL-server"><a href="#1-1-4-SQL-server" class="headerlink" title="1.1.4 SQL server"></a>1.1.4 SQL server</h4><p>微软和Sybase合作推出的SQL server，之后由于想要支持的操作系统不同，分道扬镳。<br>微软后推出了MS SQL Server（目前为止，只有用到.NET开发时会用到）<br>Sybase推出了SQL Server anywhere</p><h4 id="1-1-5-DB2、Informix-Online"><a href="#1-1-5-DB2、Informix-Online" class="headerlink" title="1.1.5 DB2、Informix-Online"></a>1.1.5 DB2、Informix-Online</h4><p>上面两个数据库服务器都是属于IBM，两款数据库的定位不同，DB2主要应用于应用于海量数据存储，业界好评，但是价格较贵。Informix-Online在在线事务处理过程中表现优异，有非常灵活的在线事务优化机制，在大量并行的读事务时，不会出现锁或者死锁的性能问题，一些银行利用Informix-Online来存储需要大量的写或者读的数据。</p><h2 id="nosql数据库"><a href="#nosql数据库" class="headerlink" title="nosql数据库"></a>nosql数据库</h2><h3 id="2-1-nosql数据库介绍"><a href="#2-1-nosql数据库介绍" class="headerlink" title="2.1 nosql数据库介绍"></a>2.1 nosql数据库介绍</h3><p>谷歌最先提出这个概念，主要解决海量数据存储的问题（数据量特别大并且不规则，如果用二维表进行存储，会造成大量字段留空）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;12123&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;gungun&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-number">12</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;12123&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;pref&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;跑步&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-attr">&quot;occupation&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;IT&quot;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如上所示，存储数据按JSON格式的数据来进行存储(用二维表造成大量字段留空)，这种类型的数据库不善于表达数据之间的关联关系，所以在进行关联查询时会有极大的问题，所以这种数据常用于强数据弱关联的数据库。</p><h3 id="2-2-常见的nosql数据库"><a href="#2-2-常见的nosql数据库" class="headerlink" title="2.2 常见的nosql数据库"></a>2.2 常见的nosql数据库</h3><p>mongoDB（主要用于文档型数据库）、redis（主要用于日志数据库）</p><h4 id="2-2-1-mongoDB"><a href="#2-2-1-mongoDB" class="headerlink" title="2.2.1 mongoDB"></a>2.2.1 mongoDB</h4><p>存储数据的结构<br>DB–&gt;collection–&gt;document–&gt;键值对<br>document：一个json格式的数据<br>collection：对应的就是关系型数据库里面的一张表</p><h4 id="2-2-2-redis"><a href="#2-2-2-redis" class="headerlink" title="2.2.2 redis"></a>2.2.2 redis</h4><p>只支持键值对并且只支持缓存存储，并且可以进行分布式部署。</p><h2 id="数据的增删改查"><a href="#数据的增删改查" class="headerlink" title="数据的增删改查"></a>数据的增删改查</h2><ul><li>插入数据的sql命令（insert）</li><li>修改更新表数据的sql命令（update）</li><li>删除数据库，数据的sql命令（drop,delete）</li><li>插入表数据（insert）</li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ul><li>1：单行注释： – 空格 快捷键：ctrl + &#x2F;  取消注释： ctrl + shift +&#x2F;</li><li>2：多行注释： &#x2F;* xxx *&#x2F;</li><li>3: 非标准的注释： #</li></ul><h3 id="插入：insert"><a href="#插入：insert" class="headerlink" title="插入：insert"></a>插入：insert</h3><h4 id="1：插入一条数据，对所有字段都赋值。"><a href="#1：插入一条数据，对所有字段都赋值。" class="headerlink" title="1：插入一条数据，对所有字段都赋值。"></a>1：插入一条数据，对所有字段都赋值。</h4><p>insert into &lt;表名&gt; values ( 值A,值B,值C…,值F); </p><p>弱语法  按字段顺序写 into可以省略，字符串型要加” “或’ ‘,duplicate出现表示主键有重复</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> member <span class="hljs-keyword">values</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;13666666666&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-string">&#x27;Jack&#x27;</span>,<span class="hljs-number">0.0</span>);  <br></code></pre></td></tr></table></figure><h4 id="插入一条数据，对部分字段都赋值。"><a href="#插入一条数据，对部分字段都赋值。" class="headerlink" title="插入一条数据，对部分字段都赋值。"></a>插入一条数据，对部分字段都赋值。</h4><p>insert into &lt;表名&gt;(字段A,字段B,字段C) values ( 值A,值B,值C);</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">-- <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> member(mobliephone,pwd,regName) <span class="hljs-keyword">values</span>(<span class="hljs-string">&#x27;1377777777&#x27;</span>,<span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-string">&#x27;happy&#x27;</span>);<br>-- <span class="hljs-keyword">insert</span> member(mobliephone,pwd,regName,leaveAmount) <br></code></pre></td></tr></table></figure><h4 id="3：新增多行记录"><a href="#3：新增多行记录" class="headerlink" title="3：新增多行记录"></a>3：新增多行记录</h4><p>insert into &lt;表名&gt;(字段A,字段B,字段C) values ( 值A,值B,值C),( 值A,值B,值C),( 值A,值B,值C);用逗号分隔</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 1c">/*<br>insert member<span class="hljs-punctuation">(</span>mobliephone<span class="hljs-punctuation">,</span>pwd<span class="hljs-punctuation">,</span>regName<span class="hljs-punctuation">,</span>leaveAmount<span class="hljs-punctuation">)</span> <br>values<span class="hljs-punctuation">(</span>&#x27;<span class="hljs-number">1377777777</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;<span class="hljs-number">123456</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;happy1&#x27;<span class="hljs-punctuation">,</span><span class="hljs-number">0.0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">(</span>&#x27;<span class="hljs-number">1377777777</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;<span class="hljs-number">123456</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;happy2&#x27;<span class="hljs-punctuation">,</span><span class="hljs-number">0.0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">(</span>&#x27;<span class="hljs-number">1377777777</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;<span class="hljs-number">123456</span>&#x27;<span class="hljs-punctuation">,</span>&#x27;happy&#x27;<span class="hljs-punctuation">,</span><span class="hljs-number">0.0</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">;</span><br>*/<br></code></pre></td></tr></table></figure><h3 id="更新（修改）"><a href="#更新（修改）" class="headerlink" title="更新（修改）"></a>更新（修改）</h3><h4 id="1-修改所有记录-update-表名-set-字段名1-新值1-字段名2-新值2-…-多个字段逗号分割"><a href="#1-修改所有记录-update-表名-set-字段名1-新值1-字段名2-新值2-…-多个字段逗号分割" class="headerlink" title="1:修改所有记录  update 表名 set 字段名1&#x3D;新值1,字段名2&#x3D;新值2 …; 多个字段逗号分割"></a>1:修改所有记录  update 表名 set 字段名1&#x3D;新值1,字段名2&#x3D;新值2 …; 多个字段逗号分割</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-- 把所有用户的余额修改成10000<br>-- update member <span class="hljs-built_in">set</span> <span class="hljs-attribute">leaveAmount</span>=10000.0;<br>-- 把所有用户的余额修改成0,密码改为abcdef<br>-- update member <span class="hljs-built_in">set</span> <span class="hljs-attribute">leaveAmount</span>=0,pwd=&#x27;abcdef&#x27;;<br></code></pre></td></tr></table></figure><h4 id="2：修改部分记录"><a href="#2：修改部分记录" class="headerlink" title="2：修改部分记录"></a>2：修改部分记录</h4><p>update 表名 set 字段名1&#x3D; 新值1，字段名2&#x3D;新值2 … where 条件表达式1 and(or)  条件表达式2 …;</p><p>条件表达式： &#x3D;  &lt;  &lt;&#x3D;  &gt;  &gt;&#x3D;  不等于：&lt;&gt;  !&#x3D;</p><h4 id="一个条件"><a href="#一个条件" class="headerlink" title="一个条件"></a>一个条件</h4><p>修改用户id为2的用户的余额为10000<br>– update member set leaveAmount&#x3D;10000 where id&#x3D;2;</p><h4 id="多个条件，采用and或者是or来连接："><a href="#多个条件，采用and或者是or来连接：" class="headerlink" title="多个条件，采用and或者是or来连接："></a>多个条件，采用and或者是or来连接：</h4><ul><li>and：并且（多个条件要同时满足）    </li><li>or：或者（满足其中一个条件即可）<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-- 修改用户id为3，regname为jack的用户余额为5000<br>-- update member <span class="hljs-built_in">set</span> <span class="hljs-attribute">leaveAmount</span>=10000 where <span class="hljs-attribute">id</span>=3  <span class="hljs-keyword">and</span> <span class="hljs-attribute">regName</span>=<span class="hljs-string">&#x27;Jack&#x27;</span>;<br>-- 修改手机号为13666666666，或者regname为rose的用户余额为100<br>-- update member <span class="hljs-built_in">set</span> <span class="hljs-attribute">leaveAmount</span>=200 where <span class="hljs-attribute">mobliePhone</span>=13666666666 <span class="hljs-keyword">or</span> <span class="hljs-attribute">regname</span>=<span class="hljs-string">&#x27;Rose&#x27;</span>;<br>-- 把余额为0的用户的可用余额修改为5000<br>-- update member <span class="hljs-built_in">set</span> <span class="hljs-attribute">leaveAmount</span>=5000 where <span class="hljs-attribute">leaveAmount</span>=0.0;<br></code></pre></td></tr></table></figure></li></ul><h3 id="四-删除"><a href="#四-删除" class="headerlink" title="四:删除"></a>四:删除</h3><h4 id="1-删除数据库-–-谨慎操作，从删库到跑路-–-删除数据库所有对象（表结构、函数、存储过程。。。。）"><a href="#1-删除数据库-–-谨慎操作，从删库到跑路-–-删除数据库所有对象（表结构、函数、存储过程。。。。）" class="headerlink" title="1:删除数据库 – 谨慎操作，从删库到跑路 – 删除数据库所有对象（表结构、函数、存储过程。。。。）"></a>1:删除数据库 – 谨慎操作，从删库到跑路 – 删除数据库所有对象（表结构、函数、存储过程。。。。）</h4><p>– drop database 数据库名;</p><h4 id="2-删除表"><a href="#2-删除表" class="headerlink" title="2:删除表"></a>2:删除表</h4><p>– drop table 表名;<br>– drop table testdrop;<br>想把一个词作为字段，打一个反引号在键盘左上角第二个<code>regName </code>  </p><h4 id="3-删除表记录"><a href="#3-删除表记录" class="headerlink" title="3:删除表记录"></a>3:删除表记录</h4><ul><li><p>1:删除所有记录<br>– delete from 表名;<br>– delete from member;</p></li><li><p>2:删除部分记录，删除符合条件的记录  – 谨慎操作</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">-- <span class="hljs-built_in">把id</span>小于<span class="hljs-number">13</span>的用户全部删除<br>-- <span class="hljs-keyword">delete</span> from member <span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>&lt;<span class="hljs-number">13</span>;<br>-- <span class="hljs-built_in">把id</span>不等于<span class="hljs-number">14</span>的用户删除<br>-- <span class="hljs-keyword">delete</span> from member <span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>&lt;&gt;<span class="hljs-number">14</span>;<br></code></pre></td></tr></table></figure></li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>如果要删除某个表里满足某个条件的数据，需要用到关键字“where”来进行过滤找出那一部分数据<br>delete也是一种删除命令，但与drop不同的是，delete只会删除表数据，不会删除表和库，简单点讲，delete只删除数据不删除结构.</p><h3 id="五：拓展"><a href="#五：拓展" class="headerlink" title="五：拓展"></a>五：拓展</h3><ul><li>1：delete清空表 :不会影响到自增长的字段值<br>– delete from 表名;<br>– delete from member;</li><li>2:truncate清空表 :会将自增长的字段恢复初始值<br>– truncate table 表名;<br>– truncate table member;</li></ul><p>插入数据时，初始化所有字段和部分字段时sql的不同点提现在哪里——-插入部分字段要指定字段名<br>赋值时对于varchar类型的字符，赋值时要用单引号或双引号<br>字段声明的长度，插入数据超长时会根据声明长度进行截取。<br>插入多条数据时用逗号分割<br>用alter修改字段类型  </p><h2 id="单表多表查询"><a href="#单表多表查询" class="headerlink" title="单表多表查询"></a>单表多表查询</h2><ul><li>1.数据库的核心就是关联，多表查询首先就是要抓住各个表之间的关联部分，两个表联系起来后，再写条件，写查询什么就很简单了</li><li>2.and 和 or 之间的关系要搞清楚。</li><li>3.基本表达式记住</li></ul><h2 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h2><h3 id="1：查询单个表的所有数据，显示所有字段"><a href="#1：查询单个表的所有数据，显示所有字段" class="headerlink" title="1：查询单个表的所有数据，显示所有字段"></a>1：查询单个表的所有数据，显示所有字段</h3><p>– select * from 表名;<br>– select * from member; – *代表所有字段</p><h3 id="2-查询单个表的所有数据，显示部分字段"><a href="#2-查询单个表的所有数据，显示部分字段" class="headerlink" title="2:查询单个表的所有数据，显示部分字段"></a>2:查询单个表的所有数据，显示部分字段</h3><p>– select &lt;字段1,字段2,…&gt; from &lt; 表名 &gt;;</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">-- 查询所有的会员信息，显示用户名，手机号，可用余额  <br>-- select RegName,MobilePhone,<span class="hljs-class">LeaveAmount from member;</span><br>```  <br><span class="hljs-comment">### 3: 查询部分数据-- where 字句</span><br>-- select &lt;字段1,字段2,...&gt; from &lt; 表名 &gt; where 条件表达式1<span class="hljs-built_in"> and/or </span>条件表达式2...;  <br>-- 条件表达式1:筛选条件  <br>-- =  &gt; &lt; &gt;=  &lt;=  != == <span class="hljs-keyword"> :</span>比较表达式  <br></code></pre></td></tr></table></figure><p>– 查询id为3的会员信息<br>– select * from member where id&#x3D;3;<br>– 查询id为3，用户名为大树的信息<br>– and :并且,需要满足其中所有条件<br>– select * from member where id&#x3D;3 and RegName&#x3D;’大树’;<br>–   or:或者,只要满足多个条件中一个条件即可<br>– select * from member where id&#x3D;3 or RegName&#x3D;’大树’;<br>– select * from member where id&gt;10;<br>– 不等于<br>– select * from member where id&lt;&gt;10;<br>– select * from member where id!&#x3D;10;.</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><br><span class="hljs-comment">## 多表查询</span><br>对于不同类型的信息放在一个表的缺点：<br><span class="hljs-literal">-</span> 1.字段过多<br><span class="hljs-literal">-</span> 2.难以维护<br><span class="hljs-literal">-</span> 3.表数据庞大<br><span class="hljs-literal">-</span> 4.数据冗余，重复数据多<br>既然不同类型的数据放在了不同的表，那原本有联系的数据怎么保持原来的联系呢<br>设计表的时候两个表之间维持一个关联即可<br><span class="hljs-literal">-</span>- Oracle、MySQL、SQL Server...关系数据库：表与表存在关系、存在联系  <br><span class="hljs-literal">-</span>- 笛卡尔积、叉乘  --》结果集（虚表、缓存表）-&gt;存在无效数据的  <br><span class="hljs-literal">-</span>- select * from member,invest; -- 5964<br><span class="hljs-literal">-</span>- select * from member; -- 42 <br><span class="hljs-literal">-</span>- select * from invest; -- 142<br><span class="hljs-literal">-</span>- 幼儿园两个班,交朋友（条件握手）<br><span class="hljs-literal">-</span>- A  B<br><span class="hljs-literal">-</span>- 10 20<br><span class="hljs-comment">#### 只有什么样的数据是有效的？？ 通过关联条件：member.Id=invest.MemberID</span><br><span class="hljs-literal">-</span>- select * from member,invest where member.Id=invest.MemberID;<br><span class="hljs-literal">-</span>- 查询投资金额大于10000的信息，显示用户名、手机号、投资金额、投资时间 -- invest  member<br></code></pre></td></tr></table></figure><p>&#x2F;*<br>select member.RegName,member.MobilePhone,invest.Amount,invest.CreateTime<br> from member,invest<br>where member.id &#x3D; invest.MemberID – 条件1：关联条件<br>and invest.Amount&gt;10000;– 条件2<br>*&#x2F;</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clean">####  别名<br></code></pre></td></tr></table></figure><p>&#x2F;*<br>select t1.RegName,t1.MobilePhone,t2.Amount,t2.CreateTime<br> from member as t1,invest as t2<br>where t1.id &#x3D; t2.MemberID<br>and t2.Amount&gt;10000;<br><em>&#x2F;<br>&#x2F;</em><br>select t1.RegName,t1.MobilePhone,t2.Amount,t2.CreateTime<br>from member t1,invest t2<br>where t1.id &#x3D; t2.MemberID<br>and t2.Amount&gt;10000;<br><em>&#x2F;<br>&#x2F;</em><br>select t1.RegName as  用户名,t1.MobilePhone  as 手机号码,<br>t2.Amount as  投资金额 ,t2.CreateTime  as 投资时间<br>from member  as t1,invest  as t2<br>where t1.id &#x3D; t2.MemberID<br>and t2.Amount&gt;10000;<br>*&#x2F;</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 排序<br>-- 查询投资金额大于<span class="hljs-number">10000</span>的信息，显示用户名、手机号、投资金额、投资时间 ，按投资金额降序、升序排序<br>#### 降序：DESC、升序： ASC（默认为ASC）<br></code></pre></td></tr></table></figure><p>select t1.Id as 用户id,t1.RegName as  用户名,t1.MobilePhone  as 手机号码,<br>t2.Amount as  投资金额 ,t2.CreateTime  as 投资时间<br>from member  as t1,invest  as t2<br>where t1.id &#x3D; t2.MemberID<br>and t2.Amount&gt;10000<br>order by 投资金额 DESC;</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">## 左连接右连接<br>![](../.vuepress/public/picture/Snipaste_2021<span class="hljs-string">-06</span><span class="hljs-string">-09</span>_11<span class="hljs-string">-32</span><span class="hljs-string">-18</span>.png)<br></code></pre></td></tr></table></figure><p>、select * from girls t1 inner join boys t2 on t1.matchNum &#x3D; t2.matchNum;<br>   select * from girls t1 join boys t2 on  t1.matchNum &#x3D; t2.matchNum;<br> select - from girls cross join boys  &#x2F;&#x2F;笛卡儿积 叉乘<br> <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### 连接两个语句连接用union，且字段名要相同才可以显示  所以要取别名<br></code></pre></td></tr></table></figure><br>select t1.id,t1.girjNum num from girls t1 left join boys t2 on   t1.matchNum &#x3D; t2.matchNum where t2.id is null<br>union<br>select t2.id,t2.boyNum num from girls t1 right  join boys t2 on   t1.matchNum &#x3D; t2.matchNum where t1.id is null;</p><pre><code class="hljs">## 子查询子查询概念：一个select语句嵌套在另一个select 语句中  子查询也可以称为内部查询，而包含子查询的语句又成为外部查询或主查询  子查询可分类：  - 非相关子查询 ：独立于外部查询，子查询只执行一次，执行完将结果传递给外部查询，子查询可以单独运行- 相关子查询：依赖于外部查询的数据，外部查询每执行一次，子查询就执行一次子查询自身可以包含一个或多个子查询  一个查询语句中可以嵌套任意数量的子查询#### 比较大小max是纵向比较，GREATEST是横向比较Greatest(1,2,3)## 高级查询- 1.in的用法  select * from member where id in(1,2,3);- 2.模糊查询like的用法- 3.统计count()的用法- 4.去重distinct的用法- 5.between的用法- 6.分组group by的用法- 7.mysql分页## in的用法在。。。里面#### 字段 in(数据集)-- 查询用户id为1，或者为2，或者为3的用户-- select * from member where id in(1,2,3)#### not in: 不在...里面-- select  * from member where id not in(1,2,3);## 模糊查询like-- 查询姓小的会员-- select * from member where RegName like &#39;小&#39;; -- 没有%表示完全匹配。名字为小的用户-- 姓小：表示第一个字符是小，后面可以是任意字符 #### 模糊匹配 %：表示可以是任意字符，也可以是空字符串-- select * from member where RegName like &#39;小%&#39;;姓为小，后面可以是任何字符-- select * from member where RegName like &#39;%小&#39;;必须以小结尾，前面可以是任意字符-- select * from member where RegName like &#39;%小%&#39;; 查找包含小这个关键字的记录## 统计count()-- 统计行数，纵向统计 count 3种写法(1)-- select count(*) from member;  42条记录 表示有42行 * 表示一条记录所有字段(2)-- select count(id) from member; -- 推荐使用 统计一个字段eg:select count(RegName) from member;(3) select count(1) from member;大力推荐使用select 1 第一列，t.*from member t;  t.*代表所有字段   1是常量的一个列select 1,&#39;零檬&#39;，t.* from member t; 增加常量列用逗号隔开select 1,id,regname from member; 1表示 第一列全部为1，是一个常量，手动加了一个常量列#### select count-- select count(&quot;柠檬班&quot;) from member;这样写的意义： 加入要j加一列type为1 为普通用户select &#39;普通用户’，type from member where type=1;#### select if 自己查找## 去重distinct-- 需求：查询所有的有投资的用户的id-- select distinct MemberID from invest;                                                  -- distinct 字段1,字段2,字段3： 当两行记录字段1,字段2,字段3一一相等的时候，表示重复-- 字段1,字段2,字段3--  A     B    C--  A     B    D--  A     B    C当2行记录多个字段全部相等时是重复，这样的记录会去掉## between...and在。。。之间  between 小值 and 大值 -- 需求：查询出用户可用余额在10000（包括）到30000（包括）之间的用户信息-- select * from member where LeaveAmount between 10000 and 30000;-- select * from member where LeaveAmount between 30000 and 10000; -- 没有记录，顺序要从小到大## 分组group by--- 通过...分组思维方式：-- 统计男生和女生的平均年龄-- 先把同学们根据性别分成男、女的两组，分完组，分别计算男女两组的平均年龄-- 统计每个投资用户的平均的投资金额 invest表  -- 按哪个字段分组的意思是哪个字段相同说明他们是同一组-- 只有memberid相同的记录表示是同一个用户的投资记录--》group by memberId-- 分组完毕：可以去计算、统计组内的信息-- select MemberID,avg(Amount) from invest group by MemberID;-- 统计每个投资用户的平均投资金额、最大投资额、最小投资额、总投资额、投资次数/*select MemberID,avg(Amount),max(Amount),min(Amount),sum(Amount), count(id) 投资次数from invest group by MemberID;*/-- group by 字段一,字段二,字段三：只有当字段一字段二字段三完全相同是，才算是一组-- 字段1,字段2,字段3--  A     B    C  和第三条记录为一组--  A     B    D--  A     B    C-- 大学  年级  班级-- 清华  大三  10086   1-- 北大  大三  10086   2-- 清华  大三  10086   3 ## MySQL分页-- 分页1：limit m,n :m表示索引(记录的索引)  n:表示一页多少记录-- 一页10条，你给我返回第一页-- select * from member limit 0,10; -- 第一页 -- select * from member limit 10,10; -- 第三页-- select * from member limit 20,10 -- 第三页-- 分页二：-- select * from member limit m offset n; -- m每页多少条，n偏移量(索引)-- 一页10条，你给我返回第一页单表查询多表查询.note-- select * from member limit 10 offset 0;-- select * from member limit 10,10; -- 第一页 、-- 分页三：top语法：取最前面的10-- select * from member limit 10;-- 查询出可用余额最多的前10个用户-- select * from member order by LeaveAmount desc limit 10;-- 查询出最新的一个会员记录-- select * from member order by id desc limit 1;-- 子查询-- select * from member where id=(select max(id) from member);## 掌握MySQL常用函数### 数值相关函数- 求字段A的最小值：min(字段A)- 求字段A的最大值：max(字段A)- 求字段A的平均值：avg(字段A)- 求字段A的和:sum(字段A)### 日期函数- 获取系统当前日期时间：sysdate( )- 获取系统当前日期：curdate()- 获取系统当前时间：curtime()- 获取系统给定日期的年份：year(date)  select year(sysdate());- 获取给定日期的月份 month(date)- 为指定日期增加一个时间间隔的函数 DATE_ADD(date,INTERVAL expr unit)slect DATE_ADD(SYSDATE(),INTERVAL 1DAY）；在系统时间基础上加上一天### 字符串函数- 字符串拼接函数：contact(字段A ,字段B,字段 C)select contact (;HELLO&#39;,&#39;&#39;,&#39;WORLD&#39;);- 字符串截取函数：SUBSTR(字段A,截取开始的位置position,截取字符个数）slect regname,mobilephone  from memberselect.substr(regname,1,l2);从最开始截取2个字符串- 获取字符串长度的函数：length(字段A)</code></pre>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试需求分析</title>
    <link href="/2020/02/17/testbasic/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/"/>
    <url>/2020/02/17/testbasic/%E6%B5%8B%E8%AF%95%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="测试需求分析"><a href="#测试需求分析" class="headerlink" title="测试需求分析"></a>测试需求分析</h2><p>软件测试需求分析</p><h2 id="1-什么是软件测试需求？"><a href="#1-什么是软件测试需求？" class="headerlink" title="1.什么是软件测试需求？"></a>1.什么是软件测试需求？</h2><p>测试需求就是明确在项目中要测试什么。<br>我们在测试活动中，首先要明确测试需求（what),才能决定怎么测（how)什么时候测（when)需要多少人（who)测试的环境是什么（where),测试中需要的技能，工具以及相应的背景知识，测试中可能遇到的风险等等。</p><h2 id="2-软目件需求分析的的"><a href="#2-软目件需求分析的的" class="headerlink" title="2.软目件需求分析的的"></a>2.软目件需求分析的的</h2><p>测试需求分析的主要目的“获取测试点，根据测试点来编写测试用例</p><ul><li>1.把不直观的需求—–转变为直观的需求（用例图&#x2F;活动图 flow图）<ul><li>a.使得测试范围可以度量（有多少功能，有多少功能项）度量测试范围（规定测试范围）</li><li>b.使得独立的功能点对应的所 有处理分支可以度量 度量独立功能点的功能处理分支（细化独立功能点的功能范围）</li><li>c.使得该系统需要测试的业务场景可以度量    度量业务场景（各种各样的流程图也是各种业务场景）</li></ul></li><li>2.把不明确的需求转变为可度量的需求明确其功能点的输入，处理和输出结果（明确输入—-输出的结果）</li></ul><h2 id="3-如何对软件测试需求分析"><a href="#3-如何对软件测试需求分析" class="headerlink" title="3.如何对软件测试需求分析"></a>3.如何对软件测试需求分析</h2><p>需求分析和测试需求分析的区别?  先需求分析(产品经理）——-测试需求分析（测试人员）</p><p>需求分析：初步设想（客户需求）-需求分析-需求规格：输入，处理和输出（先得到原始需求，由产品经理进行需求分析，然后输出需求规格说明书）</p><p>测试需求分析：单个功能点输入处理输出——-业务流程分析——-全局–（整个系统）——隐式需求挖掘（UI，性能，安全，应用性等)</p><h2 id="4-测试需求分析"><a href="#4-测试需求分析" class="headerlink" title="4.测试需求分析"></a>4.测试需求分析</h2><ul><li>通过分析需求描述中的输入，输出，处理，限制，约束等给出对应的验证内容：（功能测试）</li><li>通过分析各个功能模块之间的业务顺序，和接口之间信息和数据的传递，对存在功能交互的功能项，给出对应的验证内容（功能交互性测试，握手）</li><li>考虑到需求的完整性，要充分考虑隐性需求的验证，比如界面的验证，注册账号的唯一性（界面，易用性，兼容性，安全性，性能）</li><li>根据场景法和错误分析法补充测试案例</li></ul><h4 id="测试点分析步骤："><a href="#测试点分析步骤：" class="headerlink" title="测试点分析步骤："></a>测试点分析步骤：</h4><ul><li>1.正常功能：核心最基本的功能</li><li>2.功能验证：规则：按顺序从上至下，对每一个输入项进行验证</li><li>3.功能交互验证</li><li>4.隐性需求<br>充分熟悉产品业务，挖掘隐性需求。（UI，兼容，性能，安全，易用）</li></ul><h2 id="5-需求的变更"><a href="#5-需求的变更" class="headerlink" title="5.需求的变更"></a>5.需求的变更</h2><p>对于一个存在生命周期的软件产品来说，软件的开发和测试往往都不是一次性的，因为随着新的需求出现，以及对原有版本的改进，新的版本会不断的发布。<br>  我们都面临一个点实际问题：就是软件需求在开发过程中会不断发生变化，有时候到了后期还会有新的需求加进来，或者是发版以后发现原来的需求存在缺陷，之后重新返工，那么我们该如何在最终发布之前，确定需求呢？</p><p>如此我们就必须要考虑软件需求的版本化控制。当要进行一个新版本的迭代时，我们在工作开始之前就确认好本次需求的范围：如实出现需求变更，则根据市场策略，已公布的发布时间，客户需求，实现的代价，难易程度以及对现有工作影响等方面考虑，对需求进行适度划分，严格定义当前版本需要实现的功能，而其他的部分，则作为未来版本的需求<br>总之遵循一个原则，对一个版本的需求版更，必须早发现，早讨论，早决定，早调整。</p><h4 id="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"><a href="#以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。" class="headerlink" title="以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。"></a>以上常用的黑盒用例设计方法，等价类，边界值，错误推测，场景法细化出测试点。</h4><p>桌子<br>功能度：桌子能不能放东西。<br>安全性：打造桌子所用的木料有没有毒或者腐烂污染<br>可靠性：杯子从不同高度落下的损坏程度<br>可移植性：桌子在不同的地方、温度等环境下是否都可以正常使用<br>兼容性：桌子能否作为饭桌，书桌，游戏桌子使用。<br>易用性：桌子是否平滑不拉手、桌角是否打磨平整，桌子的高度设置是否符合人体工学标准、是否方便办公<br>用户文档：使用手册是否对桌子的用法、限制、使用条件等有详细描述<br>疲劳测试：将桌子放上100kg重物放24小时检查桌子表面的情况<br>压力测试：在桌子上面不断加重物，看压力多大时桌子会倾斜  </p>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试用例设计方法总结</title>
    <link href="/2020/02/17/testbasic/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/02/17/testbasic/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="测试用例设计方法总结"><a href="#测试用例设计方法总结" class="headerlink" title="测试用例设计方法总结"></a>测试用例设计方法总结</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>软件测试的核心是测试用例的编写，测试用例的编写对软件测试的过程来说十分重要。<br>黑盒测试和白盒测试是两类不同的测试方法。</p><ul><li>1.我们为什么要做好测试用例设计<ul><li>1）测试用例的好坏，直接关系着最根本的测试质量和测试效率的优劣</li><li>2）测试用例设计能力的好坏，直接影响了开发人员对测试第一印象的好坏</li></ul></li><li>2.好的测试用例有什么共性？<ul><li>1）测试设计结构组织合理（根据需求说明书和主要模块，有侧重点能抓住最主要的测试点和测试范围)</li><li>2)设计用例设计覆盖全面且不冗余(用专业经典的描述，最少的测试用例来尽可能多的覆盖更多测试点)</li><li>3）测试用例设计具有可执行，可判定，可再现的特点。(逐步细化第一步明确一条用例的测试需求点。然后写测试步骤，  测试步骤要明确，好执行。不要一开始就进入细节容易本末倒置逻辑混乱。测试力度要适中，精简测试用例。)</li></ul></li></ul><h2 id="黑盒测试的测试用例设计方法"><a href="#黑盒测试的测试用例设计方法" class="headerlink" title="黑盒测试的测试用例设计方法"></a>黑盒测试的测试用例设计方法</h2><h2 id="1-等价类划分法"><a href="#1-等价类划分法" class="headerlink" title="1.等价类划分法"></a>1.等价类划分法</h2><p>等价类划分法是指某个输入域的子集合。在该子集合中，所有的输入数据对于揭露软件中的错误都      是等效的</p><ul><li>有效等价类：对于系统的规格说明是合理的，有意义的输入（符合需求规格说明书要求的输入）</li><li>无效等价类：对于系统的规格说明是不合理的，无意义的输入（不符合需求规格说明书要求的输入）<br>具体案例：<br>邮件地址                     @163.com(6~18个字符可使用字母，数字，下划线，需以字母开头）</li></ul><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_10-38-44.png"></p><h4 id="分析步骤："><a href="#分析步骤：" class="headerlink" title="分析步骤："></a>分析步骤：</h4><ul><li>1.测试点：邮件地址</li><li>2.关注点：1 字符数   2.组成<br>关注点1 字符数：<br>有效等价类和无效等价类<br>关注点2 组成<br>有效等价类和无效等价类</li><li>3.设计用例 有效等价类尽可能多的覆盖，交叉设计<br>  无效等价类一个用例只能一个测试点，好判断错误原因</li></ul><h2 id="2-边界值分析法"><a href="#2-边界值分析法" class="headerlink" title="2.边界值分析法"></a>2.边界值分析法</h2><ul><li>1.定义：边界值分析法是对等价类划分法的一个补充，边界值一般都是从等价类的边缘值去找。<br>       边界值分析的基本思想：正好等于，刚刚大于，刚刚小于边界的值作为测试数据</li><li>2.边界值的作用：基本功能容易在边界附近出问题，而不是在输入范围的内部<br> 如：边界类型数值太小，输入的数值的范围<br>  - 字串长短：Null-max-max+1(150个字符以为 Null 150 150+1)<br>  - 内容有无 (是否）<br>  - 支持与否（保留字符，特殊字符，计划外字符）</li><li>3.边界值应用范围：如果需求规定了取值范围或规定了取值的个数时，可利用边界值进行测试</li></ul><h2 id="3-场景法（flow图，这个比较熟悉，无需多关注）"><a href="#3-场景法（flow图，这个比较熟悉，无需多关注）" class="headerlink" title="3.场景法（flow图，这个比较熟悉，无需多关注）"></a>3.场景法（flow图，这个比较熟悉，无需多关注）</h2><ul><li>1.定义：通过场景描述的业务流程（业务逻辑）也就是flow图，设计用例来遍历场景，验证系功能</li></ul><p>重点是测试流程，每个流程下来用一个用例验证即可。流程测试没有问题并不能说明系统没有问题，只能说是流程没有问题，还需要func测试和ope操作测试，只有单个功能和流程都没有问题才可以。</p><h4 id="如何使用场景法"><a href="#如何使用场景法" class="headerlink" title="如何使用场景法"></a>如何使用场景法</h4><p>1.画出业务流程图</p><h2 id="4-错误推测法"><a href="#4-错误推测法" class="headerlink" title="4.错误推测法"></a>4.错误推测法</h2><p>基于经验和直觉推测程序中所有可能存在的各种错误，他的要素有三点：经验，知识，直觉。</p><ul><li>1.列举程序中所有可能有的错误和容易发生错误的特殊情况</li><li>2.根据他们选择测试用例</li></ul><h2 id="测试用例选择方法"><a href="#测试用例选择方法" class="headerlink" title="测试用例选择方法"></a>测试用例选择方法</h2><ul><li>任何情况下都要使用边界值分析法，这种方法设计出的测试用例发现程序错误的能力最强  </li><li>必要时用等价类补充一些测试用例  </li><li>先使用其它设计方法编写用例，再使用错误猜测法补充用例  </li><li>对照程序逻辑，检查已设计出的测试用例的逻辑覆盖度，如果没达到要求的覆盖标准，应再补足足够的测试用例。</li></ul><h4 id="编写测试用例会用到什么方法；"><a href="#编写测试用例会用到什么方法；" class="headerlink" title="编写测试用例会用到什么方法；"></a>编写测试用例会用到什么方法；</h4><p>等价类划分法，边界值分析法，错误推测法，场景法等</p>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java运算符</title>
    <link href="/2019/10/17/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2019/10/17/java/java%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><ul><li>加法 相加运算符两侧的值</li></ul><ul><li>减法 左操作数减去右操作数</li></ul><ul><li>乘法 相乘操作符两侧的值<br>&#x2F;  除法 左操作数除以右操作数（int类型的数相除时，会得到int类型的值，如果结果有小数，则小数部分会被舍弃）<br>% 模余运算（取余数）左边操作数除右边操作数的余数（模余，也就是取余数）<br>++ 自增，变量的值增加1，注意为了增加diamante的可读性，建议一定要加括号  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">System.<span class="hljs-keyword">out</span>.println(<span class="hljs-symbol">&#x27;x</span>++=<span class="hljs-string">&quot;+(x++));先打印在执行</span><br><span class="hljs-string">System.out.println(&quot;</span>+xx=<span class="hljs-string">&quot;+(++x));先执行在打印</span><br></code></pre></td></tr></table></figure>–  自减 ，变量的值减少1<br>算术运算符只能运用在数字类型数据之间的计算</li></ul><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>&#x3D;&#x3D; 检查两个操作数的值是否相等，如果相等则表达式返回真真<br>！&#x3D;检查两个操作数的值是否相等，如果值不相等，则表达式返回真  </p><blockquote><p>检查左操作数的值是否大于右操作数的值，如果是则表达式返回真<br>&lt;检查左操作数的值是否小于右操作数的值，如果是则表达式返回真<br>&#x3D;检查左操作数的值是否大于或等于右操作数的值，如果是则表达式返回真<br>&lt;&#x3D;检查左操作数的值是否小于或等于右操作数的值，如果是则表达式返回真<br>注意关系运算符只能运用在数值类型数据之间的运算，运算结果是布尔型的值，测试两个操作数之间的关系（但不会改变操作数的值）  </p></blockquote><p>System.out.println(“(4&#x3D;&#x3D;1)&#x3D;”+(4&#x3D;&#x3D;1));         (4&#x3D;&#x3D;1)&#x3D;false<br>数值类型的取反 -<br>布尔类型的取反！  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"> <span class="hljs-type">int</span> z =<span class="hljs-number">-30</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;数值类型取反&quot;+(-z));           数值类型取反<span class="hljs-number">30</span><br><span class="hljs-type">boolean</span> j = <span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;j=&quot;+!j);                                  j=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>&amp; 称为逻辑与运算符。当且仅当运算符两边的表达式都为真时，最后运算结果才为真  不管左边是真是假，都会执行右边<br>&amp;&amp; 称为短路与运算符，当且仅当两个操作数都为真，才为真。注意：如果前面的表达式为假，后面的表达式就不会执行，所以叫短路与<br>| 称为逻辑或运算符，如果两个操作数任何一个为真则返回为真<br>|| 称为短路或操作符，如果任何两个操作数任何一个为真，条件为真，但是值得注意的是，如果前面的表达式为真，则后面的表达式不会执行，所以叫短路或<br>！逻辑非运算符，用来反转操作数的逻辑状态，如果条件为true,则逻辑非运算符将得到false<br>注意：逻辑运算符只能运用在boolean类型的数据之间的运算  </p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_13-13-57.png"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">boolean</span> g =<span class="hljs-keyword">false</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;!g=&quot;+(!g));                   !g=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>&#x3D;简单的赋值运算符，将运算符右边的值赋给左侧变量，int C&#x3D;1+2将把1+2得到的3赋给C<br>+&#x3D; 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数，C+&#x3D;A等价于C&#x3D;C+A<br>-&#x3D; 减和赋值运算符它把左操作数和右操作数相减赋值给左操作数C-&#x3D;A等价于C&#x3D;C-A<br>*&#x3D;乘和赋值运算符，它把左操作数和右操作数相乘赋值赋值给左操作数<br>&#x2F;&#x3D;除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数<br>（%）&#x3D;，取模和赋值操作符，它把左操作数和右操作数取模赋值给左操作数<br>运算顺序是从右到左的</p><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>(A&#x3D;&#x3D;B?A:B)A是否等于B,等于的话输出A，不等于的话输出B</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> x =<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> y=<span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> z= <span class="hljs-number">10</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(x==y?&quot;X&quot;:&quot;Y&quot;);                    X<br></code></pre></td></tr></table></figure><p>运算顺序<br>1.括号<br>2.++，–<br>3.*，&#x2F;,%(同一优先级，从左至右）<br>4.+，-（同一优先级，从左至右）<br>注意：<br>1.同一优先级运算符的运算顺序为：从左至右<br>2.运算复杂的时候要一步步拆解  </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试定义&amp;分类</title>
    <link href="/2019/08/17/testbasic/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AE%9A%E4%B9%89&amp;%E5%88%86%E7%B1%BB/"/>
    <url>/2019/08/17/testbasic/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%AE%9A%E4%B9%89&amp;%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试的定义-分类"><a href="#软件测试的定义-分类" class="headerlink" title="软件测试的定义&amp;分类"></a>软件测试的定义&amp;分类</h1><h2 id="1-软件的定义"><a href="#1-软件的定义" class="headerlink" title="1.软件的定义"></a>1.软件的定义</h2><p>软件&#x3D;计算机程序+程序所用的数据+有关文档资料（不可或缺，是计算机的灵魂）<br>软件分为</p><ul><li>1.系统软件：是生成，准备和执行其他程序所需要的一组文件和程序（为应用软件的运行提     供系统运行环境的）比如Windows，Linx系统，SQL-Server ,Java，Python,C++,等高级编程语言</li><li>2.应用软件：计算机用户为了解决某些具体问题，具体的需求而购买，开发或研制的各种程序和软件包，如各种app,聊天的qq,微信，购物的淘宝，听音乐的网易云音乐，记笔记的有道云笔记等</li></ul><h2 id="2-软件测试的定义"><a href="#2-软件测试的定义" class="headerlink" title="2.软件测试的定义"></a>2.软件测试的定义</h2><p>使用人工或自动手段来运行或测试某个系统的过程，目的在于检验它是否满足规定的需求或弄清预期结果与实际结果之间的差别。<br>    1)为了发现程序存在的代码错误或业务逻辑错误（业务流程，比如浏览商品-下单-支付这样的一个过 程）<br>    2）检验产品是否符合用户需求<br>    3）不仅仅是为了发现错误<br>    4）为了提高用户体验（用户体验不好会导致用户大量流失，做大量的性能优化和性能测试提高用户体验）</p><h2 id="3-软件测试的原则"><a href="#3-软件测试的原则" class="headerlink" title="3.软件测试的原则"></a>3.软件测试的原则</h2><ul><li>1）测试应尽早进入，从需求阶段开始介入。</li><li>2）所有的测试都应追溯到用户需求（所有的工作都是围绕用户需求来的）</li><li>3）程序员应该避免检查自己的程序。（除了单元测试）</li><li>4）设计测试用例的时候要考虑到合法的输入和不合法的输入以及各种边界条件，特殊情况下爱要制造极端状态和意外状态</li><li>5）Pareto原则，测试发现的错误80%很可能起源于20%的模块（关注核心功能，如果发现一个错误，要在这里多点点，很可能会发现其他的错误，关联模块也要多点点，复归的时候关联模块也要复归，可能因为修改有了其他新的错误）。</li><li>6）对错误的结果要进行一个确认过程（对自己的bug要查找式样书，需求说明书，找到与之不符合的地方，作为bug的依据，如果是用户体验票，要说明是bug的理由）</li><li>7）制定严格的测试计划（一般是由测试负责人编写，计划要写的合理科学，一般不更改）</li><li>8）完全测试是不可能的，测试需要终止（用尽可能少的测试用例去覆盖更多的测试点，需求）</li><li>9）妥善保存测试过程中的所有文档</li></ul><h2 id="4-测试的对象："><a href="#4-测试的对象：" class="headerlink" title="4.测试的对象："></a>4.测试的对象：</h2><p>1.程序 2.数据 3.文档</p><h2 id="5-软件测试的分类"><a href="#5-软件测试的分类" class="headerlink" title="5.软件测试的分类"></a>5.软件测试的分类</h2><h4 id="按照测试阶段划分"><a href="#按照测试阶段划分" class="headerlink" title="按照测试阶段划分"></a>按照测试阶段划分</h4><p>单元测试，集成测试，系统测试，验收测试（正式验收测试，Alpha测试，Beta测试）</p><h4 id="按测试技术划分"><a href="#按测试技术划分" class="headerlink" title="按测试技术划分"></a>按测试技术划分</h4><p>白盒测试，黑盒测试，灰盒测试</p><h4 id="按被测对象是否运行划分"><a href="#按被测对象是否运行划分" class="headerlink" title="按被测对象是否运行划分"></a>按被测对象是否运行划分</h4><p>动态测试，静态测试（文档检查，代码走查，界面检查）</p><h4 id="按不同的测试手段划分"><a href="#按不同的测试手段划分" class="headerlink" title="按不同的测试手段划分"></a>按不同的测试手段划分</h4><p>手工测试，自动化测试</p><h4 id="按测试包含的内容划分"><a href="#按测试包含的内容划分" class="headerlink" title="按测试包含的内容划分"></a>按测试包含的内容划分</h4><p>功能测试，界面测试，安全测试，兼容性测试，易用性测试，性能测试（压力测试，负载测试），恢复测试</p><h4 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h4><p>冒烟测试，回归测试，探索性测试（测试思维）<br>具体：<br>单元测试（每个模块测试） 集成测试（把每个单元，模块组合起来） 系统测试(整个系统结合起来）</p><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><ul><li>1.白盒测试：基于软件内部设计和程序实现的测试方法，不仅仅关注输入输出和结果是否正确，同时关注程序是如何处理的（不仅了解输入输出结果而且了解软件的运行原理）</li><li>2.黑盒测试：测试过程中只关注输入和输出，如果输入一个测试数据，输出的结果是正确的，就认为这功能是正确的，也叫数据驱动测试（只关注输入输出结果，不关注运行过程原理）</li><li>3.冒烟测试：目的是确认软件基本功能正常，可以进行后续的正式测试工作（各模块基本机能运行正常即可）</li><li>4.功能测试：测试软件的功能是否符合需求，通常采用黑盒测试方法，一般由测试人员独立进行。</li><li>5.界面测试：简称UI测试（界面布局是否合理，整体风格是否一致，界面文字图片是否显示正常，对照产品原型图）(最上面ui界面测试-中间service服务层-下面unit单元测试）越上面越不重要</li><li>6.安全性测试：测试该系统防止非法入侵的能力(密码是否加密等等）</li><li>7.兼容性测试：测试该系统与其他软硬件兼容的能力</li><li>8.负载测试：在一定的软硬件及网络条件下，通过运行一种或者多种业务在不同虚拟用户数量情况下，测试服务器的性能指标是否满足用户的需求。确定系统所能承载的最大用户数，最大有效用户数及不同用户数情况下系统的响应时间和服务器的资源利用率（运动员在50，100，130公斤负重下身体生理指标（性能指标）数，确认他的最大负重130公斤，最大有效负重100公斤）（比如双十一的时候淘宝的用户数在10万人，100万人，500万人情况下系统的响应时间和资源利用率，确定他的最大用户数和最大有效用户数）</li><li>9.压力测试：在一定软硬件及网络条件下，通过模拟大量虚拟用户向服务器产生负载，使服务器的资源处于极限状态下长时间持续运行，以测试服务器在高负载情况下稳定运行（在100-120公斤负重下，长时间负重，能够稳定运行多久）（比如淘宝假如最大有效用户数是500万，那么在520万用户数长时间同时进行加入购物车，支付操作，向服务器发送数据的情况下，测试系统能稳定运行不出错的时间）</li><li>10.恢复测试：主要检查系统的容错能力（采用各种办法让系统崩溃，出错，查看系统是否能在规定时间内尽快恢复，启动系统）</li><li>11.易用性测试：测试软件是否易用，主观性比较强，一般要根据很多用户的测试反馈信息，才能评价易用性</li><li>12.回归测试：指错误修正后或软件功能，环境发生变化后进行的重新测试，确认修改部分不会对其他功能造成影响（bug本身的回归是否修复，相关联模块，影响模块是否因为修改出错）</li><li>13.Alpha测试：一种前期的用户测试，公司内部组织员工及部分用户，模拟实际操作情况下进行验收测试（内侧）</li><li>14.Beta测试：一种后期用户测试，此时系统已经通过内部测试，大部分错误已经改正，即将正式发行，在一个或多个真实的环境下发布版本，进行（公测）</li></ul><h2 id="6-软件测试常见误区"><a href="#6-软件测试常见误区" class="headerlink" title="6.软件测试常见误区"></a>6.软件测试常见误区</h2><ul><li>1.调试和测试时一样的<br>测试时发现问题（测试），调试是定位和解决问题（开发）</li><li>2.测试应当为保证质量负责<br> 测试也要为产品质量负责，但是质量是开发做出来的，不是测出来的，本身的质量基础首先要好。<br>整个项目组包括开发  测试，产品，业务整个团队都要保证软件质量</li><li>3.把开发人员安排做测试<br>开发会有思维定式对于自己所做的产品，要让专业的测试从第三方不同的角度，专业的测试知识，经验来对产品进行测试。</li><li>4.过分的依赖Beta测试（验收测试）<br>Beta测试属于公测阶段，面向真实用户，这个时候由用户来发现缺陷是不可以的，为时已晚，大量的错误还是要由测试在前期测试过程中发现解决。</li><li>5.测试是可以穷尽的<br> 测试是没有穷尽的，测试也不可能在有限的时间内发现所有的bug,测试工作是有计划和时间要求的</li><li>6.测试是枯燥乏味，缺乏创造力的工作<br>需要利用各种各样的工具和方法，创造各种场景，来测试出软件的表层和深层的缺陷</li></ul>]]></content>
    
    
    <categories>
      
      <category>testbasic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>testbasic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java类之间的调用</title>
    <link href="/2019/08/17/java/java%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8/"/>
    <url>/2019/08/17/java/java%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="类的调用"><a href="#类的调用" class="headerlink" title="类的调用"></a>类的调用</h1><h2 id="为什么要使用面向对象"><a href="#为什么要使用面向对象" class="headerlink" title="为什么要使用面向对象"></a>为什么要使用面向对象</h2><p>面向对象的程序设计方法是按照现实世界的观点，把复杂的事物抽象为对象，具有自己的状态和行为，通过对消息的反应来完成任务<br>为什么要定义类（思考）<br>java是面向对象程序设计语言，java程序是以类为基础构建的<br>类是事物共性的反应，对象是一类事物中的一个<br>定义一个类其实就相当于定义了一套解决问题的方法（函数).变量都是为了函数服务的  </p><h4 id="为什么要调用类"><a href="#为什么要调用类" class="headerlink" title="为什么要调用类"></a>为什么要调用类</h4><p>因为定义类就是拿来用的，调用类中的api是为了解决问题  </p><p>jdk中提供的类如何调用<br>为什么需要安装jdk<br>jdk提供了编译器<br>jdk提供了java运行环境（jre)<br>jre底下有很多现成的jar包，这些jar包构成了java se的一个基本框架，实现了基本的服务<br>jre下jar包中的类如何调用？<br>调用方法：通过import语句导入到当前类中然后直接拿来用<br>示例：如果调用jdk中的data类获取当前时间的时分秒  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Date;    <span class="hljs-comment">//导入Date类</span><br><span class="hljs-keyword">import</span> java.util.Random;  <span class="hljs-comment">//导入Random类</span><br><span class="hljs-keyword">import</span> java.util.*;      <span class="hljs-comment">//导入util包下面所有类</span><br></code></pre></td></tr></table></figure><p>打印当前日期</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> BiL &#123;       <br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>();//在main方法下实例化类<span class="hljs-type">Date</span>后会报错，提示要导入<span class="hljs-type">Date</span>的类<br>Random random = <span class="hljs-built_in">new</span> Random ();<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">date</span>);<br>&#125;<br>&#125;<br>控制台：Thu Sep <span class="hljs-number">28</span> <span class="hljs-number">22</span>:<span class="hljs-number">48</span>:<span class="hljs-number">20</span> CST <span class="hljs-number">2017</span><br></code></pre></td></tr></table></figure><h4 id="创建一个文件"><a href="#创建一个文件" class="headerlink" title="创建一个文件"></a>创建一个文件</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">File</span> f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;C:\\Program Files\\Java\\BiL.txt&quot;</span>);<span class="hljs-comment">//类的实例化，会报错需要import一下包，括号里输入要创建文件的路径以及文件名</span><br><span class="hljs-keyword">if</span>(!f.exists())&#123;<br>f.createNewFile();     <span class="hljs-comment">//如果不存在就创建一个文件</span><br> <br>&#125;<br></code></pre></td></tr></table></figure><p>有些包不需要引入比如 java.lang,其他全部需要import后使用</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">        String str <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><span class="hljs-comment">;</span><br>String str1<span class="hljs-operator">=</span> new String (<span class="hljs-string">&quot;abc&quot;</span>)<span class="hljs-comment">; 不需要导入可以直接实例化</span><br></code></pre></td></tr></table></figure><h4 id="JDK之外自定义的类如何调用"><a href="#JDK之外自定义的类如何调用" class="headerlink" title="JDK之外自定义的类如何调用"></a>JDK之外自定义的类如何调用</h4><p>有两个类，类A,类B,类A中要使用到类B,下面两种情况要将类B import 进类A<br>两个类 在一个项目下：<br>但是不在一个package下，则必须importB<br>两个类不在一个项目<br>则必须将类B所在项目以jar包的形式导出，然后作为类A所在项目的一个依赖包引入进来，这个时候再importB<br>import动作可以自动让eclipse帮咱们完成，也可以手动导入<br>一旦类Aimport了类B进来，我们就可以在当前类A去创建类B的对象，拿类B的对象调用类B的函数去做你想做的事，等等   </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java循环语句和条件语句</title>
    <link href="/2019/06/17/java/java%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/2019/06/17/java/java%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="循环语句和条件语句"><a href="#循环语句和条件语句" class="headerlink" title="循环语句和条件语句"></a>循环语句和条件语句</h1><h2 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h2><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">for</span><span class="hljs-params">(int i= <span class="hljs-number">1</span>；i&lt;=<span class="hljs-number">10</span>;i++)</span></span>&#123;<br>System<span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(i)  打印每一个i的值<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="语法解释："><a href="#语法解释：" class="headerlink" title="语法解释："></a>语法解释：</h3><p>i代表循环开始的值<br>第二个表达式i&lt;&#x3D;10代表的是循环下去的条件，只有满足条件，循环才会继续下去<br>i++代表走完了一个循环，所以i要自加1<br>三个表达式之间使用“”；“”来分隔的  </p><h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>i被初始化为1<br>i&lt;&#x3D;10成立，执行循环体<br>i++后变成2，执行判断，2&lt;&#x3D;10成立，执行循环体<br>i++后变成2，执行判断，3&lt;&#x3D;10成立，执行循环体  </p><h2 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h2><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1.</span><span class="hljs-keyword">do</span>&#123;<br>&#125;<span class="hljs-keyword">while</span>(条件<span class="hljs-number">1</span>）；<br><span class="hljs-number">2.</span><span class="hljs-keyword">while</span>（条件<span class="hljs-number">2</span>）&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二者的区别："><a href="#二者的区别：" class="headerlink" title="二者的区别："></a>二者的区别：</h2><p>do….while…不管条件满不满足，它是先执行再判断条件，所以循环体里的代码至少执行一次<br>while 只有在条件满足的时候才会执行  </p><h2 id="条件控制语句："><a href="#条件控制语句：" class="headerlink" title="条件控制语句："></a>条件控制语句：</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">switch</span>语句：<span class="hljs-keyword">switch</span>能够接收的变量类型也是有限的，只有以下类型：<span class="hljs-type">char</span> <span class="hljs-type">byte</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> <span class="hljs-built_in">String</span> <span class="hljs-keyword">enum</span><br><span class="hljs-keyword">switch</span>（变量a）&#123;<br>        <span class="hljs-keyword">case</span> a:<br>                   .......;<br>                   <span class="hljs-keyword">break</span>;<br>         <span class="hljs-keyword">case</span> b;<br>                  .........;<br>                   <span class="hljs-keyword">break</span>;<br>          ...........<br>           <span class="hljs-keyword">default</span>:<br>                    .........;<br>                     <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h4 id="语法详解："><a href="#语法详解：" class="headerlink" title="语法详解："></a>语法详解：</h4><p>switch有轮换的意思，针对switch里的变量a去匹配所有的case值，如匹配则执行相关case下的代码逻辑<br>case代表一种情形<br>：冒号表示若符合此种情形，后面就是要执行的代码<br>break：有打断的意思，这里表示不再往下执行。如果没有break会形成穿透效果继续往下执行<br>default：表示前面都没有满足条件时，将要执行的代码  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>    <span class="hljs-built_in">char</span> x =<span class="hljs-string">&#x27;C&#x27;</span>;<br><span class="hljs-keyword">switch</span> (x)&#123;<br><span class="hljs-keyword">case</span><span class="hljs-string">&#x27;A&#x27;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;分数90分以上&quot;</span>);<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span><span class="hljs-string">&#x27;B&#x27;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;分数80分以上&quot;</span>);<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span><span class="hljs-string">&#x27;C&#x27;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;分数70分以上&quot;</span>);<span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span><span class="hljs-string">&#x27;D&#x27;</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;分数60分以上&quot;</span>);<span class="hljs-keyword">break</span>;<br><span class="hljs-literal">default</span>:System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;不及格&quot;</span>);<span class="hljs-keyword">break</span>;<br>&#125;;<br><span class="hljs-built_in">int</span> x =<span class="hljs-number">20</span>;<br><span class="hljs-comment">//      switch (x)&#123;</span><br><span class="hljs-comment">//      case 10:System.out.println(&quot;10元&quot;);break;</span><br><span class="hljs-comment">//      case 20:System.out.println(&quot;20元&quot;);break;</span><br><span class="hljs-comment">//      case 30:System.out.println(&quot;30元&quot;);break;</span><br><span class="hljs-comment">//      default:System.out.println(&quot;0元&quot;);break;</span><br><span class="hljs-keyword">if</span> ....<span class="hljs-keyword">else</span>  <span class="hljs-keyword">if</span> ....<span class="hljs-keyword">else</span>语句<br><span class="hljs-number">1.</span><span class="hljs-keyword">if</span>(条件)&#123;<br>            .......<span class="hljs-comment">//条件1成立，则执行这里的代码</span><br>   &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;<br>            ......<span class="hljs-comment">//条件2成立，则执行这里的代码</span><br>   &#125;<span class="hljs-keyword">else</span>&#123;<br>           ........<span class="hljs-comment">//条件1和2都不成立，则执行这里的代码</span><br>   &#125;<br><span class="hljs-number">2.</span><span class="hljs-keyword">if</span>(条件<span class="hljs-number">1</span>)&#123;<br>            ......<span class="hljs-comment">//如果条件1成立，则执行这里的代码</span><br>&#125;<br>  <span class="hljs-keyword">if</span>(条件<span class="hljs-number">2</span>)&#123;<br>            .....<span class="hljs-comment">//如果条件2成立，则执行这里的代码</span><br>&#125;<br><span class="hljs-keyword">if</span>（条件<span class="hljs-number">3</span>）&#123;<br>            ....<span class="hljs-comment">//如果条件3成立，则执行这里的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>判断条件的次数</p><ul><li>if….else if …..else 按照顺序来判断，一旦满足了某个条件，就不在执行其他的判断</li><li>if….if….if….if…..:按照顺序来判断，不管条件满足与否，每个条件都会判断一次</li></ul><p>break中断整个循环</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">4</span>;i++)&#123;<br>      <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-keyword">break</span>;<br>          &#125;<br>     <br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;循环的第&quot;</span>+i+<span class="hljs-string">&quot;个值&quot;</span>);<br>      &#125;<br><span class="hljs-keyword">continue</span>中断当次循环<br><span class="hljs-keyword">for</span>(int i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">4</span>;i++)&#123;<br>      <span class="hljs-keyword">if</span>(i==<span class="hljs-number">3</span>)&#123;<br>          <span class="hljs-keyword">continue</span>;<br>          &#125;<br>     <br>      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;循环的第&quot;</span>+i+<span class="hljs-string">&quot;个值&quot;</span>);<br>      &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java变量及变量类型</title>
    <link href="/2019/03/17/java/java%E5%8F%98%E9%87%8F%E5%8F%8A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/03/17/java/java%E5%8F%98%E9%87%8F%E5%8F%8A%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="java变量及变量类型"><a href="#java变量及变量类型" class="headerlink" title="java变量及变量类型"></a>java变量及变量类型</h1><p>##概念：<br>变量就是用来存储数据的<br>声明：数据类型  变量名称 &#x3D; 数据值；  </p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>是指在程序中，我们自己定义的内容。比如类的名字，方法的名字和变量的名字等等，都是标识符</p><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ul><li>标识符可以包含英文字母26个（区分大小写），0-9数字，$美元符号和_下划线</li><li>标识符不能以数字开头</li><li>标识符不能是关键字</li></ul><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）</li><li>变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）</li><li>方法名规范：同变量名</li></ul><p>定义一个x变量，并赋值4给它<br>数学中x&#x3D;4<br>java中 int x &#x3D;4;<br>此处int是变量的类型，因为在java这门语言中任何数据都是有类型的，所以变量前面需要声明变脸那个的类型，<br>分类：按照数据类型分<br>基本数据类型变量<br>引用数据类型变量  </p><h2 id="八大基本数据类型"><a href="#八大基本数据类型" class="headerlink" title="八大基本数据类型"></a>八大基本数据类型</h2><p>按照类型分为四类八种</p><ul><li>1.逻辑类型<br>boolean(布尔类型）取值范围为true&#x2F;false</li><li>2.整型（整数）<ul><li>byte(字节型），取值范围：-128~127</li><li>short(短整型），取值范围：-32768~32767</li><li>int(整数)，取值范围：-2147483648~2147483647</li><li>long(长整型），取值范围：-9223372036854775808 ~92233720368547758087</li></ul></li><li>3.浮点型（小数）<ul><li>float(单精度的浮点型)1.4E-45~3.4028235E38</li><li>double(双精度的浮点型)4.9E-324~1.7976931348623157E308</li><li>char(字符型)：char类型的变量，赋值的时候数据长度只能是一位，并且用’’包起来</li></ul></li></ul><p>区别就是范围不同</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">byte</span> a = <span class="hljs-number">1</span>;        long d =<span class="hljs-number">4</span>;<br><span class="hljs-attribute">short</span> b =<span class="hljs-number">2</span>;       float e =<span class="hljs-number">2</span>.<span class="hljs-number">1</span>f;  f是为了跟doubel区别开<br><span class="hljs-attribute">int</span> c =<span class="hljs-number">3</span>;            double f =<span class="hljs-number">2</span>.<span class="hljs-number">1</span>;    char a =&#x27;A&#x27;;<br></code></pre></td></tr></table></figure><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>引用类型-字符串 String<br>字符串的变量一般是用来存储一串文字信息<br>字符串可以跟任意类型的数据进行拼接得到新的字符串，拼接符号为“+”：和字符串拼接不会计算，int型拼接会进行计算  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&quot;hello&quot;+&quot;world&quot;<span class="hljs-comment">-------helloworld</span><br>&quot;hello&quot;+<span class="hljs-number">1234</span><span class="hljs-comment">--------hello1234</span><br>String a = &quot;我是一个字符串&quot;；双引号，可以存字符串(  <span class="hljs-type">char</span> b = <span class="hljs-string">&#x27;B&#x27;</span> <span class="hljs-type">char</span>只能存一个,单引号)<br>String  c = &quot;c&quot;;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(a+c);<br></code></pre></td></tr></table></figure><h2 id="引用类型-数组"><a href="#引用类型-数组" class="headerlink" title="引用类型 数组"></a>引用类型 数组</h2><p>数组是一种数据结构，它是一个结构，用来盛放容器，不同类型的数组可以盛放不同类型的数据<br>数组的特点<br>数组的容量是确定的，也就是说在定义数组时必须制定数组的大小，<br>数组的类型是确定的，也就是在定义数组时必须声明数组的类型，一种类型的数组只能放一种类型的数据  </p><h4 id="创建数组的语法："><a href="#创建数组的语法：" class="headerlink" title="创建数组的语法："></a>创建数组的语法：</h4><p>创建了一个数组，但是没有初始化数组的元素，这种情况要制定数组的大小<br>数据类型【】数组名&#x3D;new  数据类型【size】;<br>示例int[]myArr&#x3D;new int[3];<br>创建一个数组，并已知数组的内部元素<br>示例：int【】myArr&#x3D;{0,1,2}  </p><h4 id="数组取值"><a href="#数组取值" class="headerlink" title="数组取值"></a>数组取值</h4><p>对数组的赋值方式  </p><ul><li>1.在创建数组的时候赋值</li><li>2.通过操作索引来赋值，索引是从0开始的<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs prolog">int[]a = new int [n];<br>a[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>a[<span class="hljs-number">1</span>]=<span class="hljs-number">5</span>;<br>a[<span class="hljs-number">2</span>]=<span class="hljs-number">8</span>;<br>a[n<span class="hljs-number">-1</span>]=<span class="hljs-number">45</span>;<br>不同数据类型的数组赋值示例<br>char[ ]d=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>int [ ]b=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>long[ ]c=&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;;<br>float[ ]d=&#123;<span class="hljs-number">1.1</span>f,<span class="hljs-number">1.2</span>f,<span class="hljs-number">1.3</span>f&#125;;<br>double[ ]e=&#123;<span class="hljs-number">2.1</span>,<span class="hljs-number">2.1</span>,<span class="hljs-number">2.3</span>&#125;;<br>boolean[ ]f=&#123;true,false,true&#125;;<br><span class="hljs-symbol">String</span>[ ]h=&#123;<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;world&quot;</span>&#125;;<br>------------------------------------------------<br>double [ ]c=new double[<span class="hljs-number">3</span>];<br>c[<span class="hljs-number">0</span>]=<span class="hljs-number">2.1</span>;<br>c[<span class="hljs-number">1</span>]=<span class="hljs-number">2.2</span>;<br>c[<span class="hljs-number">2</span>]=<span class="hljs-number">2.3</span>;<br><span class="hljs-symbol">String</span>[ ]f =new <span class="hljs-symbol">String</span>[<span class="hljs-number">3</span>];<br>f[<span class="hljs-number">0</span>]=<span class="hljs-string">&quot;诺诺语录1&quot;</span>;<br>f[<span class="hljs-number">1</span>]=<span class="hljs-string">&quot;诺诺语录2&quot;</span>;<br>f[<span class="hljs-number">2</span>]=<span class="hljs-string">&quot;诺诺语录3&quot;</span>;<br><span class="hljs-symbol">System</span>.out.println(<span class="hljs-string">&quot;字符串数据第3个元素的值：&quot;</span>+f[<span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>当数据类型不一样时，将会发生数据类型转换  </p><h4 id="自动类型转换（隐式）"><a href="#自动类型转换（隐式）" class="headerlink" title="自动类型转换（隐式）"></a>自动类型转换（隐式）</h4><ul><li>1.特点：代码不需要进行特殊处理自动完成</li><li>2.规则：数据范围从小到大<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span>&#123;<br>      <span class="hljs-comment">// 左边是long类型，右边是默认的int类型，左右不一样</span><br>     <span class="hljs-comment">// 一个等号代表赋值，将右侧的int常量，交给左侧的long变量进行存储</span><br>     <span class="hljs-comment">// int --&gt;long 符合了数据范围从小到大的原则 </span><br>     <span class="hljs-comment">// 也发生了自动类型转换</span><br>      <span class="hljs-built_in">long</span> num =<span class="hljs-number">100</span>;<br>      System.<span class="hljs-keyword">out</span>.println(num);<br>     <br>  &#125;<br>  &#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="强制类型转换（显示）"><a href="#强制类型转换（显示）" class="headerlink" title="强制类型转换（显示）"></a>强制类型转换（显示）</h4>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java变量和函数</title>
    <link href="/2019/02/17/java/java%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <url>/2019/02/17/java/java%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="java变量和函数"><a href="#java变量和函数" class="headerlink" title="java变量和函数"></a>java变量和函数</h1><h4 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">/ 第一行的第三个单词必须和所在的文件名称完全一样，大小写也要一样<br><span class="hljs-comment">// public class后面定义一个类的名称，类是java当中所有源代码的基本组织单位</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HelloWorl</span><br>    // 第二行的内容是万年不变的固定写法，代表<span class="hljs-symbol">main</span>方法<br>    // 这一行代表程序执行的起点<br>    <span class="hljs-symbol">public</span> <span class="hljs-symbol">static</span> <span class="hljs-symbol">void</span> <span class="hljs-symbol">main</span>(<span class="hljs-symbol">String</span>[] <span class="hljs-symbol">args</span>)&#123;<br>    <span class="hljs-comment">// 第三行代表打印输出语句（其实就是屏幕显示）</span><br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>在程序运行期间，固定不变的量</p><h4 id="常量的分类："><a href="#常量的分类：" class="headerlink" title="常量的分类："></a>常量的分类：</h4><ul><li>字符串常量：凡是用双引号引起来的部分，叫做字符串常量 例如”abc”,”hello”,”123”</li><li>整数常量：直接写上的数字，没有小数点。例如100，200，0，-250</li><li>浮点数常量：直接写上的数字，有小数点 例如100.12,2.5</li><li>字符常量：凡是用单引号引起来的单个字符，就是字符常量 两个单引号之间必须有且仅有一个字符，没有不行两个不行 例如 “9”,”a”,”A”,”中”</li><li>布尔常量：只有两种取值 true false</li><li>空常量：null 代表没有任何数据</li></ul><p>类的组成（三部分）<br>全局变量（成员变量）和局部变量<br>成员方法（函数）  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>按照变量的数据类型分类</p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>字符型 char</li><li>布尔   boolean</li><li>整型   byte short int（默认） long(如果一定要使用float类型需要加上一个后缀F) long num &#x3D; 3000000L</li><li>浮点型 float（如果一定要使用float类型，需要加上一个后缀F) flaot num2 &#x3D; 2.5F double(默认)<br>如果使用byte short类型的变量 那么右侧的数据值不能超过左侧类型的范围</li></ul><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>String 数组</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>从定义变量的一行开始，一直到直接所属的大括号结束为止</p><h2 id="使用变量的注意事项："><a href="#使用变量的注意事项：" class="headerlink" title="使用变量的注意事项："></a>使用变量的注意事项：</h2><ul><li>1.如果创建多个变量，那么变量之间的名称不可以重复</li><li>2.对于float和long类型来说，字母后缀F L不要丢掉</li><li>3.如果使用byte或者short类型的变量，那么右侧的数据值不能超过左侧类型的范围</li><li>4.没有进行赋值的变量，不能直接使用；一定要赋值以后才能使用</li><li>5.变量使用不能超过作用域的范围</li><li>6.可以通过一个语句来创建多个变量，但是一般情况下不推荐这么写。</li></ul><p>根据变量定义的位置不同（或者说根据变量的作用域范围）</p><p>局部变量<br>全局变量（成员变量）<br>局部变量</p><p>局部变量是指一个方法内定义的变量，根据定义形式不同分为以下三种<br>方法内：定义在方法体内，作用域为定义变量处到方法结束，必须初始化<br>代码块：定义在代码块中的变量，作用域为定义变量处到代码块结束，必须初始化<br>形式参数：定义方法时定义的变量，作用域为整个方法内，无须显示初始化，形参的初始化是在调用该方法时由系统完成，系统会将实参赋值给形参<br>例 int x &#x3D;1;</p><h4 id="局部变量特点："><a href="#局部变量特点：" class="headerlink" title="局部变量特点："></a>局部变量特点：</h4><ul><li>没有修饰符   </li><li>定义在函数内部</li><li>作用域只限于对应的函数，，但是局部变量和成员变量可以重名</li></ul><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>全局变量是在类范围内定义的变量，也称为成员变量或类属性</p><h4 id="全局变量特点："><a href="#全局变量特点：" class="headerlink" title="全局变量特点："></a>全局变量特点：</h4><p>有修饰符  public公有的 privite私有的 default默认的 protected被保护的<br>函数外部<br>作用域为整个类，只有类消亡的时候，这个变量才会消亡</p><p><img src="/../.vuepress/public/picture/Snipaste_2021-06-16_13-13-57.png"></p><p>在方法外定义完就能被所有方法调用，不用考虑在方法前还是方法后定义，只要定义了就可以用<br>全局变量的名字可以和局部变量的名字重复<br>        public static int x &#x3D;6;<br>private int h&#x3D;20;<br>int y&#x3D;30;<br>protected int z &#x3D;50;<br>函数的概念，分类以及语法：<br>函数的概念<br>函数就是定义在类中的具有特定功能的一段独立小程序，函数也称为方法，通俗的说，方法是一段可重复调用的代码段<br>函数基本分为两类<br>构造函数<br>普通函数：静态方法和实例方法：</p><p>普通函数（非构造函数）<br>语法：                                         x形式参数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">修饰符 函数返回值类型 函数名（参数类型 参数名...)&#123;<br>                    函数体....<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span></span>&#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="语法详解"><a href="#语法详解" class="headerlink" title="语法详解"></a>语法详解</h4><h5 id="修饰符：分为public-protected-default-privite-从左到右权限逐步降低"><a href="#修饰符：分为public-protected-default-privite-从左到右权限逐步降低" class="headerlink" title="修饰符：分为public protected  default privite  从左到右权限逐步降低"></a>修饰符：分为public protected  default privite  从左到右权限逐步降低</h5><ul><li>public 公开访问权限，类和子类，同一包的类和子类，都可以访问</li><li>protected:设置权限的类中可以访问，不同包中的子类也可以访问</li><li>private:访问的权限最小，仅在该类中访问（封装思想）</li></ul><h5 id="函数返回值类型："><a href="#函数返回值类型：" class="headerlink" title="函数返回值类型："></a>函数返回值类型：</h5><ul><li>八大基本类型&#x2F;引用类型（无返回值使用void关键字表示）</li><li>函数名：随便定义，语法要求第一个字母小写，函数名要见名知意</li><li>参数类型：基本类型&#x2F;引用类型，个数可以无限个，</li><li>1.没有返回值的时候用void，有返回值的时候用return<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;i want to fly&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span></span>)&#123;<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;i want to fly&quot;</span>);          函数名字相同形参不同也可以，形参一样不成立<br>&#125;<br></code></pre></td></tr></table></figure>静态方法就是有static，可以直接通过类名调用，类名.函数方法名（）；<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">getNam</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;特别的周诺&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>BianLiang p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BianLiang</span>();<br>BianLiang.<span class="hljs-built_in">getNam</span>(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure>控制台输出：特别的周诺</li></ul><h5 id="2-实例方法调用"><a href="#2-实例方法调用" class="headerlink" title="2.实例方法调用"></a>2.实例方法调用</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x,<span class="hljs-built_in">int</span> y</span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> x+y;              有返回值时用<span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>QuanJU ff= <span class="hljs-keyword">new</span> QuanJU();  <span class="hljs-comment">//函数实例化  类名 变量=new 类名（）；</span><br>System.<span class="hljs-keyword">out</span>.println(ff.<span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>,<span class="hljs-number">10</span>));<span class="hljs-comment">//非构造函数的传参</span><br>&#125;<br></code></pre></td></tr></table></figure><p>控制台返回：15</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arduino">       <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getName</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">return</span><span class="hljs-string">&quot;蛋蛋老师&quot;</span>;  <span class="hljs-comment">//return返回的内容类型必须和返回值类型一致，传参的参数类型必须和参数类型一致</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>QuanJU ff= <span class="hljs-keyword">new</span> <span class="hljs-built_in">QuanJU</span>();<br>System.out.<span class="hljs-built_in">println</span>(ff.<span class="hljs-built_in">getName</span>(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>));  只要输入的参数是数字，无论输入什么数字，返回的都是蛋蛋老师<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台返回蛋蛋老师</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getName</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>)&#123;<br><span class="hljs-keyword">return</span><span class="hljs-string">&quot;特别的&quot;</span>+name;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br><span class="hljs-title class_">QuanJU</span> ff= <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuanJU</span>();<br><span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(ff.<span class="hljs-title function_">getName</span>(<span class="hljs-string">&quot;周诺&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">   控制台返回：特别的周诺</code></pre><h5 id="函数调用注意事项"><a href="#函数调用注意事项" class="headerlink" title="函数调用注意事项"></a>函数调用注意事项</h5><ul><li>非构造函数的调用，需要用到类（静态方法）或对象（普通方法）来调用</li><li>通过对象进行方法调用</li><li>创建对象：Person person&#x3D;new Person();</li><li>用对象调用普通函数int age&#x3D;person.getAge();<br>                          String name&#x3D;person.getName();</li></ul><h5 id="函数调用注意事项："><a href="#函数调用注意事项：" class="headerlink" title="函数调用注意事项："></a>函数调用注意事项：</h5><ul><li>传参：若要调用的函数有参数，则必须传入参数，而且传参类型要一致，个数也要一致，没有则不需要传参</li><li>返回值：返回值类型要一致int age&#x3D;person.getAge();<br>                          String name&#x3D;person.getName();</li><li>用return来返回（对于返回值为空类型的函数，不需要return语句返回任何东西，但是其实默认有一个return语句的买这个return语句比较特殊：return;)</li></ul><p>类和对象和定义，关系<br>构造函数的语法，用法</p><h2 id="什么事面向对象"><a href="#什么事面向对象" class="headerlink" title="什么事面向对象"></a>什么事面向对象</h2><p>Java是一门面向对象的语言，什么是对象？在Java中，一切事物皆可以看作对象，比如人，自行车，电脑，港币，汽车，电灯泡等等、拿人来举例，每一个人都可以看成一个对象，、<br>每个人都有属性：姓名 性别 年龄 身高等等，以及吃饭睡觉学习等行为，这在Java里体现为每个对象都有属性和函数，我们谈论一个人的姓名 年龄这些属性或者吃饭睡觉这些行为都是建立在具体的某个对象的基础上，没有具体的对象，那这些都不存在。这个就是咱们Java面向对象的一个思想</p><h3 id="面向对象的两个最重要的概念：类与对象"><a href="#面向对象的两个最重要的概念：类与对象" class="headerlink" title="面向对象的两个最重要的概念：类与对象"></a>面向对象的两个最重要的概念：类与对象</h3><p>类：共性事物的抽象，是对某一类具有共性实物的描述，是概念上的定义<br>对象：对象是共性事物的一个体现，是这类事物的每个个体，或者说是类的一个实例（instance)<br>总结：类是对象的模板。对象是类的实例</p><h2 id="对象的性质"><a href="#对象的性质" class="headerlink" title="对象的性质"></a>对象的性质</h2><p>什么事对象<br>一个对象是数据和相关方法的集合，对象是一个类事物中的一个实例，数据是对象的状态，方法是对象的行为<br>对象特点<br>面向对象概念构成了Java的核心，面向对象具有封装  继承  多态三大特征</p><h2 id="类和对象的定义"><a href="#类和对象的定义" class="headerlink" title="类和对象的定义"></a>类和对象的定义</h2><p>类的组成：属性和方法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span>类软件测试需求分析.<span class="hljs-title">note</span>名称</span>&#123;<br>       数据类型 属性;<span class="hljs-regexp">//</span>声明成员变量（属性）<br>       .....<br>       public 返回值数据类型 方法名称（参数<span class="hljs-number">1</span>，参数<span class="hljs-number">2</span>...）&#123;<br>                           <span class="hljs-regexp">//</span>TODO 程序语句<br>                            [<span class="hljs-keyword">return</span>表达式；]<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象的创建与使用"><a href="#对象的创建与使用" class="headerlink" title="对象的创建与使用"></a>对象的创建与使用</h2><ul><li>类名称 对象名称&#x3D;null;&#x2F;&#x2F;声明对象</li><li>对象名称&#x3D;new 类名称（）;&#x2F;&#x2F;实例化对象，对象必须要实例化才能直接使用。不实例化指那个在main方法里面使用<br>或：</li><li>类名称 对象名称&#x3D;new 类名称（）;</li></ul><p>有了对象，就可以调用定义的一系列操作了</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BianLiang</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> height;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;吃饭&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span>()</span>&#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;睡觉&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>                  BianLiang p = <span class="hljs-keyword">new</span> BianLiang();<span class="hljs-comment">//对象实例化</span><br>p.eat();p.sleep();<span class="hljs-comment">//访问方法</span><br>    p.name=<span class="hljs-string">&quot;周诺&quot;</span>;<span class="hljs-comment">//给成员变量赋值</span><br>                 p.age=<span class="hljs-number">26</span>;<br>                 p.height=<span class="hljs-number">163</span>;<br>System.<span class="hljs-keyword">out</span>.println(p.age);<span class="hljs-comment">//访问成员变量</span><br>               System.<span class="hljs-keyword">out</span>.println(p.name);<br>                System.<span class="hljs-keyword">out</span>.println(p.height);<br>                       <br>控制台：<br>吃饭<br>睡觉<br><span class="hljs-number">26</span><br>周诺<br><span class="hljs-number">163</span><br></code></pre></td></tr></table></figure><h4 id="访问类中的属性和方法："><a href="#访问类中的属性和方法：" class="headerlink" title="访问类中的属性和方法："></a>访问类中的属性和方法：</h4><h4 id="访问属性："><a href="#访问属性：" class="headerlink" title="访问属性："></a>访问属性：</h4><p>对象名称.属性名</p><h4 id="为属性赋值：-对象名称-属性名-值；"><a href="#为属性赋值：-对象名称-属性名-值；" class="headerlink" title="为属性赋值： 对象名称.属性名&#x3D;值；"></a>为属性赋值： 对象名称.属性名&#x3D;值；</h4><h4 id="访问方法："><a href="#访问方法：" class="headerlink" title="访问方法："></a>访问方法：</h4><p>对象名称.方法名（）;</p><h2 id="构造函数的概念及分类"><a href="#构造函数的概念及分类" class="headerlink" title="构造函数的概念及分类"></a>构造函数的概念及分类</h2><p>构造函数的概念<br>构造函数是用来构造对象的函数</p><h4 id="构造函数分类"><a href="#构造函数分类" class="headerlink" title="构造函数分类"></a>构造函数分类</h4><ul><li>无参构造函数（默认构造函数）  不写也可以，系统会默认创建一个无参构造函数</li><li>带参构造函数  参数就是为了赋值的</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>类名</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim">无参构造函数：修饰符+函数名（）<span class="hljs-meta">&#123;......&#125;</span><br>             public <span class="hljs-type">Person</span>()&#123;<br>               ..........<span class="hljs-number">2</span> ...........<br>              &#125;                       类名<br></code></pre></td></tr></table></figure><p>带参构造函数：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">修饰符+函数名（参数类型 参数名<span class="hljs-params">...</span>）&#123;<span class="hljs-params">...</span>..&#125;<br>            <span class="hljs-keyword">public</span> Person(int age,<span class="hljs-built_in">String</span> name)&#123;<br>           <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span> <span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><br>            &#125;<br><span class="hljs-keyword">public</span> BiL ()&#123;<br>      System.out.println(<span class="hljs-string">&quot;调用无参构造函数&quot;</span>); <span class="hljs-comment">//无参构造函数</span><br>    &#125;<br><span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span> args) &#123;<br>        BiL P = new BiL(); //即使上面的无参构造函数不申明，也可以调用对象。系统会自动申明<br></code></pre></td></tr></table></figure><p>有参构造函数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BiL</span> &#123;<br>       <br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> height;<br>   <br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiL</span><span class="hljs-params">(<span class="hljs-type">int</span> age,<span class="hljs-type">String</span> name,<span class="hljs-type">int</span> height)</span></span>&#123;<br>  <span class="hljs-keyword">this</span>.age=age;<span class="hljs-comment">//this代表类名（BiL),this.age调用的是上面申明的成员变量。等于号右边age就近原则就是括号里刚刚申明的形参的值</span><br>  <span class="hljs-keyword">this</span>.name=name; <span class="hljs-comment">//意思是把形参的值赋值给类中对应的成员变量</span><br>  <span class="hljs-keyword">this</span>.height=height;<br> <br>  &#125;<br><br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;i want to eat&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">()</span></span>&#123;<br>System.out.<span class="hljs-built_in">println</span>(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">&quot;i want to sleep&quot;</span>);<br>&#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        BiL P = <span class="hljs-keyword">new</span> <span class="hljs-built_in">BiL</span>(<span class="hljs-number">28</span>,<span class="hljs-string">&quot;周诺&quot;</span>,<span class="hljs-number">180</span>);<span class="hljs-comment">//有参构造函数传参</span><br>   P.<span class="hljs-built_in">eat</span>();P.<span class="hljs-built_in">sleep</span>();<br>           System.out.<span class="hljs-built_in">println</span>(P.age);<br>   System.out.<span class="hljs-built_in">println</span>(P.name);<br>   System.out.<span class="hljs-built_in">println</span>(P.height);<br>&#125;<br>&#125;<br> <br><br>控制台：<br>周诺i want to eat<br>周诺i want to sleep<br><span class="hljs-number">28</span><br>周诺<br><span class="hljs-number">180</span><br></code></pre></td></tr></table></figure><p>注意：static方法里面不能使用this</p><p>空白处右键-source-Generate Constructor using Fileds-可以全选<br>权限后eclipse可以帮你自动生成有参构造函数，不选的话就会生成无参构造函数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiL</span><span class="hljs-params">(<span class="hljs-type">int</span> age, <span class="hljs-type">String</span> name, <span class="hljs-type">int</span> height)</span> </span>&#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-keyword">this</span>.age = age;<br><span class="hljs-keyword">this</span>.name = name;<br><span class="hljs-keyword">this</span>.height = height;<br>&#125;<br>帮你自动生成<br>都不选的话，会生成如下：无参构造函数<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BiL</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">super</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="语法详解-1"><a href="#语法详解-1" class="headerlink" title="语法详解"></a>语法详解</h2><p>函数返回值：无<br>参数类型：八大基本类型&#x2F;引用类型<br>函数调用注意事项<br>构造函数的调用<br>我们通常只在一种情况下才会去调用构造函数，那就是创建对象，调用构造函数时，用关键字new来调用，方法是：<br>类名 对象名&#x3D;new 类名（）；<br>或者：类名 对象名 &#x3D;new 类名（value1,value2……）<br>调用带参构造函数来创造对象，可以按照我们的医院来初始化对象的属性，而调用无参构造函数构造出来的对象，她的所有属性都是他的属性对应类型的默认值<br>默认构造函数是自带的，编译器在编译你的Java代码的时候，若发现你的类里面有调用无参构造函数创建对象，但是你的类里面又没有显示的声明无参构造函数，那么类编译器就会自动帮你补齐这个无参构造函数，（类里面没有定义带参构造函数）。如果你的类里有定义带参构造函数，那默认构造函数就被覆盖掉了，此时若要调用午餐构造函数则必须显示定义无参构造函数，否则会报错  </p><p>构造函数构造对象是的内存分配<br>创建如下对象时，Java内存分配是如何的呢<br>CAR car1&#x3D;new car();<br>CAR car2&#x3D;new car(“宝马”，100);  </p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
